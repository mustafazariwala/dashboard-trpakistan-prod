(function () {
  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

  function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  (self["webpackChunkcuba"] = self["webpackChunkcuba"] || []).push([["default-node_modules_ks89_angular-modal-gallery___ivy_ngcc___fesm2015_ks89-angular-modal-gall-4edc15"], {
    /***/
    65072: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "BreakpointObserver": function BreakpointObserver() {
          return (
            /* binding */
            _BreakpointObserver
          );
        },

        /* harmony export */
        "Breakpoints": function Breakpoints() {
          return (
            /* binding */
            _Breakpoints
          );
        },

        /* harmony export */
        "LayoutModule": function LayoutModule() {
          return (
            /* binding */
            _LayoutModule
          );
        },

        /* harmony export */
        "MediaMatcher": function MediaMatcher() {
          return (
            /* binding */
            _MediaMatcher
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/cdk/coercion */
      39490);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs */
      79765);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! rxjs */
      9112);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! rxjs */
      29923);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(
      /*! rxjs */
      69165);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! rxjs/operators */
      15257);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! rxjs/operators */
      13653);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! rxjs/operators */
      54395);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! rxjs/operators */
      88002);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(
      /*! rxjs/operators */
      39761);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(
      /*! rxjs/operators */
      46782);
      /* harmony import */


      var _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/cdk/platform */
      80521);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _LayoutModule = function _LayoutModule() {
        _classCallCheck(this, _LayoutModule);
      };

      _LayoutModule.ɵfac = function LayoutModule_Factory(t) {
        return new (t || _LayoutModule)();
      };

      _LayoutModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _LayoutModule
      });
      _LayoutModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({});

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_LayoutModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{}]
        }], null, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Global registry for all dynamically-created, injected media queries. */


      var mediaQueriesForWebkitCompatibility = new Set();
      /** Style tag that holds all of the dynamically-created media queries. */

      var mediaQueryStyleNode;
      /** A utility for calling matchMedia queries. */

      var _MediaMatcher = /*#__PURE__*/function () {
        function _MediaMatcher(_platform) {
          _classCallCheck(this, _MediaMatcher);

          this._platform = _platform;
          this._matchMedia = this._platform.isBrowser && window.matchMedia ? // matchMedia is bound to the window scope intentionally as it is an illegal invocation to
          // call it from a different scope.
          window.matchMedia.bind(window) : noopMatchMedia;
        }
        /**
         * Evaluates the given media query and returns the native MediaQueryList from which results
         * can be retrieved.
         * Confirms the layout engine will trigger for the selector query provided and returns the
         * MediaQueryList for the query provided.
         */


        _createClass(_MediaMatcher, [{
          key: "matchMedia",
          value: function matchMedia(query) {
            if (this._platform.WEBKIT) {
              createEmptyStyleRule(query);
            }

            return this._matchMedia(query);
          }
        }]);

        return _MediaMatcher;
      }();

      _MediaMatcher.ɵfac = function MediaMatcher_Factory(t) {
        return new (t || _MediaMatcher)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
      };

      _MediaMatcher.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
        factory: function MediaMatcher_Factory() {
          return new _MediaMatcher((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform));
        },
        token: _MediaMatcher,
        providedIn: "root"
      });

      _MediaMatcher.ctorParameters = function () {
        return [{
          type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_MediaMatcher, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _angular_cdk_platform__WEBPACK_IMPORTED_MODULE_1__.Platform
          }];
        }, null);
      })();
      /**
       * For Webkit engines that only trigger the MediaQueryListListener when
       * there is at least one CSS selector for the respective media query.
       */


      function createEmptyStyleRule(query) {
        if (mediaQueriesForWebkitCompatibility.has(query)) {
          return;
        }

        try {
          if (!mediaQueryStyleNode) {
            mediaQueryStyleNode = document.createElement('style');
            mediaQueryStyleNode.setAttribute('type', 'text/css');
            document.head.appendChild(mediaQueryStyleNode);
          }

          if (mediaQueryStyleNode.sheet) {
            mediaQueryStyleNode.sheet.insertRule("@media ".concat(query, " {.fx-query-test{ }}"), 0);
            mediaQueriesForWebkitCompatibility.add(query);
          }
        } catch (e) {
          console.error(e);
        }
      }
      /** No-op matchMedia replacement for non-browser platforms. */


      function noopMatchMedia(query) {
        // Use `as any` here to avoid adding additional necessary properties for
        // the noop matcher.
        return {
          matches: query === 'all' || query === '',
          media: query,
          addListener: function addListener() {},
          removeListener: function removeListener() {}
        };
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Utility for checking the matching state of @media queries. */


      var _BreakpointObserver = /*#__PURE__*/function () {
        function _BreakpointObserver(_mediaMatcher, _zone) {
          _classCallCheck(this, _BreakpointObserver);

          this._mediaMatcher = _mediaMatcher;
          this._zone = _zone;
          /**  A map of all media queries currently being listened for. */

          this._queries = new Map();
          /** A subject for all other observables to takeUntil based on. */

          this._destroySubject = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
        }
        /** Completes the active subject, signalling to all other observables to complete. */


        _createClass(_BreakpointObserver, [{
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this._destroySubject.next();

            this._destroySubject.complete();
          }
          /**
           * Whether one or more media queries match the current viewport size.
           * @param value One or more media queries to check.
           * @returns Whether any of the media queries match.
           */

        }, {
          key: "isMatched",
          value: function isMatched(value) {
            var _this = this;

            var queries = splitQueries((0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceArray)(value));
            return queries.some(function (mediaQuery) {
              return _this._registerQuery(mediaQuery).mql.matches;
            });
          }
          /**
           * Gets an observable of results for the given queries that will emit new results for any changes
           * in matching of the given queries.
           * @param value One or more media queries to check.
           * @returns A stream of matches for the given queries.
           */

        }, {
          key: "observe",
          value: function observe(value) {
            var _this2 = this;

            var queries = splitQueries((0, _angular_cdk_coercion__WEBPACK_IMPORTED_MODULE_3__.coerceArray)(value));
            var observables = queries.map(function (query) {
              return _this2._registerQuery(query).observable;
            });
            var stateObservable = (0, rxjs__WEBPACK_IMPORTED_MODULE_4__.combineLatest)(observables); // Emit the first state immediately, and then debounce the subsequent emissions.

            stateObservable = (0, rxjs__WEBPACK_IMPORTED_MODULE_5__.concat)(stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_6__.take)(1)), stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.skip)(1), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.debounceTime)(0)));
            return stateObservable.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(function (breakpointStates) {
              var response = {
                matches: false,
                breakpoints: {}
              };
              breakpointStates.forEach(function (_ref) {
                var matches = _ref.matches,
                    query = _ref.query;
                response.matches = response.matches || matches;
                response.breakpoints[query] = matches;
              });
              return response;
            }));
          }
          /** Registers a specific query to be listened for. */

        }, {
          key: "_registerQuery",
          value: function _registerQuery(query) {
            var _this3 = this;

            // Only set up a new MediaQueryList if it is not already being listened for.
            if (this._queries.has(query)) {
              return this._queries.get(query);
            }

            var mql = this._mediaMatcher.matchMedia(query); // Create callback for match changes and add it is as a listener.


            var queryObservable = new rxjs__WEBPACK_IMPORTED_MODULE_10__.Observable(function (observer) {
              // Listener callback methods are wrapped to be placed back in ngZone. Callbacks must be placed
              // back into the zone because matchMedia is only included in Zone.js by loading the
              // webapis-media-query.js file alongside the zone.js file.  Additionally, some browsers do not
              // have MediaQueryList inherit from EventTarget, which causes inconsistencies in how Zone.js
              // patches it.
              var handler = function handler(e) {
                return _this3._zone.run(function () {
                  return observer.next(e);
                });
              };

              mql.addListener(handler);
              return function () {
                mql.removeListener(handler);
              };
            }).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_11__.startWith)(mql), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.map)(function (_ref2) {
              var matches = _ref2.matches;
              return {
                query: query,
                matches: matches
              };
            }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_12__.takeUntil)(this._destroySubject)); // Add the MediaQueryList to the set of queries.

            var output = {
              observable: queryObservable,
              mql: mql
            };

            this._queries.set(query, output);

            return output;
          }
        }]);

        return _BreakpointObserver;
      }();

      _BreakpointObserver.ɵfac = function BreakpointObserver_Factory(t) {
        return new (t || _BreakpointObserver)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_MediaMatcher), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
      };

      _BreakpointObserver.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"])({
        factory: function BreakpointObserver_Factory() {
          return new _BreakpointObserver((0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_MediaMatcher), (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone));
        },
        token: _BreakpointObserver,
        providedIn: "root"
      });

      _BreakpointObserver.ctorParameters = function () {
        return [{
          type: _MediaMatcher
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_BreakpointObserver, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: _MediaMatcher
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }];
        }, null);
      })();
      /**
       * Split each query string into separate query strings if two queries are provided as comma
       * separated.
       */


      function splitQueries(queries) {
        return queries.map(function (query) {
          return query.split(',');
        }).reduce(function (a1, a2) {
          return a1.concat(a2);
        }).map(function (query) {
          return query.trim();
        });
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // PascalCase is being used as Breakpoints is used like an enum.
      // tslint:disable-next-line:variable-name


      var _Breakpoints = {
        XSmall: '(max-width: 599.98px)',
        Small: '(min-width: 600px) and (max-width: 959.98px)',
        Medium: '(min-width: 960px) and (max-width: 1279.98px)',
        Large: '(min-width: 1280px) and (max-width: 1919.98px)',
        XLarge: '(min-width: 1920px)',
        Handset: '(max-width: 599.98px) and (orientation: portrait), ' + '(max-width: 959.98px) and (orientation: landscape)',
        Tablet: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait), ' + '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',
        Web: '(min-width: 840px) and (orientation: portrait), ' + '(min-width: 1280px) and (orientation: landscape)',
        HandsetPortrait: '(max-width: 599.98px) and (orientation: portrait)',
        TabletPortrait: '(min-width: 600px) and (max-width: 839.98px) and (orientation: portrait)',
        WebPortrait: '(min-width: 840px) and (orientation: portrait)',
        HandsetLandscape: '(max-width: 959.98px) and (orientation: landscape)',
        TabletLandscape: '(min-width: 960px) and (max-width: 1279.98px) and (orientation: landscape)',
        WebLandscape: '(min-width: 1280px) and (orientation: landscape)'
      };
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=layout.js.map

      /***/
    },

    /***/
    80521: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "Platform": function Platform() {
          return (
            /* binding */
            _Platform
          );
        },

        /* harmony export */
        "PlatformModule": function PlatformModule() {
          return (
            /* binding */
            _PlatformModule
          );
        },

        /* harmony export */
        "_getShadowRoot": function _getShadowRoot() {
          return (
            /* binding */
            _getShadowRoot2
          );
        },

        /* harmony export */
        "_supportsShadowDom": function _supportsShadowDom() {
          return (
            /* binding */
            _supportsShadowDom2
          );
        },

        /* harmony export */
        "getRtlScrollAxisType": function getRtlScrollAxisType() {
          return (
            /* binding */
            _getRtlScrollAxisType
          );
        },

        /* harmony export */
        "getSupportedInputTypes": function getSupportedInputTypes() {
          return (
            /* binding */
            _getSupportedInputTypes
          );
        },

        /* harmony export */
        "normalizePassiveListenerOptions": function normalizePassiveListenerOptions() {
          return (
            /* binding */
            _normalizePassiveListenerOptions
          );
        },

        /* harmony export */
        "supportsPassiveEventListeners": function supportsPassiveEventListeners() {
          return (
            /* binding */
            _supportsPassiveEventListeners
          );
        },

        /* harmony export */
        "supportsScrollBehavior": function supportsScrollBehavior() {
          return (
            /* binding */
            _supportsScrollBehavior
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // Whether the current platform supports the V8 Break Iterator. The V8 check
      // is necessary to detect all Blink based browsers.


      var hasV8BreakIterator; // We need a try/catch around the reference to `Intl`, because accessing it in some cases can
      // cause IE to throw. These cases are tied to particular versions of Windows and can happen if
      // the consumer is providing a polyfilled `Map`. See:
      // https://github.com/Microsoft/ChakraCore/issues/3189
      // https://github.com/angular/components/issues/15687

      try {
        hasV8BreakIterator = typeof Intl !== 'undefined' && Intl.v8BreakIterator;
      } catch (_a) {
        hasV8BreakIterator = false;
      }
      /**
       * Service to detect the current platform by comparing the userAgent strings and
       * checking browser-specific global properties.
       */


      var _Platform = function _Platform(_platformId) {
        _classCallCheck(this, _Platform);

        this._platformId = _platformId; // We want to use the Angular platform check because if the Document is shimmed
        // without the navigator, the following checks will fail. This is preferred because
        // sometimes the Document may be shimmed without the user's knowledge or intention

        /** Whether the Angular application is being rendered in the browser. */

        this.isBrowser = this._platformId ? (0, _angular_common__WEBPACK_IMPORTED_MODULE_0__.isPlatformBrowser)(this._platformId) : typeof document === 'object' && !!document;
        /** Whether the current browser is Microsoft Edge. */

        this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);
        /** Whether the current rendering engine is Microsoft Trident. */

        this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent); // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.

        /** Whether the current rendering engine is Blink. */

        this.BLINK = this.isBrowser && !!(window.chrome || hasV8BreakIterator) && typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT; // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to
        // ensure that Webkit runs standalone and is not used as another engine's base.

        /** Whether the current rendering engine is WebKit. */

        this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;
        /** Whether the current platform is Apple iOS. */

        this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window); // It's difficult to detect the plain Gecko engine, because most of the browsers identify
        // them self as Gecko-like browsers and modify the userAgent's according to that.
        // Since we only cover one explicit Firefox case, we can simply check for Firefox
        // instead of having an unstable check for Gecko.

        /** Whether the current browser is Firefox. */

        this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);
        /** Whether the current platform is Android. */
        // Trident on mobile adds the android platform to the userAgent to trick detections.

        this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT; // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake
        // this and just place the Safari keyword in the userAgent. To be more safe about Safari every
        // Safari browser should also use Webkit as its layout engine.

        /** Whether the current browser is Safari. */

        this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;
      };

      _Platform.ɵfac = function Platform_Factory(t) {
        return new (t || _Platform)(_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID));
      };

      _Platform.ɵprov = (0, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjectable"])({
        factory: function Platform_Factory() {
          return new _Platform((0, _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵinject"])(_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID));
        },
        token: _Platform,
        providedIn: "root"
      });

      _Platform.ctorParameters = function () {
        return [{
          type: Object,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](_Platform, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [{
            type: Object,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_1__.PLATFORM_ID]
            }]
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var _PlatformModule = function _PlatformModule() {
        _classCallCheck(this, _PlatformModule);
      };

      _PlatformModule.ɵfac = function PlatformModule_Factory(t) {
        return new (t || _PlatformModule)();
      };

      _PlatformModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineNgModule"]({
        type: _PlatformModule
      });
      _PlatformModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵɵdefineInjector"]({});

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_1__["ɵsetClassMetadata"](_PlatformModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.NgModule,
          args: [{}]
        }], null, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result Set of input types support by the current browser. */


      var supportedInputTypes;
      /** Types of `<input>` that *might* be supported. */

      var candidateInputTypes = [// `color` must come first. Chrome 56 shows a warning if we change the type to `color` after
      // first changing it to something else:
      // The specified value "" does not conform to the required format.
      // The format is "#rrggbb" where rr, gg, bb are two-digit hexadecimal numbers.
      'color', 'button', 'checkbox', 'date', 'datetime-local', 'email', 'file', 'hidden', 'image', 'month', 'number', 'password', 'radio', 'range', 'reset', 'search', 'submit', 'tel', 'text', 'time', 'url', 'week'];
      /** @returns The input types supported by this browser. */

      function _getSupportedInputTypes() {
        // Result is cached.
        if (supportedInputTypes) {
          return supportedInputTypes;
        } // We can't check if an input type is not supported until we're on the browser, so say that
        // everything is supported when not on the browser. We don't use `Platform` here since it's
        // just a helper function and can't inject it.


        if (typeof document !== 'object' || !document) {
          supportedInputTypes = new Set(candidateInputTypes);
          return supportedInputTypes;
        }

        var featureTestInput = document.createElement('input');
        supportedInputTypes = new Set(candidateInputTypes.filter(function (value) {
          featureTestInput.setAttribute('type', value);
          return featureTestInput.type === value;
        }));
        return supportedInputTypes;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result of whether the user's browser supports passive event listeners. */


      var supportsPassiveEvents;
      /**
       * Checks whether the user's browser supports passive event listeners.
       * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
       */

      function _supportsPassiveEventListeners() {
        if (supportsPassiveEvents == null && typeof window !== 'undefined') {
          try {
            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
              get: function get() {
                return supportsPassiveEvents = true;
              }
            }));
          } finally {
            supportsPassiveEvents = supportsPassiveEvents || false;
          }
        }

        return supportsPassiveEvents;
      }
      /**
       * Normalizes an `AddEventListener` object to something that can be passed
       * to `addEventListener` on any browser, no matter whether it supports the
       * `options` parameter.
       * @param options Object to be normalized.
       */


      function _normalizePassiveListenerOptions(options) {
        return _supportsPassiveEventListeners() ? options : !!options.capture;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */


      var rtlScrollAxisType;
      /** Cached result of the check that indicates whether the browser supports scroll behaviors. */

      var scrollBehaviorSupported;
      /** Check whether the browser supports scroll behaviors. */

      function _supportsScrollBehavior() {
        if (scrollBehaviorSupported == null) {
          // If we're not in the browser, it can't be supported. Also check for `Element`, because
          // some projects stub out the global `document` during SSR which can throw us off.
          if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {
            scrollBehaviorSupported = false;
            return scrollBehaviorSupported;
          } // If the element can have a `scrollBehavior` style, we can be sure that it's supported.


          if ('scrollBehavior' in document.documentElement.style) {
            scrollBehaviorSupported = true;
          } else {
            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's
            // supported but it doesn't handle scroll behavior, or it has been polyfilled.
            var scrollToFunction = Element.prototype.scrollTo;

            if (scrollToFunction) {
              // We can detect if the function has been polyfilled by calling `toString` on it. Native
              // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get
              // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider
              // polyfilled functions as supporting scroll behavior.
              scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString());
            } else {
              scrollBehaviorSupported = false;
            }
          }
        }

        return scrollBehaviorSupported;
      }
      /**
       * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,
       * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.
       */


      function _getRtlScrollAxisType() {
        // We can't check unless we're on the browser. Just assume 'normal' if we're not.
        if (typeof document !== 'object' || !document) {
          return 0
          /* NORMAL */
          ;
        }

        if (rtlScrollAxisType == null) {
          // Create a 1px wide scrolling container and a 2px wide content element.
          var scrollContainer = document.createElement('div');
          var containerStyle = scrollContainer.style;
          scrollContainer.dir = 'rtl';
          containerStyle.width = '1px';
          containerStyle.overflow = 'auto';
          containerStyle.visibility = 'hidden';
          containerStyle.pointerEvents = 'none';
          containerStyle.position = 'absolute';
          var content = document.createElement('div');
          var contentStyle = content.style;
          contentStyle.width = '2px';
          contentStyle.height = '1px';
          scrollContainer.appendChild(content);
          document.body.appendChild(scrollContainer);
          rtlScrollAxisType = 0
          /* NORMAL */
          ; // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL
          // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're
          // dealing with one of the other two types of browsers.

          if (scrollContainer.scrollLeft === 0) {
            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an
            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by
            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will
            // return 0 when we read it again.
            scrollContainer.scrollLeft = 1;
            rtlScrollAxisType = scrollContainer.scrollLeft === 0 ? 1
            /* NEGATED */
            : 2
            /* INVERTED */
            ;
          }

          scrollContainer.parentNode.removeChild(scrollContainer);
        }

        return rtlScrollAxisType;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var shadowDomIsSupported;
      /** Checks whether the user's browser support Shadow DOM. */

      function _supportsShadowDom2() {
        if (shadowDomIsSupported == null) {
          var head = typeof document !== 'undefined' ? document.head : null;
          shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));
        }

        return shadowDomIsSupported;
      }
      /** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */


      function _getShadowRoot2(element) {
        if (_supportsShadowDom2()) {
          var rootNode = element.getRootNode ? element.getRootNode() : null; // Note that this should be caught by `_supportsShadowDom`, but some
          // teams have been able to hit this code path on unsupported browsers.

          if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {
            return rootNode;
          }
        }

        return null;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=platform.js.map

      /***/

    },

    /***/
    39490: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "_isNumberValue": function _isNumberValue() {
          return (
            /* binding */
            _isNumberValue2
          );
        },

        /* harmony export */
        "coerceArray": function coerceArray() {
          return (
            /* binding */
            _coerceArray
          );
        },

        /* harmony export */
        "coerceBooleanProperty": function coerceBooleanProperty() {
          return (
            /* binding */
            _coerceBooleanProperty
          );
        },

        /* harmony export */
        "coerceCssPixelValue": function coerceCssPixelValue() {
          return (
            /* binding */
            _coerceCssPixelValue
          );
        },

        /* harmony export */
        "coerceElement": function coerceElement() {
          return (
            /* binding */
            _coerceElement
          );
        },

        /* harmony export */
        "coerceNumberProperty": function coerceNumberProperty() {
          return (
            /* binding */
            _coerceNumberProperty
          );
        },

        /* harmony export */
        "coerceStringArray": function coerceStringArray() {
          return (
            /* binding */
            _coerceStringArray
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Coerces a data-bound value (typically a string) to a boolean. */


      function _coerceBooleanProperty(value) {
        return value != null && "".concat(value) !== 'false';
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      function _coerceNumberProperty(value) {
        var fallbackValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return _isNumberValue2(value) ? Number(value) : fallbackValue;
      }
      /**
       * Whether the provided value is considered a number.
       * @docs-private
       */


      function _isNumberValue2(value) {
        // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,
        // and other non-number values as NaN, where Number just uses 0) but it considers the string
        // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.
        return !isNaN(parseFloat(value)) && !isNaN(Number(value));
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      function _coerceArray(value) {
        return Array.isArray(value) ? value : [value];
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /** Coerces a value to a CSS pixel value. */


      function _coerceCssPixelValue(value) {
        if (value == null) {
          return '';
        }

        return typeof value === 'string' ? value : "".concat(value, "px");
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Coerces an ElementRef or an Element into an element.
       * Useful for APIs that can accept either a ref or the native element itself.
       */


      function _coerceElement(elementOrRef) {
        return elementOrRef instanceof _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef ? elementOrRef.nativeElement : elementOrRef;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Coerces a value to an array of trimmed non-empty strings.
       * Any input that is not an array, `null` or `undefined` will be turned into a string
       * via `toString()` and subsequently split with the given separator.
       * `null` and `undefined` will result in an empty array.
       * This results in the following outcomes:
       * - `null` -&gt; `[]`
       * - `[null]` -&gt; `["null"]`
       * - `["a", "b ", " "]` -&gt; `["a", "b"]`
       * - `[1, [2, 3]]` -&gt; `["1", "2,3"]`
       * - `[{ a: 0 }]` -&gt; `["[object Object]"]`
       * - `{ a: 0 }` -&gt; `["[object", "Object]"]`
       *
       * Useful for defining CSS classes or table columns.
       * @param value the value to coerce into an array of strings
       * @param separator split-separator if value isn't an array
       */


      function _coerceStringArray(value) {
        var separator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /\s+/;
        var result = [];

        if (value != null) {
          var sourceValues = Array.isArray(value) ? value : "".concat(value).split(separator);

          var _iterator = _createForOfIteratorHelper(sourceValues),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var sourceValue = _step.value;
              var trimmedString = "".concat(sourceValue).trim();

              if (trimmedString) {
                result.push(trimmedString);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return result;
      }
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      //# sourceMappingURL=coercion.js.map

      /***/

    },

    /***/
    59715: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "GalleryModule": function GalleryModule() {
          return (
            /* binding */
            _GalleryModule
          );
        },

        /* harmony export */
        "Action": function Action() {
          return (
            /* binding */
            _Action
          );
        },

        /* harmony export */
        "Image": function Image() {
          return (
            /* binding */
            _Image
          );
        },

        /* harmony export */
        "ImageEvent": function ImageEvent() {
          return (
            /* binding */
            _ImageEvent
          );
        },

        /* harmony export */
        "ImageModalEvent": function ImageModalEvent() {
          return (
            /* binding */
            _ImageModalEvent
          );
        },

        /* harmony export */
        "DescriptionStrategy": function DescriptionStrategy() {
          return (
            /* binding */
            _DescriptionStrategy
          );
        },

        /* harmony export */
        "ButtonsStrategy": function ButtonsStrategy() {
          return (
            /* binding */
            _ButtonsStrategy
          );
        },

        /* harmony export */
        "ButtonType": function ButtonType() {
          return (
            /* binding */
            _ButtonType
          );
        },

        /* harmony export */
        "GalleryService": function GalleryService() {
          return (
            /* binding */
            _GalleryService
          );
        },

        /* harmony export */
        "LoadingType": function LoadingType() {
          return (
            /* binding */
            _LoadingType
          );
        },

        /* harmony export */
        "KS_DEFAULT_ACCESSIBILITY_CONFIG": function KS_DEFAULT_ACCESSIBILITY_CONFIG() {
          return (
            /* binding */
            _KS_DEFAULT_ACCESSIBILITY_CONFIG
          );
        },

        /* harmony export */
        "KS_DEFAULT_BTN_FULL_SCREEN": function KS_DEFAULT_BTN_FULL_SCREEN() {
          return (
            /* binding */
            _KS_DEFAULT_BTN_FULL_SCREEN
          );
        },

        /* harmony export */
        "KS_DEFAULT_BTN_CLOSE": function KS_DEFAULT_BTN_CLOSE() {
          return (
            /* binding */
            _KS_DEFAULT_BTN_CLOSE
          );
        },

        /* harmony export */
        "KS_DEFAULT_BTN_DELETE": function KS_DEFAULT_BTN_DELETE() {
          return (
            /* binding */
            _KS_DEFAULT_BTN_DELETE
          );
        },

        /* harmony export */
        "KS_DEFAULT_BTN_DOWNLOAD": function KS_DEFAULT_BTN_DOWNLOAD() {
          return (
            /* binding */
            _KS_DEFAULT_BTN_DOWNLOAD
          );
        },

        /* harmony export */
        "KS_DEFAULT_BTN_EXTURL": function KS_DEFAULT_BTN_EXTURL() {
          return (
            /* binding */
            _KS_DEFAULT_BTN_EXTURL
          );
        },

        /* harmony export */
        "KS_DEFAULT_SIZE": function KS_DEFAULT_SIZE() {
          return (
            /* binding */
            _KS_DEFAULT_SIZE
          );
        },

        /* harmony export */
        "LineLayout": function LineLayout() {
          return (
            /* binding */
            _LineLayout
          );
        },

        /* harmony export */
        "GridLayout": function GridLayout() {
          return (
            /* binding */
            _GridLayout
          );
        },

        /* harmony export */
        "AdvancedLayout": function AdvancedLayout() {
          return (
            /* binding */
            _AdvancedLayout
          );
        },

        /* harmony export */
        "PlainGalleryStrategy": function PlainGalleryStrategy() {
          return (
            /* binding */
            _PlainGalleryStrategy
          );
        },

        /* harmony export */
        "ɵi": function ɵi() {
          return (
            /* binding */
            AccessibleComponent
          );
        },

        /* harmony export */
        "ɵf": function ɵf() {
          return (
            /* binding */
            BackgroundComponent
          );
        },

        /* harmony export */
        "ɵn": function ɵn() {
          return (
            /* binding */
            CarouselPreviewsComponent
          );
        },

        /* harmony export */
        "ɵe": function ɵe() {
          return (
            /* binding */
            CarouselComponent
          );
        },

        /* harmony export */
        "ɵc": function ɵc() {
          return (
            /* binding */
            COMPONENTS
          );
        },

        /* harmony export */
        "ɵh": function ɵh() {
          return (
            /* binding */
            CurrentImageComponent
          );
        },

        /* harmony export */
        "ɵr": function ɵr() {
          return (
            /* binding */
            LoadingSpinnerComponent
          );
        },

        /* harmony export */
        "ɵp": function ɵp() {
          return (
            /* binding */
            DotsComponent
          );
        },

        /* harmony export */
        "ɵd": function ɵd() {
          return (
            /* binding */
            ModalGalleryComponent
          );
        },

        /* harmony export */
        "ɵg": function ɵg() {
          return (
            /* binding */
            PlainGalleryComponent
          );
        },

        /* harmony export */
        "ɵq": function ɵq() {
          return (
            /* binding */
            PreviewsComponent
          );
        },

        /* harmony export */
        "ɵo": function ɵo() {
          return (
            /* binding */
            UpperButtonsComponent
          );
        },

        /* harmony export */
        "ɵy": function ɵy() {
          return (
            /* binding */
            ATagBgImageDirective
          );
        },

        /* harmony export */
        "ɵt": function ɵt() {
          return (
            /* binding */
            ClickOutsideDirective
          );
        },

        /* harmony export */
        "ɵz": function ɵz() {
          return (
            /* binding */
            DescriptionDirective
          );
        },

        /* harmony export */
        "ɵx": function ɵx() {
          return (
            /* binding */
            DirectionDirective
          );
        },

        /* harmony export */
        "ɵs": function ɵs() {
          return (
            /* binding */
            DIRECTIVES
          );
        },

        /* harmony export */
        "ɵv": function ɵv() {
          return (
            /* binding */
            KeyboardNavigationDirective
          );
        },

        /* harmony export */
        "ɵba": function ɵba() {
          return (
            /* binding */
            MarginDirective
          );
        },

        /* harmony export */
        "ɵbb": function ɵbb() {
          return (
            /* binding */
            MaxSizeDirective
          );
        },

        /* harmony export */
        "ɵu": function ɵu() {
          return (
            /* binding */
            SizeDirective
          );
        },

        /* harmony export */
        "ɵw": function ɵw() {
          return (
            /* binding */
            WrapDirective
          );
        },

        /* harmony export */
        "ɵa": function ɵa() {
          return (
            /* binding */
            KsHammerGestureConfig
          );
        },

        /* harmony export */
        "ɵb": function ɵb() {
          return (
            /* binding */
            setupKeyboardService
          );
        },

        /* harmony export */
        "ɵm": function ɵm() {
          return (
            /* binding */
            IdValidatorService
          );
        },

        /* harmony export */
        "ɵj": function ɵj() {
          return (
            /* binding */
            KEYBOARD_CONFIGURATION
          );
        },

        /* harmony export */
        "ɵk": function ɵk() {
          return (
            /* binding */
            KeyboardService
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs */
      79765);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! rxjs */
      46797);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      88002);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! rxjs/operators */
      45435);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! rxjs/operators */
      43190);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! rxjs/operators */
      46782);
      /* harmony import */


      var _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(
      /*! @angular/cdk/layout */
      65072);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(
      /*! @angular/platform-browser */
      39075);
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to close the modal gallery clicking on the semi-transparent background.
       * In fact, it listens for a click on all elements that aren't 'inside' and it emits
       * an event using `\@Output clickOutside`.
       */


      function BackgroundComponent_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 1);
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.backgroundTitle);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.backgroundAriaLabel);
        }
      }

      var _c0 = function _c0(a0, a1) {
        return {
          width: a0,
          height: a1
        };
      };

      function CurrentImageComponent_ng_container_4_ng_container_1_img_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CurrentImageComponent_ng_container_4_ng_container_1_img_1_Template_img_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r9.onNavigationEvent("left", $event, ctx_r9.clickAction);
          })("keyup", function CurrentImageComponent_ng_container_4_ng_container_1_img_1_Template_img_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r11.onNavigationEvent("left", $event, ctx_r11.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var leftPreview_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().ngIf;

          var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", leftPreview_r5.modal.alt ? leftPreview_r5.modal.alt : ctx_r6.getAltDescriptionByImage(leftPreview_r5));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", (leftPreview_r5.plain == null ? null : leftPreview_r5.plain.img) ? leftPreview_r5.plain.img : leftPreview_r5.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("hidden", ctx_r6.loading)("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](7, _c0, ctx_r6.configSlide.sidePreviews == null ? null : ctx_r6.configSlide.sidePreviews.size.width, ctx_r6.configSlide.sidePreviews == null ? null : ctx_r6.configSlide.sidePreviews.size.height))("title", leftPreview_r5.modal.title ? leftPreview_r5.modal.title : ctx_r6.getDescriptionToDisplay(leftPreview_r5))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", leftPreview_r5.modal.ariaLabel);
        }
      }

      function CurrentImageComponent_ng_container_4_ng_container_1_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 12);
        }

        if (rf & 2) {
          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](1, _c0, ctx_r8.configSlide.sidePreviews == null ? null : ctx_r8.configSlide.sidePreviews.size.width, ctx_r8.configSlide.sidePreviews == null ? null : ctx_r8.configSlide.sidePreviews.size.height));
        }
      }

      function CurrentImageComponent_ng_container_4_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CurrentImageComponent_ng_container_4_ng_container_1_img_1_Template, 1, 10, "img", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CurrentImageComponent_ng_container_4_ng_container_1_ng_template_2_Template, 1, 4, "ng-template", null, 10, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r4.isFirstImage)("ngIfElse", _r7);
        }
      }

      function CurrentImageComponent_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CurrentImageComponent_ng_container_4_ng_container_1_Template, 4, 2, "ng-container", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r0.getLeftPreviewImage());
        }
      }

      function CurrentImageComponent_figcaption_7_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "figcaption", 13);
        }

        if (rf & 2) {
          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("description", ctx_r1.configCurrentImage == null ? null : ctx_r1.configCurrentImage.description)("innerHTML", ctx_r1.getDescriptionToDisplay(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
        }
      }

      function CurrentImageComponent_ng_container_9_ng_container_1_img_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CurrentImageComponent_ng_container_9_ng_container_1_img_1_Template_img_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

            var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r18.onNavigationEvent("right", $event, ctx_r18.clickAction);
          })("keyup", function CurrentImageComponent_ng_container_9_ng_container_1_img_1_Template_img_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r19);

            var ctx_r20 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r20.onNavigationEvent("right", $event, ctx_r20.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var rightPreview_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().ngIf;

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", rightPreview_r14.modal.alt ? rightPreview_r14.modal.alt : ctx_r15.getAltDescriptionByImage(rightPreview_r14));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", (rightPreview_r14.plain == null ? null : rightPreview_r14.plain.img) ? rightPreview_r14.plain.img : rightPreview_r14.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("hidden", ctx_r15.loading)("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](7, _c0, ctx_r15.slideConfig.sidePreviews == null ? null : ctx_r15.slideConfig.sidePreviews.size.width, ctx_r15.slideConfig.sidePreviews == null ? null : ctx_r15.slideConfig.sidePreviews.size.height))("title", rightPreview_r14.modal.title ? rightPreview_r14.modal.title : ctx_r15.getDescriptionToDisplay(rightPreview_r14))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", rightPreview_r14.modal.ariaLabel);
        }
      }

      function CurrentImageComponent_ng_container_9_ng_container_1_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 17);
        }

        if (rf & 2) {
          var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](1, _c0, ctx_r17.slideConfig.sidePreviews == null ? null : ctx_r17.slideConfig.sidePreviews.size.width, ctx_r17.slideConfig.sidePreviews == null ? null : ctx_r17.slideConfig.sidePreviews.size.height));
        }
      }

      function CurrentImageComponent_ng_container_9_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CurrentImageComponent_ng_container_9_ng_container_1_img_1_Template, 1, 10, "img", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CurrentImageComponent_ng_container_9_ng_container_1_ng_template_2_Template, 1, 4, "ng-template", null, 15, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var _r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx_r13.isLastImage)("ngIfElse", _r16);
        }
      }

      function CurrentImageComponent_ng_container_9_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CurrentImageComponent_ng_container_9_ng_container_1_Template, 4, 2, "ng-container", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.getRightPreviewImage());
        }
      }

      function CurrentImageComponent_ng_container_10_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "ks-loading-spinner", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("loadingConfig", ctx_r3.configCurrentImage == null ? null : ctx_r3.configCurrentImage.loadingConfig)("accessibilityConfig", ctx_r3.accessibilityConfig);
        }
      }

      function ModalGalleryComponent_div_2_Template(rf, ctx) {
        if (rf & 1) {
          var _r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickOutside", function ModalGalleryComponent_div_2_Template_div_clickOutside_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r1.onClickOutside($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "ks-upper-buttons", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("delete", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_delete_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r3.onDelete($event);
          })("navigate", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_navigate_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r4.onNavigate($event);
          })("download", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_download_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r5.onDownload($event);
          })("close", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_close_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r6.onCloseGallery($event);
          })("fullscreen", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_fullscreen_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r7.onFullScreen($event);
          })("customEmit", function ModalGalleryComponent_div_2_Template_ks_upper_buttons_customEmit_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r8.onCustomEmit($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "ks-current-image", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("loadImage", function ModalGalleryComponent_div_2_Template_ks_current_image_loadImage_4_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r9.onImageLoad($event);
          })("changeImage", function ModalGalleryComponent_div_2_Template_ks_current_image_changeImage_4_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r10.onChangeCurrentImage($event);
          })("close", function ModalGalleryComponent_div_2_Template_ks_current_image_close_4_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r11.onCloseGallery($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "div");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "ks-dots", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickDot", function ModalGalleryComponent_div_2_Template_ks_dots_clickDot_6_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r12.onClickDot($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](7, "ks-previews", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickPreview", function ModalGalleryComponent_div_2_Template_ks_previews_clickPreview_7_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r2);

            var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r13.onClickPreview($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig.modalGalleryContentTitle)("clickOutsideEnable", ctx_r0.enableCloseOutside);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig.modalGalleryContentAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("currentImage", ctx_r0.currentImage)("buttonsConfig", ctx_r0.buttonsConfig);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx_r0.id)("images", ctx_r0.images)("currentImage", ctx_r0.currentImage)("isOpen", ctx_r0.opened)("slideConfig", ctx_r0.configSlide)("keyboardConfig", ctx_r0.keyboardConfig)("accessibilityConfig", ctx_r0.accessibilityConfig)("currentImageConfig", ctx_r0.currentImageConfig);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("images", ctx_r0.images)("currentImage", ctx_r0.currentImage)("dotsConfig", ctx_r0.dotsConfig)("accessibilityConfig", ctx_r0.accessibilityConfig);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("images", ctx_r0.images)("currentImage", ctx_r0.currentImage)("previewConfig", ctx_r0.previewConfig)("accessibilityConfig", ctx_r0.accessibilityConfig);
        }
      }

      function CarouselComponent_ng_template_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojection"](0);
        }
      }

      function CarouselComponent_figure_3_a_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_figure_3_a_1_Template_a_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r9.onNavigationEvent("left", $event, ctx_r9.clickAction);
          })("keyup", function CarouselComponent_figure_3_a_1_Template_a_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r11.onNavigationEvent("left", $event, ctx_r11.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r5.isLastImage && !ctx_r5.infinite ? -1 : 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r5.accessibilityConfig.carouselPrevImageAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r5.isFirstImage && !ctx_r5.infinite || !ctx_r5.configCarousel.showArrows ? "empty-arrow-image" : "left-arrow-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r5.accessibilityConfig.carouselPrevImageTitle);
        }
      }

      function CarouselComponent_figure_3_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0);
        }
      }

      function CarouselComponent_figure_3_figcaption_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "figcaption", 16);
        }

        if (rf & 2) {
          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("description", ctx_r7.configCurrentImageCarousel == null ? null : ctx_r7.configCurrentImageCarousel.description)("innerHTML", ctx_r7.getDescriptionToDisplay(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
        }
      }

      function CarouselComponent_figure_3_a_5_Template(rf, ctx) {
        if (rf & 1) {
          var _r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_figure_3_a_5_Template_a_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r13);

            var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r12.onNavigationEvent("right", $event, ctx_r12.clickAction);
          })("keyup", function CarouselComponent_figure_3_a_5_Template_a_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r13);

            var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r14.onNavigationEvent("right", $event, ctx_r14.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r8.isLastImage && !ctx_r8.infinite ? -1 : 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r8.accessibilityConfig.carouselNextImageAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r8.isLastImage && !ctx_r8.infinite || !ctx_r8.configCarousel.showArrows ? "empty-arrow-image" : "right-arrow-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r8.accessibilityConfig.carouselNextImageTitle);
        }
      }

      var _c1 = function _c1(a0) {
        return {
          width: a0,
          height: ""
        };
      };

      var _c2 = function _c2(a0, a1) {
        return {
          maxWidth: a0,
          maxHeight: a1
        };
      };

      function CarouselComponent_figure_3_Template(rf, ctx) {
        if (rf & 1) {
          var _r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "figure", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CarouselComponent_figure_3_a_1_Template, 2, 6, "a", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CarouselComponent_figure_3_ng_container_2_Template, 1, 0, "ng-container", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "img", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_figure_3_Template_img_click_3_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

            var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r15.onClickCurrentImage();
          })("swipeleft", function CarouselComponent_figure_3_Template_img_swipeleft_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

            var ctx_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r17.swipe($event.type);
          })("swiperight", function CarouselComponent_figure_3_Template_img_swiperight_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

            var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r18.swipe($event.type);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, CarouselComponent_figure_3_figcaption_4_Template, 1, 2, "figcaption", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, CarouselComponent_figure_3_a_5_Template, 2, 6, "a", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "div", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](7, "ks-dots", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickDot", function CarouselComponent_figure_3_Template_ks_dots_clickDot_7_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r16);

            var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r19.onClickDot($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](17, _c1, ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.maxWidth));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.showArrows);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", _r0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("object-fit", ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.objectFit);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", ctx_r2.currentImage.modal.alt ? ctx_r2.currentImage.modal.alt : ctx_r2.getAltDescriptionByImage());

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](19, _c2, ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.maxWidth, ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.maxHeight))("src", ctx_r2.currentImage.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("title", ctx_r2.currentImage.modal.title ? ctx_r2.currentImage.modal.title : ctx_r2.getTitleToDisplay())("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r2.currentImage.modal.ariaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.getDescriptionToDisplay() !== "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r2.configCarousel == null ? null : ctx_r2.configCarousel.showArrows);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("currentImage", ctx_r2.currentImage)("dotsConfig", ctx_r2.configDots)("accessibilityConfig", ctx_r2.accessibilityConfig)("images", ctx_r2.images);
        }
      }

      function CarouselComponent_ng_template_4_a_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r25 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_ng_template_4_a_1_Template_a_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r25);

            var ctx_r24 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r24.onNavigationEvent("left", $event, ctx_r24.clickAction);
          })("keyup", function CarouselComponent_ng_template_4_a_1_Template_a_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r25);

            var ctx_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r26.onNavigationEvent("left", $event, ctx_r26.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r20 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r20.isLastImage && !ctx_r20.infinite ? -1 : 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r20.accessibilityConfig.carouselPrevImageAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r20.isFirstImage && !ctx_r20.infinite || !ctx_r20.configCarousel.showArrows ? "empty-arrow-image" : "left-arrow-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r20.accessibilityConfig.carouselPrevImageTitle);
        }
      }

      function CarouselComponent_ng_template_4_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainer"](0);
        }
      }

      function CarouselComponent_ng_template_4_div_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](0, "div", 21);
        }

        if (rf & 2) {
          var ctx_r22 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("description", ctx_r22.configCurrentImageCarousel == null ? null : ctx_r22.configCurrentImageCarousel.description)("innerHTML", ctx_r22.getDescriptionToDisplay(), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeHtml"]);
        }
      }

      function CarouselComponent_ng_template_4_a_5_Template(rf, ctx) {
        if (rf & 1) {
          var _r28 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_ng_template_4_a_5_Template_a_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r28);

            var ctx_r27 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r27.onNavigationEvent("right", $event, ctx_r27.clickAction);
          })("keyup", function CarouselComponent_ng_template_4_a_5_Template_a_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r28);

            var ctx_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r29.onNavigationEvent("right", $event, ctx_r29.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r23 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r23.isLastImage && !ctx_r23.infinite ? -1 : 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r23.accessibilityConfig.carouselNextImageAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r23.isLastImage && !ctx_r23.infinite || !ctx_r23.configCarousel.showArrows ? "empty-arrow-image" : "right-arrow-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r23.accessibilityConfig.carouselNextImageTitle);
        }
      }

      var _c3 = function _c3(a1) {
        return {
          width: "100%",
          height: a1
        };
      };

      var _c4 = function _c4(a0) {
        return {
          maxWidth: a0
        };
      };

      function CarouselComponent_ng_template_4_Template(rf, ctx) {
        if (rf & 1) {
          var _r31 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CarouselComponent_ng_template_4_a_1_Template, 2, 6, "a", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CarouselComponent_ng_template_4_ng_container_2_Template, 1, 0, "ng-container", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "div", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselComponent_ng_template_4_Template_div_click_3_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r31);

            var ctx_r30 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r30.onClickCurrentImage();
          })("swipeleft", function CarouselComponent_ng_template_4_Template_div_swipeleft_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r31);

            var ctx_r32 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r32.swipe($event.type);
          })("swiperight", function CarouselComponent_ng_template_4_Template_div_swiperight_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r31);

            var ctx_r33 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r33.swipe($event.type);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, CarouselComponent_ng_template_4_div_4_Template, 1, 2, "div", 19);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, CarouselComponent_ng_template_4_a_5_Template, 2, 6, "a", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "div", 20);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](7, "ks-dots", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickDot", function CarouselComponent_ng_template_4_Template_ks_dots_clickDot_7_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r31);

            var ctx_r34 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r34.onClickDot($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          var _r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](26, _c1, ctx_r4.configCarousel == null ? null : ctx_r4.configCarousel.maxWidth));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r4.configCarousel == null ? null : ctx_r4.configCarousel.showArrows);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngTemplateOutlet", _r0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("background-color", "transparent")("background-image", ctx_r4.sanitizeUrlBgStyle(ctx_r4.currentImage.modal.img + ""))("background-position", "center center")("background-size", "cover")("background-repeat", "no-repeat")("background-attachment", "scroll");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](28, _c3, ctx_r4.configCarousel == null ? null : ctx_r4.configCarousel.maxHeight))("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](30, _c4, ctx_r4.configCarousel == null ? null : ctx_r4.configCarousel.maxWidth))("title", ctx_r4.currentImage.modal.title ? ctx_r4.currentImage.modal.title : ctx_r4.getTitleToDisplay())("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r4.currentImage.modal.ariaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r4.getDescriptionToDisplay() !== "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx_r4.configCarousel == null ? null : ctx_r4.configCarousel.showArrows);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("currentImage", ctx_r4.currentImage)("dotsConfig", ctx_r4.configDots)("accessibilityConfig", ctx_r4.accessibilityConfig)("images", ctx_r4.images);
        }
      }

      var _c5 = function _c5(a0) {
        return {
          maxWidth: a0,
          maxHeight: ""
        };
      };

      var _c6 = ["*"];
      var _c7 = ".arrow-image[_ngcontent-%COMP%], .empty-arrow-image[_ngcontent-%COMP%], .left-arrow-image[_ngcontent-%COMP%], .right-arrow-image[_ngcontent-%COMP%]{width:30px;height:30px;background-size:30px}.empty-arrow-image[_ngcontent-%COMP%]{background:#000;opacity:0}.left-arrow-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.left-arrow-image[_ngcontent-%COMP%]:hover{transform:scale(1.2)}.right-arrow-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.right-arrow-image[_ngcontent-%COMP%]:hover{transform:scale(1.2)}";

      function CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_img_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_img_1_Template_img_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r8.onImageEvent(preview_r2, $event, ctx_r8.clickAction);
          })("keyup", function CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_img_1_Template_img_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r10);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r11.onImageEvent(preview_r2, $event, ctx_r11.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate2"]("inside preview-image", ctx_r7.isActive(preview_r2) ? " active" : "", "", !ctx_r7.configPreview.clickable ? " unclickable" : "", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", ctx_r7.getAlt(preview_r2));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", (preview_r2.plain == null ? null : preview_r2.plain.img) ? preview_r2.plain.img : preview_r2.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](10, _c0, ctx_r7.configPreview == null ? null : ctx_r7.configPreview.width, ctx_r7.configPreview == null ? null : ctx_r7.configPreview.maxHeight))("title", ctx_r7.getTitle(preview_r2))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r7.getAriaLabel(preview_r2));
        }
      }

      function CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_img_1_Template, 1, 13, "img", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", preview_r2 == null ? null : preview_r2.modal == null ? null : preview_r2.modal.img);
        }
      }

      function CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_div_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_div_0_Template_div_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r18);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r16 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r16.onImageEvent(preview_r2, $event, ctx_r16.clickAction);
          })("keyup", function CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_div_0_Template_div_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r18);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r19.onImageEvent(preview_r2, $event, ctx_r19.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate2"]("inside preview-ie11-image", ctx_r15.isActive(preview_r2) ? " active" : "", "", !ctx_r15.configPreview.clickable ? " unclickable" : "", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("background-color", "transparent")("background-image", ctx_r15.sanitizeUrlBgStyle((preview_r2.plain == null ? null : preview_r2.plain.img) ? preview_r2.plain.img : preview_r2.modal.img))("background-position", "center center")("background-size", ctx_r15.getIE11LegacyBgSize())("background-repeat", "no-repeat")("background-attachment", "scroll");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](20, _c0, ctx_r15.configPreview == null ? null : ctx_r15.configPreview.width, ctx_r15.configPreview == null ? null : ctx_r15.configPreview.maxHeight))("title", ctx_r15.getTitle(preview_r2))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r15.getAriaLabel(preview_r2));
        }
      }

      function CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_div_0_Template, 1, 23, "div", 11);
        }

        if (rf & 2) {
          var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", preview_r2 == null ? null : preview_r2.modal == null ? null : preview_r2.modal.img);
        }
      }

      function CarouselPreviewsComponent_nav_0_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CarouselPreviewsComponent_nav_0_ng_container_4_ng_container_1_Template, 2, 1, "ng-container", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, CarouselPreviewsComponent_nav_0_ng_container_4_ng_template_2_Template, 1, 1, "ng-template", null, 8, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !(ctx_r1.carouselConfig == null ? null : ctx_r1.carouselConfig.legacyIE11Mode))("ngIfElse", _r5);
        }
      }

      function CarouselPreviewsComponent_nav_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r24 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nav", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselPreviewsComponent_nav_0_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r24);

            var ctx_r23 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r23.onNavigationEvent("left", $event);
          })("keyup", function CarouselPreviewsComponent_nav_0_Template_a_keyup_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r24);

            var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r25.onNavigationEvent("left", $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](3, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, CarouselPreviewsComponent_nav_0_ng_container_4_Template, 4, 2, "ng-container", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "a", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CarouselPreviewsComponent_nav_0_Template_a_click_5_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r24);

            var ctx_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r26.onNavigationEvent("right", $event);
          })("keyup", function CarouselPreviewsComponent_nav_0_Template_a_keyup_5_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r24);

            var ctx_r27 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r27.onNavigationEvent("right", $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](6, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewsContainerTitle);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewsContainerAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r0.configPreview.arrows && ctx_r0.start > 0 ? 0 : -1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewScrollPrevAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r0.configPreview.arrows && ctx_r0.start > 0 ? "left-arrow-preview-image" : "empty-arrow-preview-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewScrollPrevTitle);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.previews)("ngForTrackBy", ctx_r0.trackById);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r0.configPreview.arrows && ctx_r0.end < ctx_r0.images.length ? 0 : -1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewScrollNextAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r0.configPreview.arrows && ctx_r0.end < ctx_r0.images.length ? "right-arrow-preview-image" : "empty-arrow-preview-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.carouselPreviewScrollNextTitle);
        }
      }

      var _c8 = function _c8(a0) {
        return {
          "font-size": a0
        };
      };

      function UpperButtonsComponent_ng_container_1_a_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function UpperButtonsComponent_ng_container_1_a_1_Template_a_click_0_listener($event) {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

            var btn_r2 = restoredCtx.$implicit;

            var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r4.onEvent(btn_r2, $event);
          })("keyup", function UpperButtonsComponent_ng_container_1_a_1_Template_a_keyup_0_listener($event) {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

            var btn_r2 = restoredCtx.$implicit;

            var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r6.onEvent(btn_r2, $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var btn_r2 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](8, _c0, btn_r2.size == null ? null : btn_r2.size.width, btn_r2.size == null ? null : btn_r2.size.height))("ngStyle", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](11, _c8, btn_r2.fontSize))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", btn_r2.ariaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", btn_r2.className, "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("title", btn_r2.title);
        }
      }

      function UpperButtonsComponent_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, UpperButtonsComponent_ng_container_1_a_1_Template, 2, 13, "a", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.buttons)("ngForTrackBy", ctx_r0.trackById);
        }
      }

      var _c9 = function _c9(a0) {
        return {
          "active": a0
        };
      };

      function DotsComponent_ng_container_1_div_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function DotsComponent_ng_container_1_div_1_Template_div_click_0_listener($event) {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

            var index_r3 = restoredCtx.index;

            var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r4.onDotEvent(index_r3, $event);
          })("keyup", function DotsComponent_ng_container_1_div_1_Template_div_keyup_0_listener($event) {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r5);

            var index_r3 = restoredCtx.index;

            var ctx_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r6.onDotEvent(index_r3, $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var index_r3 = ctx.index;

          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](3, _c9, ctx_r1.isActive(index_r3)))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", (ctx_r1.accessibilityConfig == null ? null : ctx_r1.accessibilityConfig.dotAriaLabel) + " " + (index_r3 + 1));
        }
      }

      function DotsComponent_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, DotsComponent_ng_container_1_div_1_Template, 1, 5, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.images)("ngForTrackBy", ctx_r0.trackById);
        }
      }

      function PreviewsComponent_ng_container_1_ng_container_3_img_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r7 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PreviewsComponent_ng_container_1_ng_container_3_img_1_Template_img_click_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

            var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r5.onImageEvent(preview_r2, $event, ctx_r5.clickAction);
          })("keyup", function PreviewsComponent_ng_container_1_ng_container_3_img_1_Template_img_keyup_0_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r7);

            var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

            var ctx_r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

            return ctx_r8.onImageEvent(preview_r2, $event, ctx_r8.keyboardAction);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var preview_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate2"]("inside preview-image ", ctx_r4.isActive(preview_r2) ? "active" : "", "", !ctx_r4.configPreview.clickable ? " unclickable" : "", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", preview_r2.modal.alt ? preview_r2.modal.alt : "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", (preview_r2.plain == null ? null : preview_r2.plain.img) ? preview_r2.plain.img : preview_r2.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](10, _c0, ctx_r4.configPreview.size ? ctx_r4.configPreview.size.width : ctx_r4.defaultPreviewSize.width, ctx_r4.configPreview.size ? ctx_r4.configPreview.size.height : ctx_r4.defaultPreviewSize.height))("title", preview_r2.modal.title ? preview_r2.modal.title : "")("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", preview_r2.modal.ariaLabel ? preview_r2.modal.ariaLabel : "");
        }
      }

      function PreviewsComponent_ng_container_1_ng_container_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PreviewsComponent_ng_container_1_ng_container_3_img_1_Template, 1, 13, "img", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var preview_r2 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", preview_r2 == null ? null : preview_r2.modal == null ? null : preview_r2.modal.img);
        }
      }

      function PreviewsComponent_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r12 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "a", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PreviewsComponent_ng_container_1_Template_a_click_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r11.onNavigationEvent("left", $event);
          })("keyup", function PreviewsComponent_ng_container_1_Template_a_keyup_1_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

            var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r13.onNavigationEvent("left", $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, PreviewsComponent_ng_container_1_ng_container_3_Template, 2, 1, "ng-container", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](4, "a", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PreviewsComponent_ng_container_1_Template_a_click_4_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

            var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r14.onNavigationEvent("right", $event);
          })("keyup", function PreviewsComponent_ng_container_1_Template_a_keyup_4_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r12);

            var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

            return ctx_r15.onNavigationEvent("right", $event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](5, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r0.configPreview.arrows && ctx_r0.start > 0 ? 0 : -1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.previewScrollPrevAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r0.configPreview.arrows && ctx_r0.start > 0 ? "left-arrow-preview-image" : "empty-arrow-preview-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.previewScrollPrevTitle);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.previews)("ngForTrackBy", ctx_r0.trackById);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx_r0.configPreview.arrows && ctx_r0.end < ctx_r0.images.length ? 0 : -1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.previewScrollNextAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx_r0.configPreview.arrows && ctx_r0.end < ctx_r0.images.length ? "right-arrow-preview-image" : "empty-arrow-preview-image", "");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.previewScrollNextTitle);
        }
      }

      var _c10 = ".arrow-preview-image[_ngcontent-%COMP%], .empty-arrow-preview-image[_ngcontent-%COMP%], .left-arrow-preview-image[_ngcontent-%COMP%], .right-arrow-preview-image[_ngcontent-%COMP%]{width:15px;height:15px;opacity:.5}.empty-arrow-preview-image[_ngcontent-%COMP%]{background:#000;opacity:0}.left-arrow-preview-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.left-arrow-preview-image[_ngcontent-%COMP%]:hover{transform:scale(1.2)}.right-arrow-preview-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.right-arrow-preview-image[_ngcontent-%COMP%]:hover{transform:scale(1.2)}";

      function LoadingSpinnerComponent_ng_container_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "div", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](4, "div", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "div", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "div", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "span", 12);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](4, "span", 13);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](5, "span", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](6, "span", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_7_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "div", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function LoadingSpinnerComponent_ng_container_8_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](2, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](4, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](5, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_img_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r13 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "img", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_img_1_Template_img_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r13);

            var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r11 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r11.showModalGalleryByImage(imgCol_r5);
          })("keyup", function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_img_1_Template_img_keyup_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r13);

            var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

            var ctx_r14 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r14.showModalGalleryByImage(imgCol_r5);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r10 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", (imgCol_r5.plain == null ? null : imgCol_r5.plain.alt) ? imgCol_r5.plain.alt : ctx_r10.getAltPlainDescriptionByImage(imgCol_r5));

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("src", (imgCol_r5.plain == null ? null : imgCol_r5.plain.img) ? imgCol_r5.plain.img : imgCol_r5.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](6, _c0, ctx_r10.size == null ? null : ctx_r10.size.width, ctx_r10.size == null ? null : ctx_r10.size.height))("title", (imgCol_r5.plain == null ? null : imgCol_r5.plain.title) ? imgCol_r5.plain.title : ctx_r10.getTitleDisplay(imgCol_r5))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", imgCol_r5.plain == null ? null : imgCol_r5.plain.ariaLabel);
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_img_1_Template, 1, 9, "img", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", imgCol_r5 == null ? null : imgCol_r5.modal == null ? null : imgCol_r5.modal.img);
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_a_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r21 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "a", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_a_0_Template_a_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r21);

            var j_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).index;

            var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r19.showModalGallery(j_r6);
          })("keyup", function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_a_0_Template_a_keyup_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵrestoreView"](_r21);

            var j_r6 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).index;

            var ctx_r22 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

            return ctx_r22.showModalGallery(j_r6);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](2).$implicit;

          var ctx_r18 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleMap"](ctx_r18.configPlainGallery.advanced == null ? null : ctx_r18.configPlainGallery.advanced.additionalBackground);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("image", imgCol_r5)("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction2"](7, _c0, ctx_r18.size == null ? null : ctx_r18.size.width, ctx_r18.size == null ? null : ctx_r18.size.height))("title", (imgCol_r5.plain == null ? null : imgCol_r5.plain.title) ? imgCol_r5.plain.title : ctx_r18.getTitleDisplay(imgCol_r5))("tabindex", 0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", imgCol_r5.plain == null ? null : imgCol_r5.plain.ariaLabel);
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_a_0_Template, 1, 10, "a", 7);
        }

        if (rf & 2) {
          var imgCol_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", imgCol_r5 == null ? null : imgCol_r5.modal == null ? null : imgCol_r5.modal.img);
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_container_1_Template, 2, 1, "ng-container", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, PlainGalleryComponent_div_0_ng_container_1_ng_container_1_ng_template_2_Template, 1, 1, "ng-template", null, 4, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](3);

          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !(ctx_r4.configPlainGallery.advanced == null ? null : ctx_r4.configPlainGallery.advanced.aTags))("ngIfElse", _r8);
        }
      }

      function PlainGalleryComponent_div_0_ng_container_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](0);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PlainGalleryComponent_div_0_ng_container_1_ng_container_1_Template, 4, 2, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();
        }

        if (rf & 2) {
          var imgRow_r2 = ctx.$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", imgRow_r2);
        }
      }

      function PlainGalleryComponent_div_0_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PlainGalleryComponent_div_0_ng_container_1_Template, 2, 1, "ng-container", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("wrap", ctx_r0.wrapStyle)("width", ctx_r0.widthStyle)("direction", ctx_r0.directionStyle)("justify", ctx_r0.justifyStyle)("title", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.plainGalleryContentTitle);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx_r0.accessibilityConfig == null ? null : ctx_r0.accessibilityConfig.plainGalleryContentAriaLabel);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngForOf", ctx_r0.imageGrid);
        }
      }

      var ClickOutsideDirective = /*#__PURE__*/function () {
        function ClickOutsideDirective() {
          _classCallCheck(this, ClickOutsideDirective);

          /**
           * Output to emit an event if the clicked element class doesn't contain 'inside' or it is 'hidden'. The payload is a boolean.
           */
          this.clickOutside = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        }
        /**
         * Method called by Angular itself every click thanks to `\@HostListener`.
         * @param {?} event
         * @return {?}
         */


        _createClass(ClickOutsideDirective, [{
          key: "onClick",
          value: function onClick(event) {
            event.stopPropagation();
            /** @type {?} */

            var targetElement = event.target;

            if (!this.clickOutsideEnable || !targetElement) {
              return;
            }
            /** @type {?} */


            var isInside = false;
            /** @type {?} */

            var isHidden = false;

            if (typeof targetElement.className !== 'string') {
              // it happens with @fortawesome/fontawesome 5
              // for some reasons className is an object with 2 empty properties inside
              isInside = true;
            } else {
              // in normal scenarios, use classname, because it's a simple string
              isInside = targetElement.className && targetElement.className.startsWith('inside');
              isHidden = targetElement.className.includes('hidden');
            } // if inside => don't close modal gallery
            // if hidden => close modal gallery

            /*
                i i' h | close
                0 1  0 |   1 => close modal gallery
                0 1  1 |   1 => close modal gallery
                1 0  0 |   0
                1 0  1 |   1 => close modal gallery
             */


            if (!isInside || isHidden) {
              // close modal gallery
              this.clickOutside.emit(true);
            }
          }
        }]);

        return ClickOutsideDirective;
      }();

      ClickOutsideDirective.ɵfac = function ClickOutsideDirective_Factory(t) {
        return new (t || ClickOutsideDirective)();
      };

      ClickOutsideDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: ClickOutsideDirective,
        selectors: [["", "ksClickOutside", ""]],
        hostBindings: function ClickOutsideDirective_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function ClickOutsideDirective_click_HostBindingHandler($event) {
              return ctx.onClick($event);
            });
          }
        },
        inputs: {
          clickOutsideEnable: "clickOutsideEnable"
        },
        outputs: {
          clickOutside: "clickOutside"
        }
      });
      ClickOutsideDirective.propDecorators = {
        clickOutsideEnable: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        clickOutside: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        onClick: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['click', ['$event']]
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ClickOutsideDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksClickOutside]'
          }]
        }], function () {
          return [];
        }, {
          clickOutside: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],

          /**
           * Method called by Angular itself every click thanks to `\@HostListener`.
           * @param {?} event
           * @return {?}
           */
          onClick: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['click', ['$event']]
          }],
          clickOutsideEnable: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to change the size of an element.
       */


      var SizeDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function SizeDirective(renderer, el) {
          _classCallCheck(this, SizeDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(SizeDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change both width and height of an element.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (!this.sizeConfig) {
              return;
            } // apply [style.width]


            this.renderer.setStyle(this.el.nativeElement, 'width', this.sizeConfig.width);
            this.renderer.setStyle(this.el.nativeElement, 'height', this.sizeConfig.height);
          }
        }]);

        return SizeDirective;
      }();

      SizeDirective.ɵfac = function SizeDirective_Factory(t) {
        return new (t || SizeDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      SizeDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: SizeDirective,
        selectors: [["", "ksSize", ""]],
        inputs: {
          sizeConfig: "sizeConfig"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      SizeDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      SizeDirective.propDecorators = {
        sizeConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](SizeDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksSize]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          sizeConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */


      var KeyboardNavigationDirective = /*#__PURE__*/function () {
        function KeyboardNavigationDirective() {
          _classCallCheck(this, KeyboardNavigationDirective);

          this.keyPress = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        }
        /**
         * Listener to catch keyboard's events and call the right method based on the key.
         * For instance, pressing esc, this will call `closeGallery(Action.KEYBOARD)` and so on.
         * If you passed a valid `keyboardConfig` esc, right and left buttons will be customized based on your data.
         * @param {?} e KeyboardEvent caught by the listener.
         * @return {?}
         */


        _createClass(KeyboardNavigationDirective, [{
          key: "onKeyDown",
          value: function onKeyDown(e) {
            if (!this.isOpen) {
              return;
            }

            this.keyPress.emit(e.keyCode);
          }
        }]);

        return KeyboardNavigationDirective;
      }();

      KeyboardNavigationDirective.ɵfac = function KeyboardNavigationDirective_Factory(t) {
        return new (t || KeyboardNavigationDirective)();
      };

      KeyboardNavigationDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: KeyboardNavigationDirective,
        selectors: [["", "ksKeyboardNavigation", ""]],
        hostBindings: function KeyboardNavigationDirective_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keydown", function KeyboardNavigationDirective_keydown_HostBindingHandler($event) {
              return ctx.onKeyDown($event);
            }, false, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵresolveWindow"]);
          }
        },
        inputs: {
          isOpen: "isOpen"
        },
        outputs: {
          keyPress: "keyPress"
        }
      });
      KeyboardNavigationDirective.propDecorators = {
        isOpen: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        keyPress: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        onKeyDown: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['window:keydown', ['$event']]
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](KeyboardNavigationDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksKeyboardNavigation]'
          }]
        }], function () {
          return [];
        }, {
          keyPress: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],

          /**
           * Listener to catch keyboard's events and call the right method based on the key.
           * For instance, pressing esc, this will call `closeGallery(Action.KEYBOARD)` and so on.
           * If you passed a valid `keyboardConfig` esc, right and left buttons will be customized based on your data.
           * @param {?} e KeyboardEvent caught by the listener.
           * @return {?}
           */
          onKeyDown: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['window:keydown', ['$event']]
          }],
          isOpen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to change the flex-wrap css property of an element.
       */


      var WrapDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function WrapDirective(renderer, el) {
          _classCallCheck(this, WrapDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(WrapDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change both widht and flex-wrap css properties.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            // TODO is this right???? If wrap os false I cannot apply width and flex-wrap
            if (!this.wrap) {
              return;
            }

            this.renderer.setStyle(this.el.nativeElement, 'width', this.width);
            this.renderer.setStyle(this.el.nativeElement, 'flex-wrap', this.wrap ? 'wrap' : 'nowrap');
          }
        }]);

        return WrapDirective;
      }();

      WrapDirective.ɵfac = function WrapDirective_Factory(t) {
        return new (t || WrapDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      WrapDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: WrapDirective,
        selectors: [["", "ksWrap", ""]],
        inputs: {
          wrap: "wrap",
          width: "width"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      WrapDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      WrapDirective.propDecorators = {
        wrap: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        width: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](WrapDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksWrap]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          wrap: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          width: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to change the flex-direction of an element, based on two inputs (`direction` and `justify`).
       */


      var DirectionDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function DirectionDirective(renderer, el) {
          _classCallCheck(this, DirectionDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(DirectionDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change both direction and justify of an element.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (!this.direction || !this.justify) {
              return;
            }

            this.renderer.setStyle(this.el.nativeElement, 'flex-direction', this.direction);
            this.renderer.setStyle(this.el.nativeElement, 'justify-content', this.justify);
          }
        }]);

        return DirectionDirective;
      }();

      DirectionDirective.ɵfac = function DirectionDirective_Factory(t) {
        return new (t || DirectionDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      DirectionDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: DirectionDirective,
        selectors: [["", "ksDirection", ""]],
        inputs: {
          direction: "direction",
          justify: "justify"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      DirectionDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      DirectionDirective.propDecorators = {
        direction: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        justify: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DirectionDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksDirection]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          direction: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          justify: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /*
       The MIT License (MIT)
      
       Copyright (c) 2017-2018 Stefano Cappa (Ks89)
      
       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:
      
       The above copyright notice and this permission notice shall be included in all
       copies or substantial portions of the Software.
      
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.
       */

      /**
       * Class `Image` that represents an image with both `modal` and `plain` configurations.
       * Both image `id` and `modal` are mandatory, instead `plain` is optional.
       */


      var _Image =
      /**
       * @param {?} id
       * @param {?} modal
       * @param {?=} plain
       */
      function _Image(id, modal, plain) {
        _classCallCheck(this, _Image);

        this.id = id;
        this.modal = modal;
        this.plain = plain;
      };
      /**
       * Class `ImageEvent` that represents the event payload with the result and the triggered action.
       */


      var _ImageEvent =
      /**
       * @param {?} action
       * @param {?} result
       */
      function _ImageEvent(action, result) {
        _classCallCheck(this, _ImageEvent);

        this.action = action;
        this.result = result;
      };
      /**
       * Class `ImageModalEvent` that represents the event payload with the result and the triggered action.
       */


      var _ImageModalEvent = /*#__PURE__*/function (_ImageEvent2) {
        _inherits(_ImageModalEvent, _ImageEvent2);

        var _super = _createSuper(_ImageModalEvent);

        /**
         * @param {?} action
         * @param {?} result
         */
        function _ImageModalEvent(action, result) {
          _classCallCheck(this, _ImageModalEvent);

          return _super.call(this, action, result);
        }

        return _ImageModalEvent;
      }(_ImageEvent);
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to add an image to an `<a>` tag with some additional custom properties.
       */


      var ATagBgImageDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function ATagBgImageDirective(renderer, el) {
          _classCallCheck(this, ATagBgImageDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(ATagBgImageDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to add an image as background of an `<a>` tag.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (!this.image || !this.image.plain && !this.image.modal) {
              return;
            }
            /** @type {?} */


            var imgPath = this.image.plain && this.image.plain.img ? this.image.plain.img : this.image.modal.img;
            this.renderer.setStyle(this.el.nativeElement, 'background', "url(\"".concat(imgPath, "\") ").concat(this.style));
          }
        }]);

        return ATagBgImageDirective;
      }();

      ATagBgImageDirective.ɵfac = function ATagBgImageDirective_Factory(t) {
        return new (t || ATagBgImageDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      ATagBgImageDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: ATagBgImageDirective,
        selectors: [["", "ksATagBgImage", ""]],
        inputs: {
          image: "image",
          style: "style"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      ATagBgImageDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      ATagBgImageDirective.propDecorators = {
        image: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        style: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ATagBgImageDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksATagBgImage]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          image: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          style: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to customize the description.
       */


      var DescriptionDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function DescriptionDirective(renderer, el) {
          _classCallCheck(this, DescriptionDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(DescriptionDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change description's style.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (!this.description) {
              return;
            }

            if (this.description.style) {
              this.renderer.setStyle(this.el.nativeElement, 'background', this.description.style.bgColor);
              this.renderer.setStyle(this.el.nativeElement, 'color', this.description.style.textColor);

              if (this.description.style.width) {
                this.renderer.setStyle(this.el.nativeElement, 'width', this.description.style.width);
              }

              if (this.description.style.height) {
                this.renderer.setStyle(this.el.nativeElement, 'height', this.description.style.height);
              }

              if (this.description.style.position) {
                this.renderer.setStyle(this.el.nativeElement, 'position', this.description.style.position);
              }

              if (this.description.style.top) {
                this.renderer.setStyle(this.el.nativeElement, 'top', this.description.style.top);
              }

              if (this.description.style.bottom) {
                this.renderer.setStyle(this.el.nativeElement, 'bottom', this.description.style.bottom);
              }

              if (this.description.style.left) {
                this.renderer.setStyle(this.el.nativeElement, 'left', this.description.style.left);
              }

              if (this.description.style.right) {
                this.renderer.setStyle(this.el.nativeElement, 'right', this.description.style.right);
              }

              this.renderer.setStyle(this.el.nativeElement, 'margin-top', this.description.style.marginTop ? this.description.style.marginTop : '0px');
              this.renderer.setStyle(this.el.nativeElement, 'margin-bottom', this.description.style.marginBottom ? this.description.style.marginBottom : '0px');
              this.renderer.setStyle(this.el.nativeElement, 'margin-left', this.description.style.marginLeft ? this.description.style.marginLeft : '0px');
              this.renderer.setStyle(this.el.nativeElement, 'margin-right', this.description.style.marginRight ? this.description.style.marginRight : '0px');
            }
          }
        }]);

        return DescriptionDirective;
      }();

      DescriptionDirective.ɵfac = function DescriptionDirective_Factory(t) {
        return new (t || DescriptionDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      DescriptionDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: DescriptionDirective,
        selectors: [["", "ksDescription", ""]],
        inputs: {
          description: "description"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      DescriptionDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      DescriptionDirective.propDecorators = {
        description: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DescriptionDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksDescription]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          description: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to change margins of an element.
       */


      var MarginDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function MarginDirective(renderer, el) {
          _classCallCheck(this, MarginDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(MarginDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change both width and height of an element.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (this.marginLeft) {
              this.renderer.setStyle(this.el.nativeElement, 'margin-left', this.marginLeft);
            }

            if (this.marginRight) {
              this.renderer.setStyle(this.el.nativeElement, 'margin-right', this.marginRight);
            }

            if (this.marginTop) {
              this.renderer.setStyle(this.el.nativeElement, 'margin-top', this.marginTop);
            }

            if (this.marginBottom) {
              this.renderer.setStyle(this.el.nativeElement, 'margin-bottom', this.marginBottom);
            }
          }
        }]);

        return MarginDirective;
      }();

      MarginDirective.ɵfac = function MarginDirective_Factory(t) {
        return new (t || MarginDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      MarginDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: MarginDirective,
        selectors: [["", "ksMargin", ""]],
        inputs: {
          marginLeft: "marginLeft",
          marginRight: "marginRight",
          marginTop: "marginTop",
          marginBottom: "marginBottom"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      MarginDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      MarginDirective.propDecorators = {
        marginLeft: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        marginRight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        marginTop: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        marginBottom: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](MarginDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksMargin]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          marginLeft: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          marginRight: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          marginTop: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          marginBottom: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Directive to change the max size of an element.
       */


      var MaxSizeDirective = /*#__PURE__*/function () {
        /**
         * @param {?} renderer
         * @param {?} el
         */
        function MaxSizeDirective(renderer, el) {
          _classCallCheck(this, MaxSizeDirective);

          this.renderer = renderer;
          this.el = el;
        }
        /**
         * Method ´ngOnInit´ to apply the style of this directive.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(MaxSizeDirective, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.applyStyle();
          }
          /**
           * Method ´ngOnChanges´ to apply the style of this directive.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges() {
            this.applyStyle();
          }
          /**
           * Private method to change both max-width and max-height of an element.
           * @private
           * @return {?}
           */

        }, {
          key: "applyStyle",
          value: function applyStyle() {
            if (!this.sizeConfig) {
              return;
            }

            if (this.sizeConfig.maxWidth) {
              this.renderer.setStyle(this.el.nativeElement, 'max-width', this.sizeConfig.maxWidth);
            }

            if (this.sizeConfig.maxHeight) {
              this.renderer.setStyle(this.el.nativeElement, 'max-height', this.sizeConfig.maxHeight);
            }
          }
        }]);

        return MaxSizeDirective;
      }();

      MaxSizeDirective.ɵfac = function MaxSizeDirective_Factory(t) {
        return new (t || MaxSizeDirective)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef));
      };

      MaxSizeDirective.ɵdir = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineDirective"]({
        type: MaxSizeDirective,
        selectors: [["", "ksMaxSize", ""]],
        inputs: {
          sizeConfig: "sizeConfig"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]]
      });
      /** @nocollapse */

      MaxSizeDirective.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
        }];
      };

      MaxSizeDirective.propDecorators = {
        sizeConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](MaxSizeDirective, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Directive,
          args: [{
            selector: '[ksMaxSize]'
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Renderer2
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ElementRef
          }];
        }, {
          sizeConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Array of all directives.
       * @type {?}
       */


      var DIRECTIVES = [ClickOutsideDirective, SizeDirective, KeyboardNavigationDirective, WrapDirective, DirectionDirective, ATagBgImageDirective, DescriptionDirective, MarginDirective, MaxSizeDirective];
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with the semi-transparent background.
       */

      var BackgroundComponent = function BackgroundComponent() {
        _classCallCheck(this, BackgroundComponent);
      };

      BackgroundComponent.ɵfac = function BackgroundComponent_Factory(t) {
        return new (t || BackgroundComponent)();
      };

      BackgroundComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: BackgroundComponent,
        selectors: [["ks-background"]],
        inputs: {
          isOpen: "isOpen",
          accessibilityConfig: "accessibilityConfig"
        },
        decls: 1,
        vars: 1,
        consts: [["class", "ng-overlay", 3, "title", 4, "ngIf"], [1, "ng-overlay", 3, "title"]],
        template: function BackgroundComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, BackgroundComponent_div_0_Template, 1, 2, "div", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.isOpen);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf],
        styles: [".ng-overlay[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;opacity:.8;z-index:9999}"],
        changeDetection: 0
      });
      BackgroundComponent.propDecorators = {
        isOpen: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](BackgroundComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-background',
            template: "<div class=\"ng-overlay\" *ngIf=\"isOpen\"\n     [attr.aria-label]=\"accessibilityConfig?.backgroundAriaLabel\"\n     [title]=\"accessibilityConfig?.backgroundTitle\"></div>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [".ng-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:#000;opacity:.8;z-index:9999}"]
          }]
        }], null, {
          isOpen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /*
       The MIT License (MIT)
      
       Copyright (c) 2017-2018 Stefano Cappa (Ks89)
      
       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:
      
       The above copyright notice and this permission notice shall be included in all
       copies or substantial portions of the Software.
      
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.
       */

      /** @enum {number} */


      var _Action = {
        NORMAL: 0,
        CLICK: 1,
        KEYBOARD: 2,
        SWIPE: 3,
        LOAD: 4,
        AUTOPLAY: 5
      };
      _Action[_Action.NORMAL] = 'NORMAL';
      _Action[_Action.CLICK] = 'CLICK';
      _Action[_Action.KEYBOARD] = 'KEYBOARD';
      _Action[_Action.SWIPE] = 'SWIPE';
      _Action[_Action.LOAD] = 'LOAD';
      _Action[_Action.AUTOPLAY] = 'AUTOPLAY';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /** @type {?} */

      var KEYBOARD_CONFIGURATION = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.InjectionToken('KEYBOARD_CONFIGURATION');
      /**
       * Service to intercept ctrl+s (or cmd+s on macOS) using a third-party library, called Mousetrap.
       */

      var KeyboardService = /*#__PURE__*/function () {
        /**
         * Constructor of `KeyboardService` to init `mousetrap` and `shortcuts` private variables.
         * @param {?} config
         */
        function KeyboardService(config) {
          _classCallCheck(this, KeyboardService);

          // this.config is always defined, because forced by forRoot inside the module
          // when empty, it's simply an empty object: {}
          this.config = config;
          this.shortcuts = this.config && this.config.shortcuts ? this.config.shortcuts : ['ctrl+s', 'meta+s']; // temporary workaround to fix this issue: https://github.com/Ks89/angular-modal-gallery/issues/142

          if (this.config && !this.config.disableSsrWorkaround) {
            // To prevent issues with angular-universal on server-side
            if (typeof window !== 'undefined') {
              __webpack_require__(
              /*! mousetrap */
              13544);

              this.mousetrap = new Mousetrap();
            }
          }
        }
        /**
         * Method to add a lister for ctrl+s/cmd+s keyboard events.
         * @param {?} onBind
         * @return {?}
         */


        _createClass(KeyboardService, [{
          key: "add",
          value: function add(onBind) {
            // temporary workaround to fix this issue: https://github.com/Ks89/angular-modal-gallery/issues/142
            if (this.config && !this.config.disableSsrWorkaround) {
              // To prevent issues with angular-universal on server-side
              if (typeof window !== 'undefined') {
                this.mousetrap.bind(this.shortcuts,
                /**
                * @param {?} event
                * @param {?} combo
                * @return {?}
                */
                function (event, combo) {
                  if (event.preventDefault) {
                    event.preventDefault();
                  } else {
                    // internet explorer
                    event.returnValue = false;
                  }

                  onBind(event, combo);
                });
              }
            }
          }
          /**
           * Method to reset all listeners. Please, call this function when needed
           * to free resources ad prevent leaks.
           * @return {?}
           */

        }, {
          key: "reset",
          value: function reset() {
            // temporary workaround to fix this issue: https://github.com/Ks89/angular-modal-gallery/issues/142
            if (this.config && !this.config.disableSsrWorkaround) {
              // To prevent issues with angular-universal on server-side
              if (typeof window !== 'undefined') {
                this.mousetrap.reset();
              }
            }
          }
        }]);

        return KeyboardService;
      }();

      KeyboardService.ɵfac = function KeyboardService_Factory(t) {
        return new (t || KeyboardService)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵinject"](KEYBOARD_CONFIGURATION));
      };

      KeyboardService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: KeyboardService,
        factory: KeyboardService.ɵfac
      });
      /** @nocollapse */

      KeyboardService.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [KEYBOARD_CONFIGURATION]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](KeyboardService, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [KEYBOARD_CONFIGURATION]
            }]
          }];
        }, null);
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Service to call methods on a gallery by its galleryId.
       */


      var _GalleryService = /*#__PURE__*/function () {
        function _GalleryService() {
          _classCallCheck(this, _GalleryService);

          this.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          this.update = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          this.autoPlay = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
        }
        /**
         * Method to open the modal gallery with the galleryId passed as parameter.
         * It will automatically shows the image at position index.
         * @throws a error with a message if galleryId is either undefined, < 0 or index is < 0
         * @param {?} galleryId number or undefined that represents the unique id of the gallery.
         * @param {?} index number of the image that you want to open.
         * @return {?}
         */


        _createClass(_GalleryService, [{
          key: "openGallery",
          value: function openGallery(galleryId, index) {
            if (galleryId === undefined || galleryId < 0 || index < 0) {
              throw new Error('Cannot open gallery via GalleryService with either index<0 or galleryId<0 or galleryId===undefined');
            }

            this.navigate.emit({
              galleryId: galleryId,
              index: index
            });
          }
          /**
           * Method to navigate to a specific index of the modal gallery with the galleryId passed as parameter.
           * At the moment, it's like openGallery, but in upcoming releases it will change the behaviour.
           * @throws a error with a message if galleryId is either undefined, < 0 or index is < 0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @param {?} index number of the image that you want to open.
           * @return {?}
           */

        }, {
          key: "navigateGallery",
          value: function navigateGallery(galleryId, index) {
            if (galleryId === undefined || galleryId < 0 || index < 0) {
              throw new Error('Cannot navigate via GalleryService with either index<0 or galleryId<0 or galleryId===undefined');
            }

            this.navigate.emit({
              galleryId: galleryId,
              index: index
            });
          }
          /**
           * Method to close the modal gallery with the galleryId passed as parameter.
           * @throws a error with a message if galleryId is either undefined or < 0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @return {?}
           */

        }, {
          key: "closeGallery",
          value: function closeGallery(galleryId) {
            if (galleryId === undefined || galleryId < 0) {
              throw new Error('Cannot close gallery via GalleryService with galleryId<0 or galleryId===undefined');
            }

            this.close.emit(galleryId);
          }
          /**
           * Service to update an image with a new object
           * @throws a error with a message if galleryId is either undefined, < 0 or index is < 0
           *
           * \@since 6.3.0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @param {?} index number of the image that you want to update.
           * @param {?} image
           * @return {?}
           */

        }, {
          key: "updateGallery",
          value: function updateGallery(galleryId, index, image) {
            if (galleryId === undefined || galleryId < 0 || index < 0) {
              throw new Error('Cannot update gallery via GalleryService with either index<0 or galleryId<0 or galleryId===undefined');
            }

            if (!image) {
              throw new Error('Cannot update gallery via GalleryService, because image is not valid');
            }

            this.update.emit({
              galleryId: galleryId,
              index: index,
              image: image
            });
          }
          /**
           * Service to play modal-gallery
           * @throws a error with a message if galleryId is either undefined or < 0
           *
           * \@since 7.2.0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @return {?}
           */

        }, {
          key: "play",
          value: function play(galleryId) {
            if (galleryId === undefined || galleryId < 0) {
              throw new Error('Cannot play gallery via GalleryService with galleryId<0 or galleryId===undefined');
            }

            this.autoPlay.emit({
              galleryId: galleryId,
              result: true
            });
          }
          /**
           * Service to stop modal-gallery
           * @throws a error with a message if galleryId is either undefined or < 0
           *
           * \@since 7.2.0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @return {?}
           */

        }, {
          key: "stop",
          value: function stop(galleryId) {
            if (galleryId === undefined || galleryId < 0) {
              throw new Error('Cannot stop gallery via GalleryService with galleryId<0 or galleryId===undefined');
            }

            this.autoPlay.emit({
              galleryId: galleryId,
              result: false
            });
          }
        }]);

        return _GalleryService;
      }();

      _GalleryService.ɵfac = function GalleryService_Factory(t) {
        return new (t || _GalleryService)();
      };

      _GalleryService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: _GalleryService,
        factory: _GalleryService.ɵfac,
        providedIn: 'root'
      });
      /** @nocollapse */

      _GalleryService.ngInjectableDef = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.defineInjectable)({
        factory: function GalleryService_Factory() {
          return new _GalleryService();
        },
        token: _GalleryService,
        providedIn: "root"
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_GalleryService, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [];
        }, null);
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Code of the keyboard's key `enter`
       * @type {?}
       */


      var ENTER_CODE = 'Enter';
      /**
       * Code of the keyboard's key `space`
       * @type {?}
       */

      var SPACE_CODE = 'Space';
      /**
       * KeyCode of the main mouse button
       * @type {?}
       */

      var MOUSE_MAIN_BUTTON_CLICK = 0;
      /**
       * Const NEXT
       * @type {?}
       */

      var NEXT = 1;
      /**
       * Const PREV
       * @type {?}
       */

      var PREV = -1;
      /**
       * Const NOTHING to represents a situation when it isn't both NEXT and PREV
       * @type {?}
       */

      var NOTHING = 0;
      /**
       * Const to represent the right direction
       * @type {?}
       */

      var DIRECTION_RIGHT = 'right';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Provides some useful methods to add accessibility features to subclasses.
       * In particular, it exposes a method to handle navigation event with both Keyboard and Mouse
       * and another with also the direction (right or left).
       */

      var AccessibleComponent = /*#__PURE__*/function () {
        function AccessibleComponent() {
          _classCallCheck(this, AccessibleComponent);
        }
        /**
         * Method to handle navigation events with both Keyboard and Mouse.
         * @param {?} direction
         * @param {?} event
         * @return {?} number -1 for PREV, 1 for NEXT and 0 for NOTHING
         */


        _createClass(AccessibleComponent, [{
          key: "handleNavigationEvent",
          value: function handleNavigationEvent(direction, event) {
            if (!event) {
              return NOTHING;
            }

            if (event instanceof KeyboardEvent) {
              return this.handleKeyboardNavigationEvent(direction, event);
            } else if (event instanceof MouseEvent) {
              return this.handleMouseNavigationEvent(direction, event);
            }

            return NOTHING;
          }
          /**
           * Method to handle events over an image, for instance a keypress with the Keyboard or a Mouse click.
           * @param {?} event
           * @return {?} number 1 for NEXT and 0 for NOTHING
           */

        }, {
          key: "handleImageEvent",
          value: function handleImageEvent(event) {
            if (!event) {
              return NOTHING;
            }

            if (event instanceof KeyboardEvent) {
              return this.handleImageKeyboardEvent(event);
            } else if (event instanceof MouseEvent) {
              return this.handleImageMouseEvent(event);
            }

            return NOTHING;
          }
          /**
           * Private method to handle keyboard events over an image.
           * @private
           * @param {?} event
           * @return {?} number 1 for NEXT and 0 for NOTHING
           */

        }, {
          key: "handleImageKeyboardEvent",
          value: function handleImageKeyboardEvent(event) {
            /** @type {?} */
            var key = event.code;

            if (key === SPACE_CODE || key === ENTER_CODE) {
              return NEXT;
            }

            return NOTHING;
          }
          /**
           * Private method to handle mouse events over an image.
           * @private
           * @param {?} event
           * @return {?} number 1 for NEXT and 0 for NOTHING
           */

        }, {
          key: "handleImageMouseEvent",
          value: function handleImageMouseEvent(event) {
            /** @type {?} */
            var mouseBtn = event.button;

            if (mouseBtn === MOUSE_MAIN_BUTTON_CLICK) {
              return NEXT;
            }

            return NOTHING;
          }
          /**
           * Method to handle events over an image, for instance a keypress with the Keyboard or a Mouse click.
           * @private
           * @param {?} direction
           * @param {?} event
           * @return {?} number -1 for PREV, 1 for NEXT and 0 for NOTHING
           */

        }, {
          key: "handleKeyboardNavigationEvent",
          value: function handleKeyboardNavigationEvent(direction, event) {
            /** @type {?} */
            var key = event.code;

            if (key === SPACE_CODE || key === ENTER_CODE) {
              return direction === DIRECTION_RIGHT ? NEXT : PREV;
            }

            return NOTHING;
          }
          /**
           * Method to handle events over an image, for instance a keypress with the Keyboard or a Mouse click.
           * @private
           * @param {?} direction
           * @param {?} event
           * @return {?} number -1 for PREV, 1 for NEXT and 0 for NOTHING
           */

        }, {
          key: "handleMouseNavigationEvent",
          value: function handleMouseNavigationEvent(direction, event) {
            /** @type {?} */
            var mouseBtn = event.button;

            if (mouseBtn === MOUSE_MAIN_BUTTON_CLICK) {
              return direction === DIRECTION_RIGHT ? NEXT : PREV;
            }

            return NOTHING;
          }
        }]);

        return AccessibleComponent;
      }();

      AccessibleComponent.ɵfac = function AccessibleComponent_Factory(t) {
        return new (t || AccessibleComponent)();
      };

      AccessibleComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: AccessibleComponent,
        selectors: [["ks-accessible"]],
        decls: 0,
        vars: 0,
        template: function AccessibleComponent_Template(rf, ctx) {},
        encapsulation: 2,
        changeDetection: 0
      });
      /** @nocollapse */

      AccessibleComponent.ctorParameters = function () {
        return [];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](AccessibleComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-accessible',
            template: "",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush
          }]
        }], function () {
          return [];
        }, null);
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /** @enum {number} */


      var _DescriptionStrategy = {
        ALWAYS_HIDDEN: 1,
        ALWAYS_VISIBLE: 2,
        HIDE_IF_EMPTY: 3
      };
      _DescriptionStrategy[_DescriptionStrategy.ALWAYS_HIDDEN] = 'ALWAYS_HIDDEN';
      _DescriptionStrategy[_DescriptionStrategy.ALWAYS_VISIBLE] = 'ALWAYS_VISIBLE';
      _DescriptionStrategy[_DescriptionStrategy.HIDE_IF_EMPTY] = 'HIDE_IF_EMPTY';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /*
       The MIT License (MIT)
      
       Copyright (c) 2017-2018 Stefano Cappa (Ks89)
      
       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:
      
       The above copyright notice and this permission notice shall be included in all
       copies or substantial portions of the Software.
      
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.
       */

      /** @enum {number} */

      var Keyboard = {
        ESC: 27,
        LEFT_ARROW: 37,
        RIGHT_ARROW: 39,
        UP_ARROW: 38,
        DOWN_ARROW: 40
      };
      Keyboard[Keyboard.ESC] = 'ESC';
      Keyboard[Keyboard.LEFT_ARROW] = 'LEFT_ARROW';
      Keyboard[Keyboard.RIGHT_ARROW] = 'RIGHT_ARROW';
      Keyboard[Keyboard.UP_ARROW] = 'UP_ARROW';
      Keyboard[Keyboard.DOWN_ARROW] = 'DOWN_ARROW';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /** @enum {number} */

      var _LoadingType = {
        STANDARD: 1,
        CIRCULAR: 2,
        BARS: 3,
        DOTS: 4,
        CUBE_FLIPPING: 5,
        CIRCLES: 6,
        EXPLOSING_SQUARES: 7
      };
      _LoadingType[_LoadingType.STANDARD] = 'STANDARD';
      _LoadingType[_LoadingType.CIRCULAR] = 'CIRCULAR';
      _LoadingType[_LoadingType.BARS] = 'BARS';
      _LoadingType[_LoadingType.DOTS] = 'DOTS';
      _LoadingType[_LoadingType.CUBE_FLIPPING] = 'CUBE_FLIPPING';
      _LoadingType[_LoadingType.CIRCLES] = 'CIRCLES';
      _LoadingType[_LoadingType.EXPLOSING_SQUARES] = 'EXPLOSING_SQUARES';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /*
       The MIT License (MIT)
      
       Copyright (c) 2017-2018 Stefano Cappa (Ks89)
      
       Permission is hereby granted, free of charge, to any person obtaining a copy
       of this software and associated documentation files (the "Software"), to deal
       in the Software without restriction, including without limitation the rights
       to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Software, and to permit persons to whom the Software is
       furnished to do so, subject to the following conditions:
      
       The above copyright notice and this permission notice shall be included in all
       copies or substantial portions of the Software.
      
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
       AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
       OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
       SOFTWARE.
       */

      /**
       * Utility function to get the index of the input `image` from `arrayOfImages`
       * @throws an Error if either image or arrayOfImages are not valid,
       *  or if the input image doesn't contain an 'id', or the 'id' is < 0
       * @param {?} image
       * @param {?} arrayOfImages
       * @return {?} number the index of the image. -1 if not found.
       */

      function getIndex(image, arrayOfImages) {
        if (!image) {
          throw new Error('image must be a valid Image object');
        }

        if (!arrayOfImages) {
          throw new Error('arrayOfImages must be a valid Image[]');
        }

        if (!image.id && image.id !== 0) {
          // id = 0 is admitted
          throw new Error("A numeric Image 'id' is mandatory");
        }

        if (image.id < 0) {
          throw new Error("Image 'id' must be >= 0");
        }

        return arrayOfImages.findIndex(
        /**
        * @param {?} val
        * @return {?}
        */
        function (val) {
          return val.id === image.id;
        });
      }
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with the current image with some additional elements like arrows and side previews.
       */


      var CurrentImageComponent = /*#__PURE__*/function (_AccessibleComponent) {
        _inherits(CurrentImageComponent, _AccessibleComponent);

        var _super2 = _createSuper(CurrentImageComponent);

        /**
         * @param {?} _platformId
         * @param {?} _ngZone
         * @param {?} ref
         */
        function CurrentImageComponent(_platformId, _ngZone, ref) {
          var _this4;

          _classCallCheck(this, CurrentImageComponent);

          _this4 = _super2.call(this);
          _this4._platformId = _platformId;
          _this4._ngZone = _ngZone;
          _this4.ref = ref;
          /**
           * Output to emit an event when images are loaded. The payload contains an `ImageLoadEvent`.
           */

          _this4.loadImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit any changes of the current image. The payload contains an `ImageModalEvent`.
           */

          _this4.changeImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the modal gallery is closed. The payload contains an `ImageModalEvent`.
           */

          _this4.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Subject to play modal-gallery.
           */

          _this4.start$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          /**
           * Subject to stop modal-gallery.
           */

          _this4.stop$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          /**
           * Enum of type `Action` that represents a normal action.
           * Declared here to be used inside the template.
           */

          _this4.normalAction = _Action.NORMAL;
          /**
           * Enum of type `Action` that represents a mouse click on a button.
           * Declared here to be used inside the template.
           */

          _this4.clickAction = _Action.CLICK;
          /**
           * Enum of type `Action` that represents a keyboard action.
           * Declared here to be used inside the template.
           */

          _this4.keyboardAction = _Action.KEYBOARD;
          /**
           * Boolean that it's true when you are watching the first image (currently visible).
           * False by default
           */

          _this4.isFirstImage = false;
          /**
           * Boolean that it's true when you are watching the last image (currently visible).
           * False by default
           */

          _this4.isLastImage = false;
          /**
           * Boolean that it's true if an image of the modal gallery is still loading.
           * True by default
           */

          _this4.loading = true;
          /**
           * Private object without type to define all swipe actions used by hammerjs.
           */

          _this4.SWIPE_ACTION = {
            LEFT: 'swipeleft',
            RIGHT: 'swiperight',
            UP: 'swipeup',
            DOWN: 'swipedown'
          };
          return _this4;
        }
        /**
         * Listener to stop the gallery when the mouse pointer is over the current image.
         * @return {?}
         */


        _createClass(CurrentImageComponent, [{
          key: "onMouseEnter",
          value: function onMouseEnter() {
            // if carousel feature is disable, don't do anything in any case
            if (!this.configSlide || !this.configSlide.playConfig) {
              return;
            }

            if (!this.configSlide.playConfig.pauseOnHover) {
              return;
            }

            this.stopCarousel();
          }
          /**
           * Listener to play the gallery when the mouse pointer leave the current image.
           * @return {?}
           */

        }, {
          key: "onMouseLeave",
          value: function onMouseLeave() {
            // if carousel feature is disable, don't do anything in any case
            if (!this.configSlide || !this.configSlide.playConfig) {
              return;
            }

            if (!this.configSlide.playConfig.pauseOnHover || !this.configSlide.playConfig.autoPlay) {
              return;
            }

            this.playCarousel();
          }
          /**
           * Method ´ngOnInit´ to build `configCurrentImage` applying default values.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called only one time!!!
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            /** @type {?} */
            var defaultLoading = {
              enable: true,
              type: _LoadingType.STANDARD
            };
            /** @type {?} */

            var defaultDescriptionStyle = {
              bgColor: 'rgba(0, 0, 0, .5)',
              textColor: 'white',
              marginTop: '0px',
              marginBottom: '0px',
              marginLeft: '0px',
              marginRight: '0px'
            };
            /** @type {?} */

            var defaultDescription = {
              strategy: _DescriptionStrategy.ALWAYS_VISIBLE,
              imageText: 'Image ',
              numberSeparator: '/',
              beforeTextDescription: ' - ',
              style: defaultDescriptionStyle
            };
            /** @type {?} */

            var defaultCurrentImageConfig = {
              navigateOnClick: true,
              loadingConfig: defaultLoading,
              description: defaultDescription,
              downloadable: false,
              invertSwipe: false
            };
            this.configCurrentImage = Object.assign({}, defaultCurrentImageConfig, this.currentImageConfig);
            this.configCurrentImage.description = Object.assign({}, defaultDescription, this.configCurrentImage.description);
            this.configSlide = Object.assign({}, this.slideConfig);
          }
          /**
           * Method ´ngOnChanges´ to update `loading` status and emit events.
           * If the gallery is open, then it will also manage boundary arrows and sliding.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @param {?} changes
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            /** @type {?} */
            var images = changes.images;
            /** @type {?} */

            var currentImage = changes.currentImage;

            if (currentImage && currentImage.previousValue !== currentImage.currentValue) {
              this.updateIndexes();
            } else if (images && images.previousValue !== images.currentValue) {
              this.updateIndexes();
            }
            /** @type {?} */


            var slideConfig = changes.slideConfig;

            if (slideConfig && slideConfig.previousValue !== slideConfig.currentValue) {
              this.configSlide = Object.assign({}, this.slideConfig);
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "ngAfterContentInit",
          value: function ngAfterContentInit() {
            var _this5 = this;

            // interval doesn't play well with SSR and protractor,
            // so we should run it in the browser and outside Angular
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this._platformId)) {
              this._ngZone.runOutsideAngular(
              /**
              * @return {?}
              */
              function () {
                _this5.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(
                /**
                * @return {?}
                */
                function () {
                  return _this5.configSlide && _this5.configSlide.playConfig && _this5.configSlide.playConfig.autoPlay && _this5.configSlide.playConfig.interval;
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(
                /**
                * @param {?} interval
                * @return {?}
                */
                function (interval) {
                  return interval > 0;
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.switchMap)(
                /**
                * @param {?} interval
                * @return {?}
                */
                function (interval) {
                  return (0, rxjs__WEBPACK_IMPORTED_MODULE_6__.timer)(interval).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.takeUntil)(_this5.stop$));
                })).subscribe(
                /**
                * @return {?}
                */
                function () {
                  return _this5._ngZone.run(
                  /**
                  * @return {?}
                  */
                  function () {
                    if (!_this5.isLastImage) {
                      _this5.nextImage(_Action.AUTOPLAY);
                    }

                    _this5.ref.markForCheck();
                  });
                });

                _this5.start$.next();
              });
            }
          }
          /**
           * Method to handle keypress based on the `keyboardConfig` input. It gets the keyCode of
           * the key that triggered the keypress event to navigate between images or to close the modal gallery.
           * @param {?} keyCode
           * @return {?}
           */

        }, {
          key: "onKeyPress",
          value: function onKeyPress(keyCode) {
            /** @type {?} */
            var esc = this.keyboardConfig && this.keyboardConfig.esc ? this.keyboardConfig.esc : Keyboard.ESC;
            /** @type {?} */

            var right = this.keyboardConfig && this.keyboardConfig.right ? this.keyboardConfig.right : Keyboard.RIGHT_ARROW;
            /** @type {?} */

            var left = this.keyboardConfig && this.keyboardConfig.left ? this.keyboardConfig.left : Keyboard.LEFT_ARROW;

            switch (keyCode) {
              case esc:
                this.close.emit(new _ImageModalEvent(_Action.KEYBOARD, true));
                break;

              case right:
                this.nextImage(_Action.KEYBOARD);
                break;

              case left:
                this.prevImage(_Action.KEYBOARD);
                break;
            }
          }
          /**
           * Method to get the image description based on input params.
           * If you provide a full description this will be the visible description, otherwise,
           * it will be built using the `Description` object, concatenating its fields.
           * @throws an Error if description isn't available
           * @param {?=} image
           * @return {?} String description of the image (or the current image if not provided)
           */

        }, {
          key: "getDescriptionToDisplay",
          value: function getDescriptionToDisplay() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!this.configCurrentImage || !this.configCurrentImage.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            }
            /** @type {?} */


            var imageWithoutDescription = !image.modal || !image.modal.description || image.modal.description === '';

            switch (this.configCurrentImage.description.strategy) {
              case _DescriptionStrategy.HIDE_IF_EMPTY:
                return imageWithoutDescription ? '' : image.modal.description + '';

              case _DescriptionStrategy.ALWAYS_HIDDEN:
                return '';

              default:
                // ----------- DescriptionStrategy.ALWAYS_VISIBLE -----------------
                return this.buildTextDescription(image, imageWithoutDescription);
            }
          }
          /**
           * Method to get `alt attribute`.
           * `alt` specifies an alternate text for an image, if the image cannot be displayed.
           * @param {?=} image
           * @return {?} String alt description of the image (or the current image if not provided)
           */

        }, {
          key: "getAltDescriptionByImage",
          value: function getAltDescriptionByImage() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!image) {
              return '';
            }

            return image.modal && image.modal.description ? image.modal.description : "Image ".concat(getIndex(image, this.images) + 1);
          }
          /**
           * Method to get the title attributes based on descriptions.
           * This is useful to prevent accessibility issues, because if DescriptionStrategy is ALWAYS_HIDDEN,
           * it prevents an empty string as title.
           * @throws an Error if description isn't available
           * @param {?=} image
           * @return {?} String title of the image based on descriptions
           */

        }, {
          key: "getTitleToDisplay",
          value: function getTitleToDisplay() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!this.configCurrentImage || !this.configCurrentImage.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            }
            /** @type {?} */


            var imageWithoutDescription = !image.modal || !image.modal.description || image.modal.description === '';
            /** @type {?} */

            var description = this.buildTextDescription(image, imageWithoutDescription);
            return description;
          }
          /**
           * Method to get the left side preview image.
           * @return {?} Image the image to show as size preview on the left
           */

        }, {
          key: "getLeftPreviewImage",
          value: function getLeftPreviewImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);

            if (currentIndex === 0 && this.configSlide.infinite) {
              // the current image is the first one,
              // so the previous one is the last image
              // because infinite is true
              return this.images[this.images.length - 1];
            }

            this.handleBoundaries(currentIndex);
            return this.images[Math.max(currentIndex - 1, 0)];
          }
          /**
           * Method to get the right side preview image.
           * @return {?} Image the image to show as size preview on the right
           */

        }, {
          key: "getRightPreviewImage",
          value: function getRightPreviewImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);

            if (currentIndex === this.images.length - 1 && this.configSlide.infinite) {
              // the current image is the last one,
              // so the next one is the first image
              // because infinite is true
              return this.images[0];
            }

            this.handleBoundaries(currentIndex);
            return this.images[Math.min(currentIndex + 1, this.images.length - 1)];
          }
          /**
           * Method called by events from both keyboard and mouse on an image.
           * This will invoke the nextImage method.
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onImageEvent",
          value: function onImageEvent(event) {
            var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Action.NORMAL;

            // check if triggered by a mouse click
            // If yes, It should block navigation when navigateOnClick is false
            if (action === _Action.CLICK && !this.configCurrentImage.navigateOnClick) {
              // a user has requested to block navigation via configCurrentImage.navigateOnClick property
              return;
            }
            /** @type {?} */


            var result = _get(_getPrototypeOf(CurrentImageComponent.prototype), "handleImageEvent", this).call(this, event);

            if (result === NEXT) {
              this.nextImage(action);
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a navigation arrow.
           * @param {?} direction
           * @param {?} event
           * @param {?=} action
           * @param {?=} disable
           * @return {?}
           */

        }, {
          key: "onNavigationEvent",
          value: function onNavigationEvent(direction, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.NORMAL;
            var disable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

            if (disable) {
              return;
            }
            /** @type {?} */


            var result = _get(_getPrototypeOf(CurrentImageComponent.prototype), "handleNavigationEvent", this).call(this, direction, event);

            if (result === NEXT) {
              this.nextImage(action);
            } else if (result === PREV) {
              this.prevImage(action);
            }
          }
          /**
           * Method to go back to the previous image.
           * @param {?=} action Enum of type `Action` that represents the source
           *  action that moved back to the previous image. `Action.NORMAL` by default.
           * @return {?}
           */

        }, {
          key: "prevImage",
          value: function prevImage() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Action.NORMAL;

            // check if prevImage should be blocked
            if (this.isPreventSliding(0)) {
              return;
            }
            /** @type {?} */


            var prevImage = this.getPrevImage();
            this.loading = !prevImage.previouslyLoaded;
            this.changeImage.emit(new _ImageModalEvent(action, getIndex(prevImage, this.images)));
            this.start$.next();
          }
          /**
           * Method to go back to the previous image.
           * @param {?=} action Enum of type `Action` that represents the source
           *  action that moved to the next image. `Action.NORMAL` by default.
           * @return {?}
           */

        }, {
          key: "nextImage",
          value: function nextImage() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Action.NORMAL;

            // check if nextImage should be blocked
            if (this.isPreventSliding(this.images.length - 1)) {
              return;
            }
            /** @type {?} */


            var nextImage = this.getNextImage();
            this.loading = !nextImage.previouslyLoaded;
            this.changeImage.emit(new _ImageModalEvent(action, getIndex(nextImage, this.images)));
            this.start$.next();
          }
          /**
           * Method to emit an event as loadImage output to say that the requested image if loaded.
           * This method is invoked by the javascript's 'load' event on an img tag.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onImageLoad",
          value: function onImageLoad(event) {
            /** @type {?} */
            var loadImageData = {
              status: true,
              index: getIndex(this.currentImage, this.images),
              id: this.currentImage.id
            };
            this.loadImage.emit(loadImageData);
            this.loading = false;
          }
          /**
           * Method used by Hammerjs to support touch gestures (you can also invert the swipe direction with configCurrentImage.invertSwipe).
           * @param {?=} action String that represent the direction of the swipe action. 'swiperight' by default.
           * @return {?}
           */

        }, {
          key: "swipe",
          value: function swipe() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.SWIPE_ACTION.RIGHT;

            switch (action) {
              case this.SWIPE_ACTION.RIGHT:
                if (this.configCurrentImage.invertSwipe) {
                  this.prevImage(_Action.SWIPE);
                } else {
                  this.nextImage(_Action.SWIPE);
                }

                break;

              case this.SWIPE_ACTION.LEFT:
                if (this.configCurrentImage.invertSwipe) {
                  this.nextImage(_Action.SWIPE);
                } else {
                  this.prevImage(_Action.SWIPE);
                }

                break;
              // case this.SWIPE_ACTION.UP:
              //   break;
              // case this.SWIPE_ACTION.DOWN:
              //   break;
            }
          }
          /**
           * Method used in `modal-gallery.component` to get the index of an image to delete.
           * @param {?=} image
           * @return {?} number the index of the image
           */

        }, {
          key: "getIndexToDelete",
          value: function getIndexToDelete() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;
            return getIndex(image, this.images);
          }
          /**
           * Method to play modal gallery.
           * @return {?}
           */

        }, {
          key: "playCarousel",
          value: function playCarousel() {
            this.start$.next();
          }
          /**
           * Stops modal gallery from cycling through items.
           * @return {?}
           */

        }, {
          key: "stopCarousel",
          value: function stopCarousel() {
            this.stop$.next();
          }
          /**
           * Method to cleanup resources. In fact, this will stop the modal gallery.
           * This is an Angular's lifecycle hook that is called when this component is destroyed.
           * @return {?}
           */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.stopCarousel();
          }
          /**
           * Private method to update both `isFirstImage` and `isLastImage` based on
           * the index of the current image.
           * @private
           * @param {?} currentIndex
           * @return {?}
           */

        }, {
          key: "handleBoundaries",
          value: function handleBoundaries(currentIndex) {
            if (this.images.length === 1) {
              this.isFirstImage = true;
              this.isLastImage = true;
              return;
            }

            if (!this.configSlide || this.configSlide.infinite === true) {
              // infinite sliding enabled
              this.isFirstImage = false;
              this.isLastImage = false;
            } else {
              switch (currentIndex) {
                case 0:
                  // execute this only if infinite sliding is disabled
                  this.isFirstImage = true;
                  this.isLastImage = false;
                  break;

                case this.images.length - 1:
                  // execute this only if infinite sliding is disabled
                  this.isFirstImage = false;
                  this.isLastImage = true;
                  break;

                default:
                  this.isFirstImage = false;
                  this.isLastImage = false;
                  break;
              }
            }
          }
          /**
           * Private method to check if next/prev actions should be blocked.
           * It checks if configSlide.infinite === false and if the image index is equals to the input parameter.
           * If yes, it returns true to say that sliding should be blocked, otherwise not.
           * @private
           * @param {?} boundaryIndex
           * @return {?} boolean true if configSlide.infinite === false and the current index is
           *  either the first or the last one.
           */

        }, {
          key: "isPreventSliding",
          value: function isPreventSliding(boundaryIndex) {
            return !!this.configSlide && this.configSlide.infinite === false && getIndex(this.currentImage, this.images) === boundaryIndex;
          }
          /**
           * Private method to get the next index.
           * This is necessary because at the end, when you call next again, you'll go to the first image.
           * That happens because all modal images are shown like in a circle.
           * @private
           * @return {?}
           */

        }, {
          key: "getNextImage",
          value: function getNextImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);
            /** @type {?} */

            var newIndex = 0;

            if (currentIndex >= 0 && currentIndex < this.images.length - 1) {
              newIndex = currentIndex + 1;
            } else {
              newIndex = 0; // start from the first index
            }

            return this.images[newIndex];
          }
          /**
           * Private method to get the previous index.
           * This is necessary because at index 0, when you call prev again, you'll go to the last image.
           * That happens because all modal images are shown like in a circle.
           * @private
           * @return {?}
           */

        }, {
          key: "getPrevImage",
          value: function getPrevImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);
            /** @type {?} */

            var newIndex = 0;

            if (currentIndex > 0 && currentIndex <= this.images.length - 1) {
              newIndex = currentIndex - 1;
            } else {
              newIndex = this.images.length - 1; // start from the last index
            }

            return this.images[newIndex];
          }
          /**
           * Private method to build a text description.
           * This is used also to create titles.
           * @private
           * @param {?} image
           * @param {?} imageWithoutDescription
           * @return {?} String description built concatenating image fields with a specific logic.
           */

        }, {
          key: "buildTextDescription",
          value: function buildTextDescription(image, imageWithoutDescription) {
            if (!this.configCurrentImage || !this.configCurrentImage.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            } // If customFullDescription use it, otherwise proceed to build a description


            if (this.configCurrentImage.description.customFullDescription && this.configCurrentImage.description.customFullDescription !== '') {
              return this.configCurrentImage.description.customFullDescription;
            }
            /** @type {?} */


            var currentIndex = getIndex(image, this.images); // If the current image hasn't a description,
            // prevent to write the ' - ' (or this.description.beforeTextDescription)

            /** @type {?} */

            var prevDescription = this.configCurrentImage.description.imageText ? this.configCurrentImage.description.imageText : '';
            /** @type {?} */

            var midSeparator = this.configCurrentImage.description.numberSeparator ? this.configCurrentImage.description.numberSeparator : '';
            /** @type {?} */

            var middleDescription = currentIndex + 1 + midSeparator + this.images.length;

            if (imageWithoutDescription) {
              return prevDescription + middleDescription;
            }
            /** @type {?} */


            var currImgDescription = image.modal && image.modal.description ? image.modal.description : '';
            /** @type {?} */

            var endDescription = this.configCurrentImage.description.beforeTextDescription + currImgDescription;
            return prevDescription + middleDescription + endDescription;
          }
          /**
           * Private method to call handleBoundaries when ngOnChanges is called.
           * @private
           * @return {?}
           */

        }, {
          key: "updateIndexes",
          value: function updateIndexes() {
            /** @type {?} */
            var index;

            try {
              index = getIndex(this.currentImage, this.images);
            } catch (err) {
              console.error('Cannot get the current image index in current-image');
              throw err;
            }

            if (this.isOpen) {
              this.handleBoundaries(index);
            }
          }
        }]);

        return CurrentImageComponent;
      }(AccessibleComponent);

      CurrentImageComponent.ɵfac = function CurrentImageComponent_Factory(t) {
        return new (t || CurrentImageComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef));
      };

      CurrentImageComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: CurrentImageComponent,
        selectors: [["ks-current-image"]],
        hostBindings: function CurrentImageComponent_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mouseenter", function CurrentImageComponent_mouseenter_HostBindingHandler() {
              return ctx.onMouseEnter();
            })("mouseleave", function CurrentImageComponent_mouseleave_HostBindingHandler() {
              return ctx.onMouseLeave();
            });
          }
        },
        inputs: {
          id: "id",
          currentImage: "currentImage",
          images: "images",
          isOpen: "isOpen",
          currentImageConfig: "currentImageConfig",
          slideConfig: "slideConfig",
          accessibilityConfig: "accessibilityConfig",
          keyboardConfig: "keyboardConfig"
        },
        outputs: {
          loadImage: "loadImage",
          changeImage: "changeImage",
          close: "close"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 13,
        vars: 33,
        consts: [["ksKeyboardNavigation", "", 1, "main-image-container", 3, "isOpen", "title", "keyPress"], [1, "left-sub-container"], ["role", "button", 3, "tabindex", "click", "keyup"], ["aria-hidden", "true", 3, "title"], [4, "ngIf"], ["id", "current-figure"], ["id", "current-image", "role", "img", 1, "inside", 3, "ngClass", "src", "title", "alt", "tabindex", "load", "click", "keyup", "swipeleft", "swiperight"], ["class", "inside description", "ksDescription", "", 3, "description", "innerHTML", 4, "ngIf"], [1, "right-sub-container"], ["class", "inside current-image-previous", "ksSize", "", "role", "img", 3, "src", "hidden", "sizeConfig", "title", "alt", "tabindex", "click", "keyup", 4, "ngIf", "ngIfElse"], ["firstImage", ""], ["ksSize", "", "role", "img", 1, "inside", "current-image-previous", 3, "src", "hidden", "sizeConfig", "title", "alt", "tabindex", "click", "keyup"], ["ksSize", "", 1, "current-image-previous", "hidden", 3, "sizeConfig"], ["ksDescription", "", 1, "inside", "description", 3, "description", "innerHTML"], ["class", "inside current-image-next", "ksSize", "", "role", "img", 3, "src", "hidden", "sizeConfig", "title", "alt", "tabindex", "click", "keyup", 4, "ngIf", "ngIfElse"], ["lastImage", ""], ["ksSize", "", "role", "img", 1, "inside", "current-image-next", 3, "src", "hidden", "sizeConfig", "title", "alt", "tabindex", "click", "keyup"], ["ksSize", "", 1, "current-image-next", "hidden", 3, "sizeConfig"], [3, "loadingConfig", "accessibilityConfig"]],
        template: function CurrentImageComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "main", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("keyPress", function CurrentImageComponent_Template_main_keyPress_0_listener($event) {
              return ctx.onKeyPress($event);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](1, "div", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](2, "a", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CurrentImageComponent_Template_a_click_2_listener($event) {
              return ctx.onNavigationEvent("left", $event, ctx.normalAction, ctx.isFirstImage);
            })("keyup", function CurrentImageComponent_Template_a_keyup_2_listener($event) {
              return ctx.onNavigationEvent("left", $event, ctx.normalAction, ctx.isFirstImage);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](3, "div", 3);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, CurrentImageComponent_ng_container_4_Template, 2, 1, "ng-container", 4);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](5, "figure", 5);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "img", 6);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("load", function CurrentImageComponent_Template_img_load_6_listener($event) {
              return ctx.onImageLoad($event);
            })("click", function CurrentImageComponent_Template_img_click_6_listener($event) {
              return ctx.onImageEvent($event, ctx.clickAction);
            })("keyup", function CurrentImageComponent_Template_img_keyup_6_listener($event) {
              return ctx.onImageEvent($event, ctx.keyboardAction);
            })("swipeleft", function CurrentImageComponent_Template_img_swipeleft_6_listener($event) {
              return ctx.swipe($event.type);
            })("swiperight", function CurrentImageComponent_Template_img_swiperight_6_listener($event) {
              return ctx.swipe($event.type);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](7, CurrentImageComponent_figcaption_7_Template, 1, 2, "figcaption", 7);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](8, "div", 8);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](9, CurrentImageComponent_ng_container_9_Template, 2, 1, "ng-container", 4);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](10, CurrentImageComponent_ng_container_10_Template, 2, 2, "ng-container", 4);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](11, "a", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("click", function CurrentImageComponent_Template_a_click_11_listener($event) {
              return ctx.onNavigationEvent("right", $event, ctx.normalAction, ctx.isLastImage);
            })("keyup", function CurrentImageComponent_Template_a_keyup_11_listener($event) {
              return ctx.onNavigationEvent("right", $event, ctx.normalAction, ctx.isLastImage);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](12, "div", 3);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("isOpen", ctx.isOpen)("title", ctx.accessibilityConfig.mainContainerTitle);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig.mainContainerAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("nav-left ", ctx.isFirstImage ? "no-pointer" : "", "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx.isFirstImage ? -1 : 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig.mainPrevImageAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx.isFirstImage ? "empty-arrow-image" : "left-arrow-image", "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.isFirstImage ? "" : ctx.accessibilityConfig.mainPrevImageTitle);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.configSlide == null ? null : ctx.configSlide.sidePreviews == null ? null : ctx.configSlide.sidePreviews.show);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("display", ctx.loading ? "none" : "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpropertyInterpolate"]("alt", ctx.currentImage.modal.alt ? ctx.currentImage.modal.alt : ctx.getAltDescriptionByImage());

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngClass", "rotate" + (ctx.currentImage.modal && ctx.currentImage.modal.angle ? ctx.currentImage.modal.angle : "0"))("src", ctx.currentImage.modal.img, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsanitizeUrl"])("title", ctx.currentImage.modal.title ? ctx.currentImage.modal.title : ctx.getTitleToDisplay())("tabindex", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.currentImage.modal.ariaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.getDescriptionToDisplay() !== "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.slideConfig == null ? null : ctx.slideConfig.sidePreviews == null ? null : ctx.slideConfig.sidePreviews.show);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.loading && (ctx.configCurrentImage == null ? null : ctx.configCurrentImage.loadingConfig == null ? null : ctx.configCurrentImage.loadingConfig.enable));

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("nav-right ", ctx.isFirstImage ? "no-pointer" : "", "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("tabindex", ctx.isLastImage ? -1 : 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig.mainNextImageAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵclassMapInterpolate1"]("inside ", ctx.isLastImage ? "empty-arrow-image" : "right-arrow-image", "");

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.isLastImage ? "" : ctx.accessibilityConfig.mainNextImageTitle);
          }
        },
        directives: function directives() {
          return [KeyboardNavigationDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgClass, SizeDirective, DescriptionDirective, LoadingSpinnerComponent];
        },
        styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;justify-content:center}.main-image-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.main-image-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%], .main-image-container[_ngcontent-%COMP%] > .left-sub-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%], .main-image-container[_ngcontent-%COMP%] > .right-sub-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{-webkit-animation:1s animatezoom;animation:1s animatezoom;cursor:pointer;transition:.5s}.main-image-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%]:hover, .main-image-container[_ngcontent-%COMP%] > .left-sub-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]:hover, .main-image-container[_ngcontent-%COMP%] > .right-sub-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]:hover{transform:scale(1.1)}.main-image-container[_ngcontent-%COMP%] > .left-sub-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:space-around;align-items:center}.main-image-container[_ngcontent-%COMP%] > .left-sub-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]{margin-right:5px;margin-left:15px}.main-image-container[_ngcontent-%COMP%] > .left-sub-container[_ngcontent-%COMP%] > .nav-left.no-pointer[_ngcontent-%COMP%]{cursor:default!important}.main-image-container[_ngcontent-%COMP%] > .right-sub-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:space-around;align-items:center}.main-image-container[_ngcontent-%COMP%] > .right-sub-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{margin-right:15px;margin-left:5px}.main-image-container[_ngcontent-%COMP%] > .right-sub-container[_ngcontent-%COMP%] > .nav-right.no-pointer[_ngcontent-%COMP%]{cursor:default!important}.main-image-container[_ngcontent-%COMP%]   #current-figure[_ngcontent-%COMP%]{-webkit-animation:.8s fadein-visible;animation:.8s fadein-visible;text-align:center;margin:0;position:relative}.main-image-container[_ngcontent-%COMP%]   #current-figure[_ngcontent-%COMP%] > #current-image[_ngcontent-%COMP%]{max-width:100%;height:auto;display:block}.main-image-container[_ngcontent-%COMP%]   #current-figure[_ngcontent-%COMP%]   figcaption[_ngcontent-%COMP%]{padding:10px;position:absolute;bottom:0;left:0;right:0}.main-image-container[_ngcontent-%COMP%]   #current-figure[_ngcontent-%COMP%]   figcaption[_ngcontent-%COMP%]   .description[_ngcontent-%COMP%]{font-weight:700;text-align:center}#current-image[_ngcontent-%COMP%]{height:auto;max-width:80vw;max-height:60vh;cursor:pointer}@media screen and (min-width:70vw){#current-image[_ngcontent-%COMP%]{max-width:70vw}}@-webkit-keyframes fadein-visible{from{opacity:0}to{opacity:1}}@keyframes fadein-visible{from{opacity:0}to{opacity:1}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}", _c7, "@media only screen and (max-width:1024px),only screen and (max-device-width:1024px){.current-image-next[_ngcontent-%COMP%], .current-image-previous[_ngcontent-%COMP%]{display:none}}@media only screen and (min-device-width:1025px){.current-image-next[_ngcontent-%COMP%], .current-image-preview[_ngcontent-%COMP%], .current-image-previous[_ngcontent-%COMP%]{height:auto;cursor:pointer;opacity:.5;-webkit-animation:.8s fadein-semi-visible05;animation:.8s fadein-semi-visible05}.current-image-next[_ngcontent-%COMP%]:hover, .current-image-preview[_ngcontent-%COMP%]:hover, .current-image-previous[_ngcontent-%COMP%]:hover{opacity:1;transition:.5s}.current-image-previous[_ngcontent-%COMP%]{margin-left:10px;margin-right:5px}.current-image-next[_ngcontent-%COMP%]{margin-right:10px;margin-left:5px}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}"],
        changeDetection: 0
      });
      /** @nocollapse */

      CurrentImageComponent.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }];
      };

      CurrentImageComponent.propDecorators = {
        id: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        currentImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        isOpen: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        currentImageConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        slideConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        keyboardConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        loadImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        changeImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        close: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        onMouseEnter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['mouseenter']
        }],
        onMouseLeave: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['mouseleave']
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CurrentImageComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-current-image',
            template: "<main class=\"main-image-container\"\n      ksKeyboardNavigation [isOpen]=\"isOpen\" (keyPress)=\"onKeyPress($event)\"\n      [attr.aria-label]=\"accessibilityConfig.mainContainerAriaLabel\"\n      [title]=\"accessibilityConfig.mainContainerTitle\">\n\n  <div class=\"left-sub-container\">\n    <a class=\"nav-left {{isFirstImage ? 'no-pointer' : ''}}\"\n       [attr.aria-label]=\"accessibilityConfig.mainPrevImageAriaLabel\"\n       [tabindex]=\"isFirstImage ? -1 : 0\" role=\"button\"\n       (click)=\"onNavigationEvent('left', $event, normalAction, isFirstImage)\" (keyup)=\"onNavigationEvent('left', $event, normalAction, isFirstImage)\">\n      <div class=\"inside {{isFirstImage ? 'empty-arrow-image' : 'left-arrow-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"isFirstImage ? '' : accessibilityConfig.mainPrevImageTitle\"></div>\n    </a>\n\n    <ng-container *ngIf=\"configSlide?.sidePreviews?.show\">\n      <ng-container *ngIf=\"getLeftPreviewImage() as leftPreview\">\n        <img *ngIf=\"!isFirstImage; else firstImage\"\n             class=\"inside current-image-previous\"\n             [src]=\"leftPreview.plain?.img ? leftPreview.plain.img : leftPreview.modal.img\"\n             [hidden]=\"loading\"\n             ksSize [sizeConfig]=\"{width: configSlide.sidePreviews?.size.width, height: configSlide.sidePreviews?.size.height}\"\n             [attr.aria-label]=\"leftPreview.modal.ariaLabel\"\n             [title]=\"leftPreview.modal.title ? leftPreview.modal.title : getDescriptionToDisplay(leftPreview)\"\n             alt=\"{{leftPreview.modal.alt ? leftPreview.modal.alt : getAltDescriptionByImage(leftPreview)}}\"\n             [tabindex]=\"0\" role=\"img\"\n             (click)=\"onNavigationEvent('left', $event, clickAction)\" (keyup)=\"onNavigationEvent('left', $event, keyboardAction)\"/>\n        <ng-template #firstImage>\n          <div class=\"current-image-previous hidden\"\n               ksSize [sizeConfig]=\"{width: configSlide.sidePreviews?.size.width, height: configSlide.sidePreviews?.size.height}\"></div>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n  </div>\n\n\n  <figure id=\"current-figure\" [style.display]=\"loading ? 'none' : ''\">\n    <img id=\"current-image\"\n         class=\"inside\"\n         [ngClass]=\"'rotate' + (currentImage.modal && currentImage.modal.angle ? currentImage.modal.angle : '0')\"\n         [src]=\"currentImage.modal.img\"\n         [attr.aria-label]=\"currentImage.modal.ariaLabel\"\n         [title]=\"currentImage.modal.title ? currentImage.modal.title : getTitleToDisplay()\"\n         alt=\"{{currentImage.modal.alt ? currentImage.modal.alt : getAltDescriptionByImage()}}\"\n         [tabindex]=\"0\" role=\"img\"\n         (load)=\"onImageLoad($event)\"\n         (click)=\"onImageEvent($event, clickAction)\" (keyup)=\"onImageEvent($event, keyboardAction)\"\n         (swipeleft)=\"swipe($event.type)\"\n         (swiperight)=\"swipe($event.type)\"/>\n    <figcaption *ngIf=\"getDescriptionToDisplay() !== ''\"\n                class=\"inside description\"\n                ksDescription [description]=\"configCurrentImage?.description\"\n                [innerHTML]=\"getDescriptionToDisplay()\">\n    </figcaption>\n  </figure>\n\n  <div class=\"right-sub-container\">\n    <ng-container *ngIf=\"slideConfig?.sidePreviews?.show\">\n      <ng-container *ngIf=\"getRightPreviewImage() as rightPreview\">\n        <img *ngIf=\"!isLastImage; else lastImage\"\n             class=\"inside current-image-next\"\n             [src]=\"rightPreview.plain?.img ? rightPreview.plain.img : rightPreview.modal.img\"\n             [hidden]=\"loading\"\n             ksSize [sizeConfig]=\"{width: slideConfig.sidePreviews?.size.width, height: slideConfig.sidePreviews?.size.height}\"\n             [attr.aria-label]=\"rightPreview.modal.ariaLabel\"\n             [title]=\"rightPreview.modal.title ? rightPreview.modal.title : getDescriptionToDisplay(rightPreview)\"\n             alt=\"{{rightPreview.modal.alt ? rightPreview.modal.alt : getAltDescriptionByImage(rightPreview)}}\"\n             [tabindex]=\"0\" role=\"img\"\n             (click)=\"onNavigationEvent('right', $event, clickAction)\" (keyup)=\"onNavigationEvent('right', $event, keyboardAction)\"/>\n        <ng-template #lastImage>\n          <div class=\"current-image-next hidden\"\n               ksSize [sizeConfig]=\"{width: slideConfig.sidePreviews?.size.width, height: slideConfig.sidePreviews?.size.height}\">\n          </div>\n        </ng-template>\n      </ng-container>\n    </ng-container>\n\n    <ng-container *ngIf=\"loading && configCurrentImage?.loadingConfig?.enable\">\n      <ks-loading-spinner [loadingConfig]=\"configCurrentImage?.loadingConfig\"\n                          [accessibilityConfig]=\"accessibilityConfig\"></ks-loading-spinner>\n    </ng-container>\n\n    <a class=\"nav-right {{isFirstImage ? 'no-pointer' : ''}}\"\n       [attr.aria-label]=\"accessibilityConfig.mainNextImageAriaLabel\"\n       [tabindex]=\"isLastImage ? -1 : 0\" role=\"button\"\n       (click)=\"onNavigationEvent('right', $event, normalAction, isLastImage)\" (keyup)=\"onNavigationEvent('right', $event, normalAction, isLastImage)\">\n      <div class=\"inside {{isLastImage ? 'empty-arrow-image' : 'right-arrow-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"isLastImage ? '' : accessibilityConfig.mainNextImageTitle\"></div>\n    </a>\n  </div>\n</main>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [":host{display:flex;flex-direction:column;justify-content:center}.main-image-container{display:flex;flex-direction:row;align-items:center;justify-content:space-between}.main-image-container .nav,.main-image-container>.left-sub-container>.nav-left,.main-image-container>.right-sub-container>.nav-right{-webkit-animation:1s animatezoom;animation:1s animatezoom;cursor:pointer;transition:.5s}.main-image-container .nav:hover,.main-image-container>.left-sub-container>.nav-left:hover,.main-image-container>.right-sub-container>.nav-right:hover{transform:scale(1.1)}.main-image-container>.left-sub-container{display:flex;flex-direction:row;justify-content:space-around;align-items:center}.main-image-container>.left-sub-container>.nav-left{margin-right:5px;margin-left:15px}.main-image-container>.left-sub-container>.nav-left.no-pointer{cursor:default!important}.main-image-container>.right-sub-container{display:flex;flex-direction:row;justify-content:space-around;align-items:center}.main-image-container>.right-sub-container>.nav-right{margin-right:15px;margin-left:5px}.main-image-container>.right-sub-container>.nav-right.no-pointer{cursor:default!important}.main-image-container #current-figure{-webkit-animation:.8s fadein-visible;animation:.8s fadein-visible;text-align:center;margin:0;position:relative}.main-image-container #current-figure>#current-image{max-width:100%;height:auto;display:block}.main-image-container #current-figure figcaption{padding:10px;position:absolute;bottom:0;left:0;right:0}.main-image-container #current-figure figcaption .description{font-weight:700;text-align:center}#current-image{height:auto;max-width:80vw;max-height:60vh;cursor:pointer}@media screen and (min-width:70vw){#current-image{max-width:70vw}}@-webkit-keyframes fadein-visible{from{opacity:0}to{opacity:1}}@keyframes fadein-visible{from{opacity:0}to{opacity:1}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}", ".arrow-image,.empty-arrow-image,.left-arrow-image,.right-arrow-image{width:30px;height:30px;background-size:30px}.empty-arrow-image{background:#000;opacity:0}.left-arrow-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.left-arrow-image:hover{transform:scale(1.2)}.right-arrow-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.right-arrow-image:hover{transform:scale(1.2)}", "@media only screen and (max-width:1024px),only screen and (max-device-width:1024px){.current-image-next,.current-image-previous{display:none}}@media only screen and (min-device-width:1025px){.current-image-next,.current-image-preview,.current-image-previous{height:auto;cursor:pointer;opacity:.5;-webkit-animation:.8s fadein-semi-visible05;animation:.8s fadein-semi-visible05}.current-image-next:hover,.current-image-preview:hover,.current-image-previous:hover{opacity:1;transition:.5s}.current-image-previous{margin-left:10px;margin-right:5px}.current-image-next{margin-right:10px;margin-left:5px}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}"]
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
            }]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }];
        }, {
          loadImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          changeImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          close: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],

          /**
           * Listener to stop the gallery when the mouse pointer is over the current image.
           * @return {?}
           */
          onMouseEnter: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['mouseenter']
          }],

          /**
           * Listener to play the gallery when the mouse pointer leave the current image.
           * @return {?}
           */
          onMouseLeave: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['mouseleave']
          }],
          id: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          currentImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          isOpen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          currentImageConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          slideConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          keyboardConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Class `LineLayout` to configure a linear plain gallery.
       */


      var _LineLayout =
      /**
       * @param {?} size
       * @param {?} breakConfig
       * @param {?} justify
       */
      function _LineLayout(size, breakConfig, justify) {
        _classCallCheck(this, _LineLayout);

        this.size = size;
        this.breakConfig = breakConfig;
        this.justify = justify;
      };
      /**
       * Class `GridLayout` to configure a grid plain gallery.
       */


      var _GridLayout =
      /**
       * @param {?} size
       * @param {?} breakConfig
       */
      function _GridLayout(size, breakConfig) {
        _classCallCheck(this, _GridLayout);

        this.size = size;
        this.breakConfig = breakConfig;
      };
      /**
       * Class `AdvancedLayout` to configure a fully custom plain gallery.
       */


      var _AdvancedLayout =
      /**
       * @param {?} modalOpenerByIndex
       * @param {?} hideDefaultPlainGallery
       */
      function _AdvancedLayout(modalOpenerByIndex, hideDefaultPlainGallery) {
        _classCallCheck(this, _AdvancedLayout);

        this.modalOpenerByIndex = modalOpenerByIndex;
        this.hideDefaultPlainGallery = hideDefaultPlainGallery;
      };
      /** @enum {number} */


      var _PlainGalleryStrategy = {
        // don't use 0 here
        // the first index is 1 and all of the following members are auto-incremented from that point on
        ROW: 1,
        COLUMN: 2,
        GRID: 3,
        CUSTOM: 4 // full custom strategy

      };
      _PlainGalleryStrategy[_PlainGalleryStrategy.ROW] = 'ROW';
      _PlainGalleryStrategy[_PlainGalleryStrategy.COLUMN] = 'COLUMN';
      _PlainGalleryStrategy[_PlainGalleryStrategy.GRID] = 'GRID';
      _PlainGalleryStrategy[_PlainGalleryStrategy.CUSTOM] = 'CUSTOM';
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Default accessibility configuration.
       * @type {?}
       */

      var _KS_DEFAULT_ACCESSIBILITY_CONFIG = {
        backgroundAriaLabel: 'Modal gallery full screen background',
        backgroundTitle: '',
        plainGalleryContentAriaLabel: 'Plain gallery content',
        plainGalleryContentTitle: '',
        modalGalleryContentAriaLabel: 'Modal gallery content',
        modalGalleryContentTitle: '',
        loadingSpinnerAriaLabel: 'The current image is loading. Please be patient.',
        loadingSpinnerTitle: 'The current image is loading. Please be patient.',
        mainContainerAriaLabel: 'Current image and navigation',
        mainContainerTitle: '',
        mainPrevImageAriaLabel: 'Previous image',
        mainPrevImageTitle: 'Previous image',
        mainNextImageAriaLabel: 'Next image',
        mainNextImageTitle: 'Next image',
        dotsContainerAriaLabel: 'Image navigation dots',
        dotsContainerTitle: '',
        dotAriaLabel: 'Navigate to image number',
        previewsContainerAriaLabel: 'Image previews',
        previewsContainerTitle: '',
        previewScrollPrevAriaLabel: 'Scroll previous previews',
        previewScrollPrevTitle: 'Scroll previous previews',
        previewScrollNextAriaLabel: 'Scroll next previews',
        previewScrollNextTitle: 'Scroll next previews',
        carouselContainerAriaLabel: 'Current image and navigation',
        carouselContainerTitle: '',
        carouselPrevImageAriaLabel: 'Previous image',
        carouselPrevImageTitle: 'Previous image',
        carouselNextImageAriaLabel: 'Next image',
        carouselNextImageTitle: 'Next image',
        carouselPreviewsContainerAriaLabel: 'Image previews',
        carouselPreviewsContainerTitle: '',
        carouselPreviewScrollPrevAriaLabel: 'Scroll previous previews',
        carouselPreviewScrollPrevTitle: 'Scroll previous previews',
        carouselPreviewScrollNextAriaLabel: 'Scroll next previews',
        carouselPreviewScrollNextTitle: 'Scroll next previews'
      };
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Service to check if the provided id is unique
       */

      var IdValidatorService = /*#__PURE__*/function () {
        function IdValidatorService() {
          _classCallCheck(this, IdValidatorService);

          this.ids = new Map();
        }
        /**
         * Method to check and reserve an id for the current instance of the library.
         * In this way, no other instances can use the same id.
         * @throws a error with a message if galleryId is neither unique, < 0 or an integer
         * @param {?} galleryId number or undefined that represents the unique id of the gallery.
         * @return {?} boolean true if success. false is never returned, instead an exception is thrown
         */


        _createClass(IdValidatorService, [{
          key: "checkAndAdd",
          value: function checkAndAdd(galleryId) {
            if (!Number.isInteger(galleryId) || galleryId < 0) {
              throw new Error('You must provide a valid [id]="unique integer > 0 here" to the gallery/carousel in your template');
            }

            if (this.ids.get(galleryId)) {
              throw new Error("Cannot create gallery with id=".concat(galleryId, " because already used in your application. This must be a unique integer >= 0"));
            }

            this.ids.set(galleryId, galleryId);
            return true;
          }
          /**
           * Method to remove a reserved id. In this way you are able to use the id again for another instance of the library.
           * @throws a error with a message if galleryId is neither integer or < 0
           * @param {?} galleryId number or undefined that represents the unique id of the gallery.
           * @return {?} boolean true if success. false is never returned, instead an exception is thrown
           */

        }, {
          key: "remove",
          value: function remove(galleryId) {
            if (!Number.isInteger(galleryId) || galleryId < 0) {
              throw new Error('You must provide a valid [id]="unique integer > 0 here" to the gallery/carousel in your template');
            } // if (this.ids.find(id => id === galleryId)) {
            //   throw new Error(`Cannot create gallery with id=${galleryId} because already used in your application. This must be a unique number >= 0.`);
            // }


            this.ids["delete"](galleryId);
            return true;
          }
        }]);

        return IdValidatorService;
      }();

      IdValidatorService.ɵfac = function IdValidatorService_Factory(t) {
        return new (t || IdValidatorService)();
      };

      IdValidatorService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: IdValidatorService,
        factory: IdValidatorService.ɵfac,
        providedIn: 'root'
      });
      /** @nocollapse */

      IdValidatorService.ngInjectableDef = (0, _angular_core__WEBPACK_IMPORTED_MODULE_0__.defineInjectable)({
        factory: function IdValidatorService_Factory() {
          return new IdValidatorService();
        },
        token: IdValidatorService,
        providedIn: "root"
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](IdValidatorService, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable,
          args: [{
            providedIn: 'root'
          }]
        }], function () {
          return [];
        }, null);
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Main Component of this library with both the plain and modal galleries.
       */


      var ModalGalleryComponent = /*#__PURE__*/function () {
        /**
         * Constructor with the injection of ´KeyboardService´, an object to support Server-Side Rendering and other useful services.
         * @param {?} keyboardService
         * @param {?} galleryService
         * @param {?} platformId
         * @param {?} changeDetectorRef
         * @param {?} idValidatorService
         */
        function ModalGalleryComponent(keyboardService, galleryService, platformId, changeDetectorRef, idValidatorService) {
          _classCallCheck(this, ModalGalleryComponent);

          this.keyboardService = keyboardService;
          this.galleryService = galleryService;
          this.platformId = platformId;
          this.changeDetectorRef = changeDetectorRef;
          this.idValidatorService = idValidatorService;
          /**
           * Boolean to enable modal-gallery close behaviour when clicking
           * on the semi-transparent background. Enabled by default.
           */

          this.enableCloseOutside = true;
          /**
           * Object of type `AccessibilityConfig` to init custom accessibility features.
           * For instance, it contains titles, alt texts, aria-labels and so on.
           */

          this.accessibilityConfig = _KS_DEFAULT_ACCESSIBILITY_CONFIG;
          /**
           * Output to emit an event when the modal gallery is closed.
           */

          this.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when an image is changed.
           */

          this.show = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the current image is the first one.
           */

          this.firstImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the current image is the last one.
           */

          this.lastImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the modal gallery is closed.
           */

          this.hasData = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when a button is clicked, but before that the action is triggered.
           */

          this.buttonBeforeHook = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when a button is clicked, but after that the action is triggered.
           */

          this.buttonAfterHook = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when someone clicks either an arrow of modal gallery or also in previews.
           */

          this.arrow = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Boolean that it is true if the modal gallery is visible. False by default.
           */

          this.opened = false;
          /**
           * Boolean to open the modal gallery. False by default.
           */

          this.showGallery = false;
        }
        /**
         * HostListener to catch browser's back button and destroy the gallery.
         * This prevents weired behaviour about scrolling.
         * Added to fix this issue: https://github.com/Ks89/angular-modal-gallery/issues/159
         * @param {?} e
         * @return {?}
         */


        _createClass(ModalGalleryComponent, [{
          key: "onPopState",
          value: function onPopState(e) {
            this.closeGallery();
          }
          /**
           * Method ´ngOnChanges´ to re-init images if input is changed.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called before `ngOnInit()` and whenever one or more data-bound input properties change.
           * @param {?} changes `SimpleChanges` object of current and previous property values provided by Angular.
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            /** @type {?} */
            var imagesChange = changes.modalImages;
            /** @type {?} */

            var plainGalleryConfigChange = changes.plainGalleryConfig;

            if (imagesChange && !imagesChange.firstChange && imagesChange.previousValue !== imagesChange.currentValue) {
              this.initImages();
            }

            if (plainGalleryConfigChange) {
              // const prevPlainGalleryConfigChange: any = plainGalleryConfigChange.previousValue;

              /** @type {?} */
              var currPlainGalleryConfigChange = plainGalleryConfigChange.currentValue;

              if (currPlainGalleryConfigChange.layout && currPlainGalleryConfigChange.layout instanceof _AdvancedLayout && currPlainGalleryConfigChange.layout.modalOpenerByIndex !== -1) {
                // console.log('opening modal gallery from custom plain gallery, index: ', currPlainGalleryConfigChange);
                this.showModalGallery(currPlainGalleryConfigChange.layout.modalOpenerByIndex);
              }
            }
          }
          /**
           * Method ´ngOnInit´ to init images calling `initImages()`.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called only one time!!!
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            var _this6 = this;

            this.idValidatorService.checkAndAdd(this.id); // id is a mandatory input and must a number > 0

            if (!this.id && this.id !== 0 || this.id < 0) {
              throw new Error("'[id]=\"a number >= 0\"' is a mandatory input from 6.0.0 in angular-modal-gallery." + "If you are using multiple instances of this library, please be sure to use different ids");
            } // call initImages to init images and to emit `hasData` event


            this.initImages();
            /** @type {?} */

            var defaultSlideConfig = {
              infinite: false,
              playConfig: {
                autoPlay: false,
                interval: 5000,
                pauseOnHover: true
              },
              sidePreviews: {
                show: true,
                size: {
                  width: '100px',
                  height: 'auto'
                }
              }
            };
            this.configSlide = Object.assign({}, defaultSlideConfig, this.slideConfig);
            this.galleryServiceNavigateSubscription = this.galleryService.navigate.subscribe(
            /**
            * @param {?} payload
            * @return {?}
            */
            function (payload) {
              if (!payload) {
                return;
              } // if galleryId is not valid OR galleryId is related to another instance and not this one


              if (payload.galleryId === undefined || payload.galleryId < 0 || payload.galleryId !== _this6.id) {
                return;
              } // if image index is not valid


              if (payload.index < 0 || payload.index > _this6.images.length) {
                return;
              }

              _this6.showModalGallery(payload.index, true);
            });
            this.galleryServiceCloseSubscription = this.galleryService.close.subscribe(
            /**
            * @param {?} galleryId
            * @return {?}
            */
            function (galleryId) {
              if (galleryId < 0 || _this6.id !== galleryId) {
                return;
              }

              _this6.closeGallery(_Action.NORMAL, true);
            });
            this.galleryServiceUpdateSubscription = this.galleryService.update.subscribe(
            /**
            * @param {?} payload
            * @return {?}
            */
            function (payload) {
              if (!payload) {
                return;
              } // if galleryId is not valid OR galleryId is related to another instance and not this one


              if (payload.galleryId === undefined || payload.galleryId < 0 || payload.galleryId !== _this6.id) {
                return;
              } // if either image index or image are not valid


              if (payload.index < 0 || payload.index > _this6.images.length || !payload.image) {
                return;
              }
              /** @type {?} */


              var currentIndex = getIndex(payload.image, _this6.images);
              _this6.images = _this6.images.map(
              /**
              * @param {?} image
              * @param {?} index
              * @return {?}
              */
              function (image, index) {
                if (image.id === payload.index) {
                  return payload.image;
                }

                return image;
              });

              if (currentIndex === payload.index) {
                _this6.currentImage = _this6.images[payload.index];
              }

              _this6.changeDetectorRef.markForCheck();
            });
            this.galleryServiceAutoPlaySubscription = this.galleryService.autoPlay.subscribe(
            /**
            * @param {?} payload
            * @return {?}
            */
            function (payload) {
              // if galleryId is not valid OR galleryId is related to another instance and not this one
              if (payload.galleryId === undefined || payload.galleryId < 0 || payload.galleryId !== _this6.id) {
                return;
              }

              _this6.configSlide.playConfig.autoPlay = payload.result;
            });
          }
          /**
           * Method called by custom upper buttons.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onCustomEmit",
          value: function onCustomEmit(event) {
            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit); // console.log('on onCustomEmit', eventToEmit);

            this.buttonAfterHook.emit(eventToEmit);
          } // TODO implement on refresh
          // /**
          //  * Method called by the refresh upper button.
          //  * STILL NOT IMPLEMENTED, SO DON'T USE IT
          //  * @param ButtonEvent event payload
          //  */
          // onRefresh(event: ButtonEvent) {
          //   const eventToEmit: ButtonEvent = this.getButtonEventToEmit(event);
          //
          //   this.buttonBeforeHook.emit(eventToEmit);
          //   // console.log('TODO implement on refresh inside the library', eventToEmit);
          //
          //   this.currentImage = Object.assign({}, this.currentImage, { previouslyLoaded: false });
          //
          //   // TODO add logic to hide and show the current image
          //
          //   // console.log('onRefresh', this.currentImage);
          //
          //   // const indexNum: number = this.currentImageComponent.getIndex();
          //
          //   // this.images = this.images.map((val: InternalLibImage, index: number) => {
          //   //   if (index !== 2) {
          //   //     return val;
          //   //   } else {
          //   //     const img: InternalLibImage = Object.assign({}, val, {previouslyLoaded: false});
          //   //     return img;
          //   //   }
          //   // });
          //   //
          //   // this.closeGallery();
          //   // this.showModalGallery(2);
          //
          //   this.buttonAfterHook.emit(eventToEmit);
          // }
          // /**
          //  * Method called by the rotate upper button.
          //  * @param ButtonEvent event payload
          //  */
          // onRotate(event: ButtonEvent) {
          //   const eventToEmit: ButtonEvent = this.getButtonEventToEmit(event);
          //   this.buttonBeforeHook.emit(eventToEmit);
          //
          //   // TODO implement rotation logic
          //
          //   this.buttonAfterHook.emit(eventToEmit);
          // }

          /**
           * Method called by the full-screen upper button.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onFullScreen",
          value: function onFullScreen(event) {
            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit);
            /** @type {?} */

            var doc = document;
            /** @type {?} */

            var docEl = document.documentElement;
            /** @type {?} */

            var fullscreenDisabled = !doc.fullscreenElement && !doc.webkitFullscreenElement && !doc.mozFullScreenElement && !doc.msFullscreenElement;

            if (fullscreenDisabled) {
              if (docEl.requestFullscreen) {
                docEl.requestFullscreen();
              } else if (docEl.webkitRequestFullscreen) {
                docEl.webkitRequestFullscreen();
              } else if (docEl.mozRequestFullScreen) {
                docEl.mozRequestFullScreen();
              } else if (docEl.msRequestFullscreen) {
                docEl.msRequestFullscreen();
              }
            } else {
              if (doc.exitFullscreen) {
                doc.exitFullscreen();
              } else if (doc.msExitFullscreen) {
                doc.msExitFullscreen();
              } else if (doc.mozCancelFullScreen) {
                doc.mozCancelFullScreen();
              } else if (doc.webkitExitFullscreen) {
                doc.webkitExitFullscreen();
              }
            }

            this.buttonAfterHook.emit(eventToEmit);
          }
          /**
           * Method called by the delete upper button.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onDelete",
          value: function onDelete(event) {
            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit);

            if (this.images.length === 1) {
              this.closeGallery();
            }
            /** @type {?} */


            var imageIndexToDelete = this.currentImageComponent.getIndexToDelete(event.image);

            if (imageIndexToDelete === this.images.length - 1) {
              // last image
              this.currentImageComponent.prevImage();
            } else {
              this.currentImageComponent.nextImage();
            }

            this.buttonAfterHook.emit(eventToEmit);
          }
          /**
           * Method called by the navigate upper button.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onNavigate",
          value: function onNavigate(event) {
            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit); // To support SSR

            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this.platformId)) {
              if (eventToEmit.image && eventToEmit.image.modal.extUrl) {
                // where I should open this link? The current tab or another one?
                if (eventToEmit.button && eventToEmit.button.extUrlInNewTab) {
                  // in this case I should use target _blank to open the url in a new tab, however these is a security issue.
                  // Prevent Reverse Tabnabbing's attacks (https://www.owasp.org/index.php/Reverse_Tabnabbing)
                  // Some resources:
                  // - https://www.owasp.org/index.php/HTML5_Security_Cheat_Sheet#Tabnabbing
                  // - https://medium.com/@jitbit/target-blank-the-most-underestimated-vulnerability-ever-96e328301f4c
                  // - https://developer.mozilla.org/en-US/docs/Web/API/Window/open

                  /** @type {?} */
                  var newWindow = window.open(eventToEmit.image.modal.extUrl, 'noopener,noreferrer,');
                  newWindow.opener = null; // required to prevent security issues
                } else {
                  window.location.href = eventToEmit.image.modal.extUrl;
                }
              }
            }

            this.buttonAfterHook.emit(eventToEmit);
          }
          /**
           * Method called by the download upper button.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onDownload",
          value: function onDownload(event) {
            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit);
            this.downloadImage();
            this.buttonAfterHook.emit(eventToEmit);
          }
          /**
           * Method called by the close upper button.
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onCloseGallery",
          value: function onCloseGallery(event) {
            var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _Action.NORMAL;

            /** @type {?} */
            var eventToEmit = this.getButtonEventToEmit(event);
            this.buttonBeforeHook.emit(eventToEmit);
            this.closeGallery(action);
            this.buttonAfterHook.emit(eventToEmit);
          }
          /**
           * Method to close the modal gallery specifying the action.
           * It also reset the `keyboardService` to prevent multiple listeners.
           * @param {?=} action
           * @param {?=} isCalledByService
           * @return {?}
           */

        }, {
          key: "closeGallery",
          value: function closeGallery() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Action.NORMAL;
            var isCalledByService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            this.close.emit(new _ImageModalEvent(action, true));
            this.opened = false;
            this.keyboardService.reset(); // shows scrollbar

            document.body.style.overflow = 'visible';

            if (isCalledByService) {
              // the following is required, otherwise the view will not be updated
              // this happens only if called by gallery.service
              this.changeDetectorRef.markForCheck();
            }
          }
          /**
           * Method called when you click on an image of your plain (or inline) gallery.
           * @param {?} index
           * @return {?}
           */

        }, {
          key: "onShowModalGallery",
          value: function onShowModalGallery(index) {
            this.showModalGallery(index);
          }
          /**
           * Method to show the modal gallery displaying the image with
           * the index specified as input parameter.
           * It will also register a new `keyboardService` to catch keyboard's events to download the current
           * image with keyboard's shortcuts. This service, will be removed either when modal gallery component
           * will be destroyed or when the gallery is closed invoking the `closeGallery` method.
           * @param {?} index
           * @param {?=} isCalledByService
           * @return {?}
           */

        }, {
          key: "showModalGallery",
          value: function showModalGallery(index) {
            var _this7 = this;

            var isCalledByService = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            // hides scrollbar
            document.body.style.overflow = 'hidden';
            this.keyboardService.add(
            /**
            * @param {?} event
            * @param {?} combo
            * @return {?}
            */
            function (event, combo) {
              if (event.preventDefault) {
                event.preventDefault();
              } else {
                // internet explorer
                event.returnValue = false;
              }

              _this7.downloadImage();
            });
            this.opened = true;
            this.currentImage = this.images[index]; // emit a new ImageModalEvent with the index of the current image

            this.show.emit(new _ImageModalEvent(_Action.LOAD, index + 1));

            if (isCalledByService) {
              // the following is required, otherwise the view will not be updated
              // this happens only if called by gallery.service
              this.changeDetectorRef.markForCheck();
            }
          }
          /**
           * Method called when the image changes and used to update the `currentImage` object.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onChangeCurrentImage",
          value: function onChangeCurrentImage(event) {
            /** @type {?} */
            var newIndex = event.result;

            if (newIndex < 0 || newIndex >= this.images.length) {
              return;
            }

            this.currentImage = this.images[newIndex]; // emit first/last event based on newIndex value

            this.emitBoundaryEvent(event.action, newIndex); // emit current visible image index

            this.show.emit(new _ImageModalEvent(event.action, newIndex + 1));
          }
          /**
           * @return {?}
           */

        }, {
          key: "isPlainGalleryVisible",
          value: function isPlainGalleryVisible() {
            if (this.plainGalleryConfig && this.plainGalleryConfig.layout && this.plainGalleryConfig.layout instanceof _AdvancedLayout) {
              return !this.plainGalleryConfig.layout.hideDefaultPlainGallery;
            }

            return true;
          }
          /**
           * Method called when you click 'outside' (i.e. on the semi-transparent background)
           * to close the modal gallery if `enableCloseOutside` is true.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onClickOutside",
          value: function onClickOutside(event) {
            if (event && this.enableCloseOutside) {
              this.closeGallery(_Action.CLICK);
            }
          }
          /**
           * Method called when an image is loaded and the loading spinner has gone.
           * It sets the previouslyLoaded flag inside the Image to hide loading spinner when displayed again.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onImageLoad",
          value: function onImageLoad(event) {
            // console.log('modal-image onImageLoad', event);
            // console.log('modal-image onImageLoad images before', this.images);
            // sets as previously loaded the image with index specified by `event.status`
            this.images = this.images.map(
            /**
            * @param {?} img
            * @return {?}
            */
            function (img) {
              if (img && img.id === event.id) {
                return Object.assign({}, img, {
                  previouslyLoaded: event.status
                });
              }

              return img;
            }); // console.log('modal-image onImageLoad images after', this.images);
          }
          /**
           * Method called when a dot is clicked and used to update the current image.
           * @param {?} index
           * @return {?}
           */

        }, {
          key: "onClickDot",
          value: function onClickDot(index) {
            this.currentImage = this.images[index];
          }
          /**
           * Method called when an image preview is clicked and used to update the current image.
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onClickPreview",
          value: function onClickPreview(event) {
            this.onChangeCurrentImage(event);
          } // onClickArrow(event: InteractionEvent) {
          //   // TODO validate before to emit
          //   this.arrow.emit(event);
          // }

          /**
           * Method to download the current image, only if `downloadable` is true.
           * It contains also a logic to enable downloading features also for IE11.
           * @return {?}
           */

        }, {
          key: "downloadImage",
          value: function downloadImage() {
            if (this.currentImageConfig && !this.currentImageConfig.downloadable) {
              return;
            } // If IE11 or Microsoft Edge use msSaveBlob(...)


            if (this.isIEorEdge()) {
              // I cannot use fetch API because IE11 doesn't support it,
              // so I have to switch to XMLHttpRequest
              this.downloadImageOnlyIEorEdge();
            } else {
              // for all other browsers
              this.downloadImageAllBrowsers();
            }
          }
          /**
           * Method to cleanup resources. In fact, this will reset keyboard's service.
           * This is an Angular's lifecycle hook that is called when this component is destroyed.
           * @return {?}
           */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.keyboardService.reset();
            this.idValidatorService.remove(this.id);

            if (this.galleryServiceNavigateSubscription) {
              this.galleryServiceNavigateSubscription.unsubscribe();
            }

            if (this.galleryServiceCloseSubscription) {
              this.galleryServiceCloseSubscription.unsubscribe();
            }

            if (this.galleryServiceUpdateSubscription) {
              this.galleryServiceUpdateSubscription.unsubscribe();
            }

            if (this.galleryServiceAutoPlaySubscription) {
              this.galleryServiceAutoPlaySubscription.unsubscribe();
            }
          }
          /**
           * Private method to download the current image for all browsers except for IE11.
           * @private
           * @return {?}
           */

        }, {
          key: "downloadImageAllBrowsers",
          value: function downloadImageAllBrowsers() {
            /** @type {?} */
            var link = document.createElement('a');
            link.href = this.currentImage.modal.img;
            link.setAttribute('download', this.getFileName(this.currentImage));
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }
          /**
           * Private method to download the current image only for IE11 using
           * custom javascript's methods available only on IE.
           * @private
           * @return {?}
           */

        }, {
          key: "downloadImageOnlyIEorEdge",
          value: function downloadImageOnlyIEorEdge() {
            var _this8 = this;

            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this.platformId)) {
              /** @type {?} */
              var req = new XMLHttpRequest();
              req.open('GET', this.currentImage.modal.img, true);
              req.responseType = 'arraybuffer';

              req.onload =
              /**
              * @param {?} event
              * @return {?}
              */
              function (event) {
                /** @type {?} */
                var blob = new Blob([req.response], {
                  type: 'image/png'
                });
                window.navigator.msSaveBlob(blob, _this8.getFileName(_this8.currentImage));
              };

              req.send();
            }
          }
          /**
           * Private method to get the `ButtonEvent` to emit, merging the input `ButtonEvent`
           * with the current image.
           * @private
           * @param {?} event
           * @return {?} ButtonEvent event payload with the current image included
           */

        }, {
          key: "getButtonEventToEmit",
          value: function getButtonEventToEmit(event) {
            return Object.assign(event, {
              image: this.currentImage
            });
          }
          /**
           * Private method to get the file name from an input path.
           * This is used either to get the image's name from its path or from the Image itself,
           * if specified as 'downloadFileName' by the user.
           * @private
           * @param {?} image
           * @return {?} string string file name of the input image.
           */

        }, {
          key: "getFileName",
          value: function getFileName(image) {
            if (!image.modal.downloadFileName || image.modal.downloadFileName.length === 0) {
              return this.currentImage.modal.img.replace(/^.*[\\\/]/, '');
            } else {
              return image.modal.downloadFileName;
            }
          }
          /**
           * Private method to initialize `images` as array of `Image`s.
           * Also, it will emit ImageowmodaModalEvent to say that images are loaded.
           * @private
           * @return {?}
           */

        }, {
          key: "initImages",
          value: function initImages() {
            // I'm not cloning the array, but I'm doing this to cast it to an array of InternalLibImages
            this.images = this.modalImages;
            this.hasData.emit(new _ImageModalEvent(_Action.LOAD, true));
            this.showGallery = this.images.length > 0;
          }
          /**
           * Private method to emit events when either the last or the first image are visible.
           * @private
           * @param {?} action Enum of type Action that represents the source of the event that changed the
           *  current image to the first one or the last one.
           * @param {?} indexToCheck is the index number of the image (the first or the last one).
           * @return {?}
           */

        }, {
          key: "emitBoundaryEvent",
          value: function emitBoundaryEvent(action, indexToCheck) {
            // to emit first/last event
            switch (indexToCheck) {
              case 0:
                this.firstImage.emit(new _ImageModalEvent(action, true));
                break;

              case this.images.length - 1:
                this.lastImage.emit(new _ImageModalEvent(action, true));
                break;
            }
          }
          /**
           * Private method to check if this library is running on
           * Microsoft browsers or not (i.e. it detects both IE11 and Edge)
           * supporting also Server-Side Rendering.
           * Inspired by https://msdn.microsoft.com/it-it/library/hh779016(v=vs.85).aspx
           * @private
           * @return {?} any the result
           */

        }, {
          key: "isIEorEdge",
          value: function isIEorEdge() {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this.platformId)) {
              // if both Blob constructor and msSaveOrOpenBlob are supported by the current browser
              return window.Blob && window.navigator.msSaveOrOpenBlob;
            }

            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformServer)(this.platformId)) {
              // server only
              return true;
            }
          }
        }]);

        return ModalGalleryComponent;
      }();

      ModalGalleryComponent.ɵfac = function ModalGalleryComponent_Factory(t) {
        return new (t || ModalGalleryComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](KeyboardService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_GalleryService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](IdValidatorService));
      };

      ModalGalleryComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: ModalGalleryComponent,
        selectors: [["ks-modal-gallery"]],
        viewQuery: function ModalGalleryComponent_Query(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵviewQuery"](CurrentImageComponent, 5);
          }

          if (rf & 2) {
            var _t;

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵqueryRefresh"](_t = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵloadQuery"]()) && (ctx.currentImageComponent = _t.first);
          }
        },
        hostBindings: function ModalGalleryComponent_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("popstate", function ModalGalleryComponent_popstate_HostBindingHandler($event) {
              return ctx.onPopState($event);
            }, false, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵresolveWindow"]);
          }
        },
        inputs: {
          enableCloseOutside: "enableCloseOutside",
          accessibilityConfig: "accessibilityConfig",
          id: "id",
          modalImages: "modalImages",
          buttonsConfig: "buttonsConfig",
          currentImageConfig: "currentImageConfig",
          dotsConfig: "dotsConfig",
          previewConfig: "previewConfig",
          slideConfig: "slideConfig",
          keyboardConfig: "keyboardConfig",
          plainGalleryConfig: "plainGalleryConfig"
        },
        outputs: {
          close: "close",
          show: "show",
          firstImage: "firstImage",
          lastImage: "lastImage",
          hasData: "hasData",
          buttonBeforeHook: "buttonBeforeHook",
          buttonAfterHook: "buttonAfterHook",
          arrow: "arrow"
        },
        exportAs: ["ksModalGallery"],
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 3,
        vars: 7,
        consts: [[3, "images", "showGallery", "plainGalleryConfig", "accessibilityConfig", "show"], [3, "isOpen", "accessibilityConfig"], ["id", "modal-gallery-wrapper", "ksClickOutside", "", 3, "title", "clickOutsideEnable", "clickOutside", 4, "ngIf"], ["id", "modal-gallery-wrapper", "ksClickOutside", "", 3, "title", "clickOutsideEnable", "clickOutside"], ["id", "flex-min-height-ie-fix"], ["id", "modal-gallery-container"], [3, "currentImage", "buttonsConfig", "delete", "navigate", "download", "close", "fullscreen", "customEmit"], [3, "id", "images", "currentImage", "isOpen", "slideConfig", "keyboardConfig", "accessibilityConfig", "currentImageConfig", "loadImage", "changeImage", "close"], [3, "images", "currentImage", "dotsConfig", "accessibilityConfig", "clickDot"], [3, "images", "currentImage", "previewConfig", "accessibilityConfig", "clickPreview"]],
        template: function ModalGalleryComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "ks-plain-gallery", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("show", function ModalGalleryComponent_Template_ks_plain_gallery_show_0_listener($event) {
              return ctx.onShowModalGallery($event);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](1, "ks-background", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, ModalGalleryComponent_div_2_Template, 8, 21, "div", 2);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("images", ctx.images)("showGallery", ctx.showGallery && ctx.isPlainGalleryVisible())("plainGalleryConfig", ctx.plainGalleryConfig)("accessibilityConfig", ctx.accessibilityConfig);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("isOpen", ctx.opened)("accessibilityConfig", ctx.accessibilityConfig);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.opened);
          }
        },
        directives: function directives() {
          return [PlainGalleryComponent, BackgroundComponent, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, ClickOutsideDirective, UpperButtonsComponent, CurrentImageComponent, DotsComponent, PreviewsComponent];
        },
        styles: ["#modal-gallery-wrapper[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:10000}#flex-min-height-ie-fix[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center}#modal-gallery-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:space-between;min-height:100vh}"],
        changeDetection: 0
      });
      /** @nocollapse */

      ModalGalleryComponent.ctorParameters = function () {
        return [{
          type: KeyboardService
        }, {
          type: _GalleryService
        }, {
          type: Object,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }, {
          type: IdValidatorService
        }];
      };

      ModalGalleryComponent.propDecorators = {
        id: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        modalImages: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        buttonsConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        enableCloseOutside: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        currentImageConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        dotsConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        previewConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        slideConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        keyboardConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        plainGalleryConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        close: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        show: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        firstImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        lastImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        hasData: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        buttonBeforeHook: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        buttonAfterHook: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        arrow: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        currentImageComponent: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
          args: [CurrentImageComponent]
        }],
        onPopState: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['window:popstate', ['$event']]
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](ModalGalleryComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-modal-gallery',
            exportAs: 'ksModalGallery',
            template: "<ks-plain-gallery [images]=\"images\"\n                  [showGallery]=\"showGallery && isPlainGalleryVisible()\"\n                  [plainGalleryConfig]=\"plainGalleryConfig\"\n                  [accessibilityConfig]=\"accessibilityConfig\"\n                  (show)=\"onShowModalGallery($event)\"></ks-plain-gallery>\n\n<ks-background [isOpen]=\"opened\"\n               [accessibilityConfig]=\"accessibilityConfig\"></ks-background>\n\n<div id=\"modal-gallery-wrapper\" *ngIf=\"opened\"\n     [attr.aria-label]=\"accessibilityConfig.modalGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig.modalGalleryContentTitle\"\n     ksClickOutside [clickOutsideEnable]=\"enableCloseOutside\"\n     (clickOutside)=\"onClickOutside($event)\">\n\n  <div id=\"flex-min-height-ie-fix\">\n    <div id=\"modal-gallery-container\">\n\n      <ks-upper-buttons [currentImage]=\"currentImage\"\n                        [buttonsConfig]=\"buttonsConfig\"\n                        (delete)=\"onDelete($event)\"\n                        (navigate)=\"onNavigate($event)\"\n                        (download)=\"onDownload($event)\"\n                        (close)=\"onCloseGallery($event)\"\n                        (fullscreen)=\"onFullScreen($event)\"\n                        (customEmit)=\"onCustomEmit($event)\"></ks-upper-buttons>\n                        <!--(rotate)=\"onRotate($event)\"-->\n\n      <ks-current-image [id]=\"id\"\n                        [images]=\"images\"\n                        [currentImage]=\"currentImage\"\n                        [isOpen]=\"opened\"\n                        [slideConfig]=\"configSlide\"\n                        [keyboardConfig]=\"keyboardConfig\"\n                        [accessibilityConfig]=\"accessibilityConfig\"\n                        [currentImageConfig]=\"currentImageConfig\"\n                        (loadImage)=\"onImageLoad($event)\"\n                        (changeImage)=\"onChangeCurrentImage($event)\"\n                        (close)=\"onCloseGallery($event)\"></ks-current-image>\n\n      <div>\n        <ks-dots [images]=\"images\"\n                 [currentImage]=\"currentImage\"\n                 [dotsConfig]=\"dotsConfig\"\n                 [accessibilityConfig]=\"accessibilityConfig\"\n                 (clickDot)=\"onClickDot($event)\"></ks-dots>\n\n        <ks-previews [images]=\"images\"\n                     [currentImage]=\"currentImage\"\n                     [previewConfig]=\"previewConfig\"\n                     [accessibilityConfig]=\"accessibilityConfig\"\n                     (clickPreview)=\"onClickPreview($event)\"></ks-previews>\n      </div>\n    </div>\n  </div>\n</div>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: ["#modal-gallery-wrapper{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:10000}#flex-min-height-ie-fix{display:flex;flex-direction:column;justify-content:center}#modal-gallery-container{display:flex;flex-direction:column;justify-content:space-between;min-height:100vh}"]
          }]
        }], function () {
          return [{
            type: KeyboardService
          }, {
            type: _GalleryService
          }, {
            type: Object,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
            }]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }, {
            type: IdValidatorService
          }];
        }, {
          enableCloseOutside: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          close: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          show: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          firstImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          lastImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          hasData: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          buttonBeforeHook: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          buttonAfterHook: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          arrow: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],

          /**
           * HostListener to catch browser's back button and destroy the gallery.
           * This prevents weired behaviour about scrolling.
           * Added to fix this issue: https://github.com/Ks89/angular-modal-gallery/issues/159
           * @param {?} e
           * @return {?}
           */
          onPopState: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['window:popstate', ['$event']]
          }],
          id: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          modalImages: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          buttonsConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          currentImageConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          dotsConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          previewConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          slideConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          keyboardConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          plainGalleryConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          currentImageComponent: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ViewChild,
            args: [CurrentImageComponent]
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with configurable inline/plain carousel.
       */


      var CarouselComponent = /*#__PURE__*/function (_AccessibleComponent2) {
        _inherits(CarouselComponent, _AccessibleComponent2);

        var _super3 = _createSuper(CarouselComponent);

        /**
         * @param {?} _platformId
         * @param {?} _ngZone
         * @param {?} galleryService
         * @param {?} ref
         * @param {?} sanitizer
         */
        function CarouselComponent(_platformId, _ngZone, galleryService, ref, sanitizer) {
          var _this9;

          _classCallCheck(this, CarouselComponent);

          _this9 = _super3.call(this);
          _this9._platformId = _platformId;
          _this9._ngZone = _ngZone;
          _this9.galleryService = galleryService;
          _this9.ref = ref;
          _this9.sanitizer = sanitizer;
          /**
           * Attribute to set ariaLabel of the host component
           */

          _this9.ariaLabel = "Carousel";
          /**
           * Object of type `DotsConfig` to init DotsComponent's features.
           * For instance, it contains a param to show/hide this component.
           */

          _this9.dotsConfig = {
            visible: true
          };
          /**
           * boolean to enable/disable infinite sliding. Enabled by default.
           */

          _this9.infinite = true;
          /**
           * Object of type `AccessibilityConfig` to init custom accessibility features.
           * For instance, it contains titles, alt texts, aria-labels and so on.
           */

          _this9.accessibilityConfig = _KS_DEFAULT_ACCESSIBILITY_CONFIG;
          /**
           * Output to emit an event when an image is changed.
           */

          _this9.show = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the current image is the first one.
           */

          _this9.firstImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit an event when the current image is the last one.
           */

          _this9.lastImage = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Enum of type `Action` that represents a mouse click on a button.
           * Declared here to be used inside the template.
           */

          _this9.clickAction = _Action.CLICK;
          /**
           * Enum of type `Action` that represents a keyboard action.
           * Declared here to be used inside the template.
           */

          _this9.keyboardAction = _Action.KEYBOARD;
          /**
           * Boolean that it's true when you are watching the first image (currently visible).
           * False by default
           */

          _this9.isFirstImage = false;
          /**
           * Boolean that it's true when you are watching the last image (currently visible).
           * False by default
           */

          _this9.isLastImage = false;
          /**
           * Object of type `PlainGalleryConfig` to force ks-modal-gallery to hide plain-gallery
           */

          _this9.plainGalleryHidden = {
            strategy: _PlainGalleryStrategy.CUSTOM,
            layout: new _AdvancedLayout(-1, true)
          };
          /**
           * Subject to play the carousel.
           */

          _this9.start$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          /**
           * Subject to stop the carousel.
           */

          _this9.stop$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.Subject();
          /**
           * Private object without type to define all swipe actions used by hammerjs.
           */

          _this9.SWIPE_ACTION = {
            LEFT: 'swipeleft',
            RIGHT: 'swiperight',
            UP: 'swipeup',
            DOWN: 'swipedown'
          };
          return _this9;
        }
        /**
         * Listener to stop the gallery when the mouse pointer is over the current image.
         * @return {?}
         */


        _createClass(CarouselComponent, [{
          key: "onMouseEnter",
          value: function onMouseEnter() {
            if (!this.configPlay.pauseOnHover) {
              return;
            }

            this.stopCarousel();
          }
          /**
           * Listener to play the gallery when the mouse pointer leave the current image.
           * @return {?}
           */

        }, {
          key: "onMouseLeave",
          value: function onMouseLeave() {
            if (!this.configPlay.pauseOnHover || !this.configPlay.autoPlay) {
              return;
            }

            this.playCarousel();
          }
          /**
           * Listener to navigate carousel images with keyboard (left).
           * @return {?}
           */

        }, {
          key: "onKeyDownLeft",
          value: function onKeyDownLeft() {
            if (!this.configCarousel.keyboardEnable) {
              return;
            }

            this.prevImage();
          }
          /**
           * Listener to navigate carousel images with keyboard (right).
           * @return {?}
           */

        }, {
          key: "onKeyDownLRight",
          value: function onKeyDownLRight() {
            if (!this.configCarousel.keyboardEnable) {
              return;
            }

            this.nextImage();
          }
          /**
           * @param {?} changes
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            // handle changes of dotsConfig

            /** @type {?} */
            var configDotsChange = changes.dotsConfig;

            if (configDotsChange && configDotsChange.currentValue !== configDotsChange.previousValue) {
              this.configDots = configDotsChange.currentValue;
            } // handle changes of carouselConfig

            /** @type {?} */


            var carouselConfigChange = changes.carouselConfig;

            if (carouselConfigChange && carouselConfigChange.currentValue !== carouselConfigChange.previousValue) {
              this.configCarousel = carouselConfigChange.currentValue;
            } // handle changes of playConfig starting/stopping the carousel accordingly

            /** @type {?} */


            var playConfigChange = changes.playConfig;

            if (playConfigChange) {
              /** @type {?} */
              var playConfigChangePrev = playConfigChange.previousValue;
              /** @type {?} */

              var playConfigChangeCurr = playConfigChange.currentValue;

              if (playConfigChangePrev !== playConfigChangeCurr) {
                this.configPlay = playConfigChange.currentValue; // if autoplay is enabled, and this is not the
                // first change (to prevent multiple starts at the beginning)

                if (playConfigChangeCurr.autoPlay && !playConfigChange.isFirstChange()) {
                  this.start$.next();
                } else {
                  this.stopCarousel();
                }
              }
            }
          }
          /**
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            this.currentImage = this.images[0];
            /** @type {?} */

            var defaultDescriptionStyle = {
              bgColor: 'rgba(0, 0, 0, .5)',
              textColor: 'white',
              marginTop: '0px',
              marginBottom: '0px',
              marginLeft: '0px',
              marginRight: '0px'
            };
            /** @type {?} */

            var defaultDescription = {
              strategy: _DescriptionStrategy.ALWAYS_HIDDEN,
              imageText: 'Image ',
              numberSeparator: '/',
              beforeTextDescription: ' - ',
              style: defaultDescriptionStyle
            };
            /** @type {?} */

            var defaultCurrentImageConfig = {
              description: defaultDescription,
              invertSwipe: false
            };
            /** @type {?} */

            var defaultCurrentCarouselConfig = {
              maxWidth: '100%',
              maxHeight: '400px',
              showArrows: true,
              objectFit: 'cover',
              keyboardEnable: true,
              modalGalleryEnable: false,
              legacyIE11Mode: false
            };
            /** @type {?} */

            var defaultCurrentCarouselPlay = {
              autoPlay: true,
              interval: 5000,
              pauseOnHover: true
            };
            this.configCurrentImageCarousel = Object.assign({}, defaultCurrentImageConfig, this.carouselImageConfig);
            this.configCurrentImageCarousel.description = Object.assign({}, defaultDescription, this.configCurrentImageCarousel.description);
            /** @type {?} */

            var defaultConfig = {
              visible: true
            };
            this.configDots = Object.assign(defaultConfig, this.dotsConfig);
            this.configCarousel = Object.assign({}, defaultCurrentCarouselConfig, this.carouselConfig);
            this.configPlay = Object.assign({}, defaultCurrentCarouselPlay, this.playConfig); // check values

            if (this.configPlay.interval <= 0) {
              throw new Error("Carousel's interval must be a number >= 0");
            }

            this.manageSlideConfig();
          }
          /**
           * @return {?}
           */

        }, {
          key: "ngAfterContentInit",
          value: function ngAfterContentInit() {
            var _this10 = this;

            // interval doesn't play well with SSR and protractor,
            // so we should run it in the browser and outside Angular
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_1__.isPlatformBrowser)(this._platformId)) {
              this._ngZone.runOutsideAngular(
              /**
              * @return {?}
              */
              function () {
                _this10.start$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(
                /**
                * @return {?}
                */
                function () {
                  return _this10.configPlay.interval;
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.filter)(
                /**
                * @param {?} interval
                * @return {?}
                */
                function (interval) {
                  return interval > 0;
                }), (0, rxjs_operators__WEBPACK_IMPORTED_MODULE_5__.switchMap)(
                /**
                * @param {?} interval
                * @return {?}
                */
                function (interval) {
                  return (0, rxjs__WEBPACK_IMPORTED_MODULE_6__.timer)(interval).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_7__.takeUntil)(_this10.stop$));
                })).subscribe(
                /**
                * @return {?}
                */
                function () {
                  return _this10._ngZone.run(
                  /**
                  * @return {?}
                  */
                  function () {
                    if (_this10.configPlay.autoPlay) {
                      _this10.nextImage();
                    }

                    _this10.ref.markForCheck();
                  });
                });

                _this10.start$.next();
              });
            }
          }
          /**
           * Method used in template to sanitize an url when you need legacyIE11Mode.
           * In this way you can set an url as background of a div.
           * @param {?} unsafeStyle is a string and represents the url to sanitize.
           * @return {?} a SafeStyle object that can be used in template without problems.
           */

        }, {
          key: "sanitizeUrlBgStyle",
          value: function sanitizeUrlBgStyle(unsafeStyle) {
            // Method used only to sanitize background-image style before add it to background property when legacyIE11Mode is enabled
            return this.sanitizer.bypassSecurityTrustStyle('url(' + unsafeStyle + ')');
          }
          /**
           * Method called when a dot is clicked and used to update the current image.
           * @param {?} index
           * @return {?}
           */

        }, {
          key: "onClickDot",
          value: function onClickDot(index) {
            this.changeCurrentImage(this.images[index], _Action.NORMAL);
          }
          /**
           * Method called by events from both keyboard and mouse on a navigation arrow.
           * @param {?} direction
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onNavigationEvent",
          value: function onNavigationEvent(direction, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.NORMAL;

            /** @type {?} */
            var result = _get(_getPrototypeOf(CarouselComponent.prototype), "handleNavigationEvent", this).call(this, direction, event);

            if (result === NEXT) {
              this.nextImage(action);
            } else if (result === PREV) {
              this.prevImage(action);
            }
          }
          /**
           * Method triggered when you click on the current image.
           * Also, if modalGalleryEnable is true, you can open the modal-gallery.
           * @return {?}
           */

        }, {
          key: "onClickCurrentImage",
          value: function onClickCurrentImage() {
            if (!this.configCarousel.modalGalleryEnable) {
              return;
            }
            /** @type {?} */


            var index = getIndex(this.currentImage, this.images);
            this.galleryService.openGallery(this.id, index);
          }
          /**
           * Method to get the image description based on input params.
           * If you provide a full description this will be the visible description, otherwise,
           * it will be built using the `Description` object, concatenating its fields.
           * @throws an Error if description isn't available
           * @param {?=} image
           * @return {?} String description of the image (or the current image if not provided)
           */

        }, {
          key: "getDescriptionToDisplay",
          value: function getDescriptionToDisplay() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!this.configCurrentImageCarousel || !this.configCurrentImageCarousel.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            }
            /** @type {?} */


            var imageWithoutDescription = !image.modal || !image.modal.description || image.modal.description === '';

            switch (this.configCurrentImageCarousel.description.strategy) {
              case _DescriptionStrategy.HIDE_IF_EMPTY:
                return imageWithoutDescription ? '' : image.modal.description + '';

              case _DescriptionStrategy.ALWAYS_HIDDEN:
                return '';

              default:
                // ----------- DescriptionStrategy.ALWAYS_VISIBLE -----------------
                return this.buildTextDescription(image, imageWithoutDescription);
            }
          }
          /**
           * Method used by Hammerjs to support touch gestures (you can also invert the swipe direction with configCurrentImage.invertSwipe).
           * @param {?=} action String that represent the direction of the swipe action. 'swiperight' by default.
           * @return {?}
           */

        }, {
          key: "swipe",
          value: function swipe() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.SWIPE_ACTION.RIGHT;

            switch (action) {
              case this.SWIPE_ACTION.RIGHT:
                if (this.configCurrentImageCarousel.invertSwipe) {
                  this.prevImage(_Action.SWIPE);
                } else {
                  this.nextImage(_Action.SWIPE);
                }

                break;

              case this.SWIPE_ACTION.LEFT:
                if (this.configCurrentImageCarousel.invertSwipe) {
                  this.nextImage(_Action.SWIPE);
                } else {
                  this.prevImage(_Action.SWIPE);
                }

                break;
              // case this.SWIPE_ACTION.UP:
              //   break;
              // case this.SWIPE_ACTION.DOWN:
              //   break;
            }
          }
          /**
           * Method to go back to the previous image.
           * @param {?=} action Enum of type `Action` that represents the source
           *  action that moved back to the previous image. `Action.NORMAL` by default.
           * @return {?}
           */

        }, {
          key: "prevImage",
          value: function prevImage() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Action.NORMAL;

            // check if prevImage should be blocked
            if (this.isPreventSliding(0)) {
              return;
            }

            this.changeCurrentImage(this.getPrevImage(), action);
            this.manageSlideConfig();
            this.start$.next();
          }
          /**
           * Method to go back to the previous image.
           * @param {?=} action Enum of type `Action` that represents the source
           *  action that moved to the next image. `Action.NORMAL` by default.
           * @return {?}
           */

        }, {
          key: "nextImage",
          value: function nextImage() {
            var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _Action.NORMAL;

            // check if nextImage should be blocked
            if (this.isPreventSliding(this.images.length - 1)) {
              return;
            }

            this.changeCurrentImage(this.getNextImage(), action);
            this.manageSlideConfig();
            this.start$.next();
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item.id;
          }
          /**
           * Method called when an image preview is clicked and used to update the current image.
           * @param {?} event an ImageEvent object with the relative action and the index of the clicked preview.
           * @return {?}
           */

        }, {
          key: "onClickPreview",
          value: function onClickPreview(event) {
            /** @type {?} */
            var imageFound = this.images[event.result];

            if (!!imageFound) {
              this.manageSlideConfig();
              this.changeCurrentImage(imageFound, event.action);
            }
          }
          /**
           * Method to play carousel.
           * @return {?}
           */

        }, {
          key: "playCarousel",
          value: function playCarousel() {
            this.start$.next();
          }
          /**
           * Stops the carousel from cycling through items.
           * @return {?}
           */

        }, {
          key: "stopCarousel",
          value: function stopCarousel() {
            this.stop$.next();
          } // TODO remove this because duplicated

          /**
           * Method to get `alt attribute`.
           * `alt` specifies an alternate text for an image, if the image cannot be displayed.
           * @param {?=} image
           * @return {?} String alt description of the image (or the current image if not provided)
           */

        }, {
          key: "getAltDescriptionByImage",
          value: function getAltDescriptionByImage() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!image) {
              return '';
            }

            return image.modal && image.modal.description ? image.modal.description : "Image ".concat(getIndex(image, this.images) + 1);
          } // TODO remove this because duplicated

          /**
           * Method to get the title attributes based on descriptions.
           * This is useful to prevent accessibility issues, because if DescriptionStrategy is ALWAYS_HIDDEN,
           * it prevents an empty string as title.
           * @throws an Error if description isn't available
           * @param {?=} image
           * @return {?} String title of the image based on descriptions
           */

        }, {
          key: "getTitleToDisplay",
          value: function getTitleToDisplay() {
            var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentImage;

            if (!this.configCurrentImageCarousel || !this.configCurrentImageCarousel.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            }
            /** @type {?} */


            var imageWithoutDescription = !image.modal || !image.modal.description || image.modal.description === '';
            /** @type {?} */

            var description = this.buildTextDescription(image, imageWithoutDescription);
            return description;
          }
          /**
             * Method to reset carousel (force image with index 0 to be the current image and re-init also previews)
             */
          // temporary removed because never tested
          // reset() {
          //   if (this.configPlay && this.configPlay.autoPlay) {
          //     this.stopCarousel();
          //   }
          //   this.currentImage = this.images[0];
          //   this.handleBoundaries(0);
          //   if (this.configPlay && this.configPlay.autoPlay) {
          //     this.playCarousel();
          //   }
          //   this.ref.markForCheck();
          // }

          /**
           * Method to cleanup resources. In fact, this will stop the carousel.
           * This is an Angular's lifecycle hook that is called when this component is destroyed.
           * @return {?}
           */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            this.stopCarousel();
          }
          /**
           * Method to change the current image, receiving the new image as input the relative action.
           * @private
           * @param {?} image an Image object that represents the new image to set as current.
           * @param {?} action Enum of type `Action` that represents the source action that triggered the change.
           * @return {?}
           */

        }, {
          key: "changeCurrentImage",
          value: function changeCurrentImage(image, action) {
            this.currentImage = image;
            /** @type {?} */

            var index = getIndex(image, this.images); // emit first/last event based on newIndex value

            this.emitBoundaryEvent(action, index); // emit current visible image index

            this.show.emit(new _ImageModalEvent(action, index + 1));
          }
          /**
           * Private method to get the next index.
           * This is necessary because at the end, when you call next again, you'll go to the first image.
           * That happens because all modal images are shown like in a circle.
           * @private
           * @return {?}
           */

        }, {
          key: "getNextImage",
          value: function getNextImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);
            /** @type {?} */

            var newIndex = 0;

            if (currentIndex >= 0 && currentIndex < this.images.length - 1) {
              newIndex = currentIndex + 1;
            } else {
              newIndex = 0; // start from the first index
            }

            return this.images[newIndex];
          }
          /**
           * Private method to get the previous index.
           * This is necessary because at index 0, when you call prev again, you'll go to the last image.
           * That happens because all modal images are shown like in a circle.
           * @private
           * @return {?}
           */

        }, {
          key: "getPrevImage",
          value: function getPrevImage() {
            /** @type {?} */
            var currentIndex = getIndex(this.currentImage, this.images);
            /** @type {?} */

            var newIndex = 0;

            if (currentIndex > 0 && currentIndex <= this.images.length - 1) {
              newIndex = currentIndex - 1;
            } else {
              newIndex = this.images.length - 1; // start from the last index
            }

            return this.images[newIndex];
          }
          /**
           * Private method to build a text description.
           * This is used also to create titles.
           * @private
           * @param {?} image
           * @param {?} imageWithoutDescription
           * @return {?} String description built concatenating image fields with a specific logic.
           */

        }, {
          key: "buildTextDescription",
          value: function buildTextDescription(image, imageWithoutDescription) {
            if (!this.configCurrentImageCarousel || !this.configCurrentImageCarousel.description) {
              throw new Error('Description input must be a valid object implementing the Description interface');
            } // If customFullDescription use it, otherwise proceed to build a description


            if (this.configCurrentImageCarousel.description.customFullDescription && this.configCurrentImageCarousel.description.customFullDescription !== '') {
              return this.configCurrentImageCarousel.description.customFullDescription;
            }
            /** @type {?} */


            var currentIndex = getIndex(image, this.images); // If the current image hasn't a description,
            // prevent to write the ' - ' (or this.description.beforeTextDescription)

            /** @type {?} */

            var prevDescription = this.configCurrentImageCarousel.description.imageText ? this.configCurrentImageCarousel.description.imageText : '';
            /** @type {?} */

            var midSeparator = this.configCurrentImageCarousel.description.numberSeparator ? this.configCurrentImageCarousel.description.numberSeparator : '';
            /** @type {?} */

            var middleDescription = currentIndex + 1 + midSeparator + this.images.length;

            if (imageWithoutDescription) {
              return prevDescription + middleDescription;
            }
            /** @type {?} */


            var currImgDescription = image.modal && image.modal.description ? image.modal.description : '';
            /** @type {?} */

            var endDescription = this.configCurrentImageCarousel.description.beforeTextDescription + currImgDescription;
            return prevDescription + middleDescription + endDescription;
          }
          /**
           * Private method to update both `isFirstImage` and `isLastImage` based on
           * the index of the current image.
           * @private
           * @param {?} currentIndex
           * @return {?}
           */

        }, {
          key: "handleBoundaries",
          value: function handleBoundaries(currentIndex) {
            if (this.images.length === 1) {
              this.isFirstImage = true;
              this.isLastImage = true;
              return;
            }

            switch (currentIndex) {
              case 0:
                // execute this only if infinite sliding is disabled
                this.isFirstImage = true;
                this.isLastImage = false;
                break;

              case this.images.length - 1:
                // execute this only if infinite sliding is disabled
                this.isFirstImage = false;
                this.isLastImage = true;
                break;

              default:
                this.isFirstImage = false;
                this.isLastImage = false;
                break;
            }
          }
          /**
           * Private method to manage boundary arrows and sliding.
           * This is based on the slideConfig input to enable/disable 'infinite sliding'.
           * @private
           * @return {?}
           */

        }, {
          key: "manageSlideConfig",
          value: function manageSlideConfig() {
            /** @type {?} */
            var index;

            try {
              index = getIndex(this.currentImage, this.images);
            } catch (err) {
              console.error('Cannot get the current image index in current-image');
              throw err;
            }

            if (this.infinite === true) {
              // enable infinite sliding
              this.isFirstImage = false;
              this.isLastImage = false;
            } else {
              this.handleBoundaries(index);
            }
          }
          /**
           * Private method to emit events when either the last or the first image are visible.
           * @private
           * @param {?} action Enum of type Action that represents the source of the event that changed the
           *  current image to the first one or the last one.
           * @param {?} indexToCheck is the index number of the image (the first or the last one).
           * @return {?}
           */

        }, {
          key: "emitBoundaryEvent",
          value: function emitBoundaryEvent(action, indexToCheck) {
            // to emit first/last event
            switch (indexToCheck) {
              case 0:
                this.firstImage.emit(new _ImageModalEvent(action, true));
                break;

              case this.images.length - 1:
                this.lastImage.emit(new _ImageModalEvent(action, true));
                break;
            }
          }
          /**
           * Private method to check if next/prev actions should be blocked.
           * It checks if slideConfig.infinite === false and if the image index is equals to the input parameter.
           * If yes, it returns true to say that sliding should be blocked, otherwise not.
           * @private
           * @param {?} boundaryIndex
           * @return {?} boolean true if slideConfig.infinite === false and the current index is
           *  either the first or the last one.
           */

        }, {
          key: "isPreventSliding",
          value: function isPreventSliding(boundaryIndex) {
            return !this.infinite && getIndex(this.currentImage, this.images) === boundaryIndex;
          }
        }]);

        return CarouselComponent;
      }(AccessibleComponent);

      CarouselComponent.ɵfac = function CarouselComponent_Factory(t) {
        return new (t || CarouselComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_GalleryService), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer));
      };

      CarouselComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: CarouselComponent,
        selectors: [["ks-carousel"]],
        hostVars: 1,
        hostBindings: function CarouselComponent_HostBindings(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("mouseenter", function CarouselComponent_mouseenter_HostBindingHandler() {
              return ctx.onMouseEnter();
            })("mouseleave", function CarouselComponent_mouseleave_HostBindingHandler() {
              return ctx.onMouseLeave();
            })("keydown.arrowLeft", function CarouselComponent_keydown_arrowLeft_HostBindingHandler() {
              return ctx.onKeyDownLeft();
            })("keydown.arrowRight", function CarouselComponent_keydown_arrowRight_HostBindingHandler() {
              return ctx.onKeyDownLRight();
            });
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.ariaLabel);
          }
        },
        inputs: {
          dotsConfig: "dotsConfig",
          infinite: "infinite",
          accessibilityConfig: "accessibilityConfig",
          id: "id",
          images: "images",
          carouselConfig: "carouselConfig",
          playConfig: "playConfig",
          carouselImageConfig: "carouselImageConfig",
          previewConfig: "previewConfig"
        },
        outputs: {
          show: "show",
          firstImage: "firstImage",
          lastImage: "lastImage"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        ngContentSelectors: _c6,
        decls: 8,
        vars: 15,
        consts: [["id", "carousel-container", "ksMaxSize", "", 3, "title", "sizeConfig"], ["content", ""], ["class", "current-figure", "ksSize", "", 3, "sizeConfig", 4, "ngIf", "ngIfElse"], ["legacyMode", ""], [3, "images", "currentImage", "carouselConfig", "previewConfig", "accessibilityConfig", "clickPreview"], [3, "id", "modalImages", "plainGalleryConfig"], ["ksSize", "", 1, "current-figure", 3, "sizeConfig"], ["class", "nav-left", "role", "button", 3, "tabindex", "click", "keyup", 4, "ngIf"], [4, "ngTemplateOutlet"], ["id", "current-image", "ksMaxSize", "", "role", "img", 3, "sizeConfig", "src", "title", "alt", "tabindex", "click", "swipeleft", "swiperight"], ["class", "description", "ksDescription", "", 3, "description", "innerHTML", 4, "ngIf"], ["class", "nav-right", "role", "button", 3, "tabindex", "click", "keyup", 4, "ngIf"], ["id", "dots"], [3, "currentImage", "dotsConfig", "accessibilityConfig", "images", "clickDot"], ["role", "button", 1, "nav-left", 3, "tabindex", "click", "keyup"], ["aria-hidden", "true", 3, "title"], ["ksDescription", "", 1, "description", 3, "description", "innerHTML"], ["role", "button", 1, "nav-right", 3, "tabindex", "click", "keyup"], ["id", "current-image-legacy", "ksSize", "", "ksMaxSize", "", "role", "img", 3, "sizeConfig", "title", "tabindex", "click", "swipeleft", "swiperight"], ["class", "description-ie11", "ksDescription", "", 3, "description", "innerHTML", 4, "ngIf"], ["id", "dots-ie11"], ["ksDescription", "", 1, "description-ie11", 3, "description", "innerHTML"]],
        template: function CarouselComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵprojectionDef"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "main", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, CarouselComponent_ng_template_1_Template, 1, 0, "ng-template", null, 1, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, CarouselComponent_figure_3_Template, 8, 22, "figure", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, CarouselComponent_ng_template_4_Template, 8, 32, "ng-template", null, 3, _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplateRefExtractor"]);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](6, "ks-carousel-previews", 4);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵlistener"]("clickPreview", function CarouselComponent_Template_ks_carousel_previews_clickPreview_6_listener($event) {
              return ctx.onClickPreview($event);
            });

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelement"](7, "ks-modal-gallery", 5);
          }

          if (rf & 2) {
            var _r3 = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵreference"](5);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.accessibilityConfig.carouselContainerTitle)("sizeConfig", _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵpureFunction1"](13, _c5, ctx.configCarousel == null ? null : ctx.configCarousel.maxWidth));

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig.carouselContainerAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", (ctx.configCarousel == null ? null : ctx.configCarousel.legacyIE11Mode) === false)("ngIfElse", _r3);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](3);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("images", ctx.images)("currentImage", ctx.currentImage)("carouselConfig", ctx.configCarousel)("previewConfig", ctx.previewConfig)("accessibilityConfig", ctx.accessibilityConfig);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("id", ctx.id)("modalImages", ctx.images)("plainGalleryConfig", ctx.plainGalleryHidden);
          }
        },
        directives: function directives() {
          return [MaxSizeDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, CarouselPreviewsComponent, ModalGalleryComponent, SizeDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgTemplateOutlet, DotsComponent, DescriptionDirective];
        },
        styles: ["[_nghost-%COMP%]{display:flex;flex-direction:column;justify-content:flex-start;align-items:center}#carousel-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;align-items:center;justify-content:space-between;width:100%}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%]{-webkit-animation:.8s fadein-visible;animation:.8s fadein-visible;text-align:center;margin:0;position:relative}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%], #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%], #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{-webkit-animation:1s animatezoom;animation:1s animatezoom;cursor:pointer;transition:.5s;top:50%;position:absolute}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%]:hover, #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]:hover, #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]:hover{transform:scale(1.1)}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]{left:5px}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{right:5px}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > #current-image[_ngcontent-%COMP%], #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > #current-image-legacy[_ngcontent-%COMP%]{width:100%;height:auto;display:block}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > #current-image-legacy[_ngcontent-%COMP%] > .description-ie11[_ngcontent-%COMP%]{bottom:0;width:100%;position:absolute;padding-top:10px;padding-bottom:10px}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > figcaption[_ngcontent-%COMP%]{padding:10px;position:absolute;bottom:0;left:0;right:0}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > figcaption[_ngcontent-%COMP%]   .description[_ngcontent-%COMP%]{font-weight:700;text-align:center}#carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > #dots[_ngcontent-%COMP%], #carousel-container[_ngcontent-%COMP%] > .current-figure[_ngcontent-%COMP%] > #dots-ie11[_ngcontent-%COMP%]{position:absolute;bottom:20px;width:100%}", _c7],
        changeDetection: 0
      });
      /** @nocollapse */

      CarouselComponent.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
          }]
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
        }, {
          type: _GalleryService
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }, {
          type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer
        }];
      };

      CarouselComponent.propDecorators = {
        ariaLabel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
          args: ['attr.aria-label']
        }],
        id: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        carouselConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        playConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        carouselImageConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        dotsConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        previewConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        infinite: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        show: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        firstImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        lastImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        onMouseEnter: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['mouseenter']
        }],
        onMouseLeave: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['mouseleave']
        }],
        onKeyDownLeft: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['keydown.arrowLeft']
        }],
        onKeyDownLRight: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
          args: ['keydown.arrowRight']
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CarouselComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-carousel',
            template: "<main id=\"carousel-container\"\n      [attr.aria-label]=\"accessibilityConfig.carouselContainerAriaLabel\"\n      [title]=\"accessibilityConfig.carouselContainerTitle\"\n      ksMaxSize [sizeConfig]=\"{maxWidth: configCarousel?.maxWidth,\n                               maxHeight: ''}\">\n\n\n  <!-- Workaround to support 2 ng-content in the same template in 2 ngIf (https://github.com/angular/angular/issues/22972) -->\n  <ng-template #content><ng-content></ng-content></ng-template>\n\n  <!-- Normal figure used by all browsers except for IE11, because\n    it doesn't support object-fit cover.-->\n  <figure class=\"current-figure\" *ngIf=\"configCarousel?.legacyIE11Mode === false; else legacyMode\"\n          ksSize [sizeConfig]=\"{width: configCarousel?.maxWidth,\n                                height: ''}\">\n\n    <a class=\"nav-left\" *ngIf=\"configCarousel?.showArrows\"\n       [attr.aria-label]=\"accessibilityConfig.carouselPrevImageAriaLabel\"\n       [tabindex]=\"isLastImage && !infinite ? -1 : 0\" role=\"button\"\n       (click)=\"onNavigationEvent('left', $event, clickAction)\" (keyup)=\"onNavigationEvent('left', $event, keyboardAction)\">\n      <div class=\"inside {{(isFirstImage && !infinite) || !configCarousel.showArrows ? 'empty-arrow-image' : 'left-arrow-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"accessibilityConfig.carouselPrevImageTitle\"></div>\n    </a>\n\n    <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n\n    <img id=\"current-image\"\n         [style.object-fit]=\"configCarousel?.objectFit\"\n         ksMaxSize [sizeConfig]=\"{maxWidth: configCarousel?.maxWidth,\n                                  maxHeight: configCarousel?.maxHeight}\"\n         [src]=\"currentImage.modal.img\"\n         [attr.aria-label]=\"currentImage.modal.ariaLabel\"\n         [title]=\"currentImage.modal.title ? currentImage.modal.title : getTitleToDisplay()\"\n         alt=\"{{currentImage.modal.alt ? currentImage.modal.alt : getAltDescriptionByImage()}}\"\n         [tabindex]=\"0\" role=\"img\"\n         (click)=\"onClickCurrentImage()\"\n         (swipeleft)=\"swipe($event.type)\"\n         (swiperight)=\"swipe($event.type)\"/>\n\n    <figcaption *ngIf=\"getDescriptionToDisplay() !== ''\"\n                class=\"description\"\n                ksDescription [description]=\"configCurrentImageCarousel?.description\"\n                [innerHTML]=\"getDescriptionToDisplay()\"></figcaption>\n\n    <a class=\"nav-right\" *ngIf=\"configCarousel?.showArrows\"\n       [attr.aria-label]=\"accessibilityConfig.carouselNextImageAriaLabel\"\n       [tabindex]=\"isLastImage && !infinite ? -1 : 0\" role=\"button\"\n       (click)=\"onNavigationEvent('right', $event, clickAction)\" (keyup)=\"onNavigationEvent('right', $event, keyboardAction)\">\n      <div class=\"inside {{(isLastImage && !infinite) || !configCarousel.showArrows ? 'empty-arrow-image' : 'right-arrow-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"accessibilityConfig.carouselNextImageTitle\"></div>\n    </a>\n\n    <div id=\"dots\">\n      <ks-dots [currentImage]=\"currentImage\"\n               [dotsConfig]=\"configDots\"\n               [accessibilityConfig]=\"accessibilityConfig\"\n               [images]=\"images\"\n               (clickDot)=\"onClickDot($event)\"></ks-dots>\n    </div>\n\n  </figure>\n\n  <!-- Legacy mode to support img cover also on IE11,\n    because it doesn't support natively object-fit cover. -->\n  <ng-template #legacyMode>\n    <div class=\"current-figure\"\n         ksSize [sizeConfig]=\"{width: configCarousel?.maxWidth,\n                               height: ''}\">\n\n      <a class=\"nav-left\" *ngIf=\"configCarousel?.showArrows\"\n         [attr.aria-label]=\"accessibilityConfig.carouselPrevImageAriaLabel\"\n         [tabindex]=\"isLastImage && !infinite ? -1 : 0\" role=\"button\"\n         (click)=\"onNavigationEvent('left', $event, clickAction)\" (keyup)=\"onNavigationEvent('left', $event, keyboardAction)\">\n        <div class=\"inside {{(isFirstImage && !infinite) || !configCarousel.showArrows ? 'empty-arrow-image' : 'left-arrow-image'}}\"\n             aria-hidden=\"true\"\n             [title]=\"accessibilityConfig.carouselPrevImageTitle\"></div>\n      </a>\n\n      <ng-container *ngTemplateOutlet=\"content\"></ng-container>\n\n      <div id=\"current-image-legacy\"\n           [style.background-color]=\"'transparent'\"\n           [style.background-image]=\"sanitizeUrlBgStyle(currentImage.modal.img + '')\"\n           [style.background-position]=\"'center center'\"\n           [style.background-size]=\"'cover'\"\n           [style.background-repeat]=\"'no-repeat'\"\n           [style.background-attachment]=\"'scroll'\"\n           ksSize [sizeConfig]=\"{width: '100%',\n                                 height: configCarousel?.maxHeight}\"\n           ksMaxSize [sizeConfig]=\"{maxWidth: configCarousel?.maxWidth}\"\n           [attr.aria-label]=\"currentImage.modal.ariaLabel\"\n           [title]=\"currentImage.modal.title ? currentImage.modal.title : getTitleToDisplay()\"\n           [tabindex]=\"0\" role=\"img\"\n           (click)=\"onClickCurrentImage()\"\n           (swipeleft)=\"swipe($event.type)\"\n           (swiperight)=\"swipe($event.type)\">\n\n        <div *ngIf=\"getDescriptionToDisplay() !== ''\"\n             class=\"description-ie11\"\n             ksDescription [description]=\"configCurrentImageCarousel?.description\"\n             [innerHTML]=\"getDescriptionToDisplay()\"></div>\n      </div>\n\n      <a class=\"nav-right\" *ngIf=\"configCarousel?.showArrows\"\n         [attr.aria-label]=\"accessibilityConfig.carouselNextImageAriaLabel\"\n         [tabindex]=\"isLastImage && !infinite ? -1 : 0\" role=\"button\"\n         (click)=\"onNavigationEvent('right', $event, clickAction)\" (keyup)=\"onNavigationEvent('right', $event, keyboardAction)\">\n        <div class=\"inside {{(isLastImage && !infinite) || !configCarousel.showArrows ? 'empty-arrow-image' : 'right-arrow-image'}}\"\n             aria-hidden=\"true\"\n             [title]=\"accessibilityConfig.carouselNextImageTitle\"></div>\n      </a>\n\n      <div id=\"dots-ie11\">\n        <ks-dots [currentImage]=\"currentImage\"\n                 [dotsConfig]=\"configDots\"\n                 [accessibilityConfig]=\"accessibilityConfig\"\n                 [images]=\"images\"\n                 (clickDot)=\"onClickDot($event)\"></ks-dots>\n      </div>\n\n    </div>\n  </ng-template>\n\n</main>\n\n<ks-carousel-previews [images]=\"images\"\n                      [currentImage]=\"currentImage\"\n                      [carouselConfig]=\"configCarousel\"\n                      [previewConfig]=\"previewConfig\"\n                      [accessibilityConfig]=\"accessibilityConfig\"\n                      (clickPreview)=\"onClickPreview($event)\"></ks-carousel-previews>\n\n<ks-modal-gallery [id]=\"id\" [modalImages]=\"images\" [plainGalleryConfig]=\"plainGalleryHidden\"></ks-modal-gallery>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [":host{display:flex;flex-direction:column;justify-content:flex-start;align-items:center}#carousel-container{display:flex;flex-direction:row;align-items:center;justify-content:space-between;width:100%}#carousel-container>.current-figure{-webkit-animation:.8s fadein-visible;animation:.8s fadein-visible;text-align:center;margin:0;position:relative}#carousel-container>.current-figure .nav,#carousel-container>.current-figure>.nav-left,#carousel-container>.current-figure>.nav-right{-webkit-animation:1s animatezoom;animation:1s animatezoom;cursor:pointer;transition:.5s;top:50%;position:absolute}#carousel-container>.current-figure .nav:hover,#carousel-container>.current-figure>.nav-left:hover,#carousel-container>.current-figure>.nav-right:hover{transform:scale(1.1)}#carousel-container>.current-figure>.nav-left{left:5px}#carousel-container>.current-figure>.nav-right{right:5px}#carousel-container>.current-figure>#current-image,#carousel-container>.current-figure>#current-image-legacy{width:100%;height:auto;display:block}#carousel-container>.current-figure>#current-image-legacy>.description-ie11{bottom:0;width:100%;position:absolute;padding-top:10px;padding-bottom:10px}#carousel-container>.current-figure>figcaption{padding:10px;position:absolute;bottom:0;left:0;right:0}#carousel-container>.current-figure>figcaption .description{font-weight:700;text-align:center}#carousel-container>.current-figure>#dots,#carousel-container>.current-figure>#dots-ie11{position:absolute;bottom:20px;width:100%}", ".arrow-image,.empty-arrow-image,.left-arrow-image,.right-arrow-image{width:30px;height:30px;background-size:30px}.empty-arrow-image{background:#000;opacity:0}.left-arrow-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.left-arrow-image:hover{transform:scale(1.2)}.right-arrow-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);opacity:.8;transition:.5s}.right-arrow-image:hover{transform:scale(1.2)}"]
          }]
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.PLATFORM_ID]
            }]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgZone
          }, {
            type: _GalleryService
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }, {
            type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer
          }];
        }, {
          ariaLabel: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
            args: ['attr.aria-label']
          }],
          dotsConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          infinite: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          show: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          firstImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          lastImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],

          /**
           * Listener to stop the gallery when the mouse pointer is over the current image.
           * @return {?}
           */
          onMouseEnter: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['mouseenter']
          }],

          /**
           * Listener to play the gallery when the mouse pointer leave the current image.
           * @return {?}
           */
          onMouseLeave: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['mouseleave']
          }],

          /**
           * Listener to navigate carousel images with keyboard (left).
           * @return {?}
           */
          onKeyDownLeft: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['keydown.arrowLeft']
          }],

          /**
           * Listener to navigate carousel images with keyboard (right).
           * @return {?}
           */
          onKeyDownLRight: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostListener,
            args: ['keydown.arrowRight']
          }],
          id: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          carouselConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          playConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          carouselImageConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          previewConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with image previews for carousel
       */


      var CarouselPreviewsComponent = /*#__PURE__*/function (_AccessibleComponent3) {
        _inherits(CarouselPreviewsComponent, _AccessibleComponent3);

        var _super4 = _createSuper(CarouselPreviewsComponent);

        /**
         * @param {?} ref
         * @param {?} breakpointObserver
         * @param {?} sanitizer
         */
        function CarouselPreviewsComponent(ref, breakpointObserver, sanitizer) {
          var _this11;

          _classCallCheck(this, CarouselPreviewsComponent);

          _this11 = _super4.call(this);
          _this11.ref = ref;
          _this11.breakpointObserver = breakpointObserver;
          _this11.sanitizer = sanitizer;
          /**
           * Variable to change the max-width of the host component
           */

          _this11.hostMaxWidth = '100%';
          /**
           * Variable to set aria-label of the host component
           */

          _this11.ariaLabel = "Carousel previews";
          /**
           * Output to emit the clicked preview. The payload contains the `InternalLibImage` associated to the clicked preview.
           */

          _this11.clickPreview = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Enum of type `Action` that represents a mouse click on a button.
           * Declared here to be used inside the template.
           */

          _this11.clickAction = _Action.CLICK;
          /**
           * Enum of type `Action` that represents a keyboard action.
           * Declared here to be used inside the template.
           */

          _this11.keyboardAction = _Action.KEYBOARD;
          /**
           * Array of `InternalLibImage` exposed to the template. This field is initialized
           * applying transformations, default values and so on to the input of the same type.
           */

          _this11.previews = [];
          /**
           * Private property with the default max height of previews.
           */

          _this11.defaultMaxHeight = '200px'; // listen for width changes and update preview heights accordingly

          _this11.breakpointSubscription = breakpointObserver.observe([_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XSmall, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Small, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Medium, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Large, _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XLarge]).subscribe(
          /**
          * @param {?} result
          * @return {?}
          */
          function (result) {
            if (!_this11.configPreview) {
              return;
            }

            if (result.breakpoints[_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XSmall]) {
              _this11.updateHeight(_this11.configPreview.breakpoints.xSmall);
            } else if (result.breakpoints[_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Small]) {
              _this11.updateHeight(_this11.configPreview.breakpoints.small);
            } else if (result.breakpoints[_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Medium]) {
              _this11.updateHeight(_this11.configPreview.breakpoints.medium);
            } else if (result.breakpoints[_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Large]) {
              _this11.updateHeight(_this11.configPreview.breakpoints.large);
            } else if (result.breakpoints[_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XLarge]) {
              _this11.updateHeight(_this11.configPreview.breakpoints.xLarge);
            }
          });
          return _this11;
        }
        /**
         * Method to update the height of previews, passing the desired height as input.
         * @private
         * @param {?} configBreakpointHeight is a number that represent the desired height to set.
         * @return {?}
         */


        _createClass(CarouselPreviewsComponent, [{
          key: "updateHeight",
          value: function updateHeight(configBreakpointHeight) {
            /** @type {?} */
            var newConfigPreview = Object.assign({}, this.configPreview);

            if (this.previewConfig && this.previewConfig.maxHeight) {
              /** @type {?} */
              var heightNum = +this.previewConfig.maxHeight.replace('px', '').replace('%', '');
              newConfigPreview.maxHeight = Math.min(configBreakpointHeight, heightNum) + 'px';
            } else {
              /** @type {?} */
              var _heightNum = +this.defaultMaxHeight.replace('px', '').replace('%', '');

              newConfigPreview.maxHeight = Math.min(configBreakpointHeight, _heightNum) + 'px';
            }

            this.configPreview = newConfigPreview;
            this.ref.markForCheck();
          }
          /**
           * Method ´ngOnInit´ to build `configPreview` applying a default value and also to
           * init the `previews` array.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called only one time!!!
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            /** @type {?} */
            var defaultBreakpoints = {
              xSmall: 100,
              small: 100,
              medium: 150,
              large: 200,
              xLarge: 200
            };
            /** @type {?} */

            var defaultPreviewConfig = {
              visible: true,
              number: 4,
              arrows: true,
              clickable: true,
              width: 100 / 4 + '%',
              maxHeight: this.defaultMaxHeight,
              breakpoints: defaultBreakpoints
            };
            this.configPreview = Object.assign({}, defaultPreviewConfig, this.previewConfig); // if number is <= 0 reset to default

            if (this.configPreview && this.configPreview.number <= 0) {
              this.configPreview.number = defaultPreviewConfig.number;
            } // Init preview image width based on the number of previews in PreviewConfig
            // Don't move this line above, because I need to be sure that both configPreview.number
            // and configPreview.size are initialized


            this.configPreview.width = 100 / this.configPreview.number + '%'; // change the max-width of this component if there is a specified width !== 100% in carouselConfig

            if (this.carouselConfig && this.carouselConfig.maxWidth !== '100%') {
              this.hostMaxWidth = this.carouselConfig.maxWidth;
            } // init previews based on currentImage and the full array of images


            this.initPreviews(this.currentImage, this.images); // apply custom height based on responsive breakpoints
            // This is required, because the breakpointSubscription is not triggered at creation,
            // but only when the width changes

            /** @type {?} */

            var isXsmallScreen = this.breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XSmall);
            /** @type {?} */

            var isSmallScreen = this.breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Small);
            /** @type {?} */

            var isMediumScreen = this.breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Medium);
            /** @type {?} */

            var isLargeScreen = this.breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.Large);
            /** @type {?} */

            var isxLargeScreen = this.breakpointObserver.isMatched(_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.Breakpoints.XLarge);

            if (isXsmallScreen) {
              this.updateHeight(this.configPreview.breakpoints.xSmall);
            } else if (isSmallScreen) {
              this.updateHeight(this.configPreview.breakpoints.small);
            } else if (isMediumScreen) {
              this.updateHeight(this.configPreview.breakpoints.medium);
            } else if (isLargeScreen) {
              this.updateHeight(this.configPreview.breakpoints.large);
            } else if (isxLargeScreen) {
              this.updateHeight(this.configPreview.breakpoints.xLarge);
            }
          }
          /**
           * Method to check if an image is active (i.e. a preview image).
           * @param {?} preview
           * @return {?} boolean true if is active, false otherwise
           */

        }, {
          key: "isActive",
          value: function isActive(preview) {
            if (!preview || !this.currentImage) {
              return false;
            }

            return preview.id === this.currentImage.id;
          }
          /**
           * Method ´ngOnChanges´ to update `previews` array.
           * Also, both `start` and `end` local variables will be updated accordingly.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @param {?} changes
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            var _this12 = this;

            /** @type {?} */
            var simpleChange = changes.currentImage;

            if (!simpleChange) {
              return;
            }
            /** @type {?} */


            var prev = simpleChange.previousValue;
            /** @type {?} */

            var current = simpleChange.currentValue;

            if (current && changes.images && changes.images.previousValue && changes.images.currentValue) {
              // I'm in this if statement, if input images are changed (for instance, because I removed one of them with the 'delete button',
              // or because users changed the images array while modal gallery is still open).
              // In this case, I have to re-init previews, because the input array of images is changed.
              this.initPreviews(current, changes.images.currentValue);
            }

            if (prev && current && prev.id !== current.id) {
              // to manage infinite sliding I have to reset both `start` and `end` at the beginning
              // to show again previews from the first image.
              // This happens when you navigate over the last image to return to the first one

              /** @type {?} */
              var prevIndex;
              /** @type {?} */

              var currentIndex;

              try {
                prevIndex = getIndex(prev, this.images);
                currentIndex = getIndex(current, this.images);
              } catch (err) {
                console.error('Cannot get previous and current image indexes in previews');
                throw err;
              } // apply a formula to get a values to be used to decide if go next, return back or stay without doing anything

              /** @type {?} */


              var calc = Math.floor((this.end - this.start) / 2) + this.start;

              if (prevIndex === this.images.length - 1 && currentIndex === 0) {
                // first image
                this.setBeginningIndexesPreviews();
                this.previews = this.images.filter(
                /**
                * @param {?} img
                * @param {?} i
                * @return {?}
                */
                function (img, i) {
                  return i >= _this12.start && i < _this12.end;
                });
                return;
              } // the same for the opposite case, when you navigate back from the fist image to go to the last one.


              if (prevIndex === 0 && currentIndex === this.images.length - 1) {
                // last image
                this.setEndIndexesPreviews();
                this.previews = this.images.filter(
                /**
                * @param {?} img
                * @param {?} i
                * @return {?}
                */
                function (img, i) {
                  return i >= _this12.start && i < _this12.end;
                });
                return;
              }

              if (this.configPreview.number % 2 === 0) {
                if (calc > currentIndex) {
                  this.previous();
                } else {
                  this.next();
                }
              } else {
                if (calc > currentIndex) {
                  this.previous();
                }

                if (calc < currentIndex) {
                  this.next();
                }
              }
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a preview.
           * This will trigger the `clickpreview` output with the input preview as its payload.
           * @param {?} preview
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onImageEvent",
          value: function onImageEvent(preview, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.NORMAL;

            if (!this.configPreview || !this.configPreview.clickable) {
              return;
            }
            /** @type {?} */


            var clickedImageIndex = this.images.indexOf(preview);
            /** @type {?} */

            var result = _get(_getPrototypeOf(CarouselPreviewsComponent.prototype), "handleImageEvent", this).call(this, event);

            if (result === NEXT) {
              this.clickPreview.emit({
                action: action,
                result: clickedImageIndex
              });
            } else if (result === PREV) {
              this.clickPreview.emit({
                action: action,
                result: clickedImageIndex
              });
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a navigation arrow.
           * @param {?} direction
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onNavigationEvent",
          value: function onNavigationEvent(direction, event) {
            /** @type {?} */
            var result = _get(_getPrototypeOf(CarouselPreviewsComponent.prototype), "handleNavigationEvent", this).call(this, direction, event);

            if (result === NEXT) {
              this.next();
            } else if (result === PREV) {
              this.previous();
            }
          }
          /**
           * Method to get aria-label text for a preview image.
           * @param {?} preview
           * @return {?}
           */

        }, {
          key: "getAriaLabel",
          value: function getAriaLabel(preview) {
            if (!preview.plain) {
              return preview.modal.ariaLabel || '';
            }

            return preview.plain.ariaLabel || preview.modal.ariaLabel || '';
          }
          /**
           * Method to get title text for a preview image.
           * @param {?} preview
           * @return {?}
           */

        }, {
          key: "getTitle",
          value: function getTitle(preview) {
            if (!preview.plain) {
              return preview.modal.title || '';
            }

            return preview.plain.title || preview.modal.title || '';
          }
          /**
           * Method to get alt text for a preview image.
           * @param {?} preview
           * @return {?}
           */

        }, {
          key: "getAlt",
          value: function getAlt(preview) {
            if (!preview.plain) {
              return preview.modal.alt || '';
            }

            return preview.plain.alt || preview.modal.alt || '';
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item.id;
          }
          /**
           * Method used in template to sanitize an url when you need legacyIE11Mode.
           * In this way you can set an url as background of a div.
           * @param {?} unsafeStyle is a string and represents the url to sanitize.
           * @return {?} a SafeStyle object that can be used in template without problems.
           */

        }, {
          key: "sanitizeUrlBgStyle",
          value: function sanitizeUrlBgStyle(unsafeStyle) {
            // Method used only to sanitize background-image style before add it to background property when legacyIE11Mode is enabled
            return this.sanitizer.bypassSecurityTrustStyle('url(' + unsafeStyle + ')');
          }
          /**
           * Method to get the background-size value when IE11LegacyMode is enabled.
           * This prevent weired behaviour on IE11 when previews are really small, but original images (.png/.jgp/...) are big.
           * Using 'cover' it's not enough, because it's causing empty background in some cases.
           * After some experiments, I decided to use the double of the height and auto as width.
           * @return {?}
           */

        }, {
          key: "getIE11LegacyBgSize",
          value: function getIE11LegacyBgSize() {
            if (this.configPreview && this.configPreview.maxHeight) {
              /** @type {?} */
              var bgHeight = +this.configPreview.maxHeight.replace('px', '');
              return '100% ' + bgHeight * 2 + 'px';
            }

            return 'cover';
          }
          /**
           * Method to cleanup resources. In fact, it cleans breakpointSubscription.
           * This is an Angular's lifecycle hook that is called when this component is destroyed.
           * @return {?}
           */

        }, {
          key: "ngOnDestroy",
          value: function ngOnDestroy() {
            if (this.breakpointSubscription) {
              this.breakpointSubscription.unsubscribe();
            }
          }
          /**
           * Private method to init previews based on the currentImage and the full array of images.
           * The current image in mandatory to show always the current preview (as highlighted).
           * @private
           * @param {?} currentImage
           * @param {?} images
           * @return {?}
           */

        }, {
          key: "initPreviews",
          value: function initPreviews(currentImage, images) {
            var _this13 = this;

            /** @type {?} */
            var index;

            try {
              index = getIndex(currentImage, images);
            } catch (err) {
              throw err;
            }

            switch (index) {
              case 0:
                // first image
                this.setBeginningIndexesPreviews();
                break;

              case images.length - 1:
                // last image
                this.setEndIndexesPreviews();
                break;
              // default:
              //   // other images
              //   // TODO unused because it starts always at image 0
              //   this.setIndexesPreviews();
              //   break;
            }

            this.previews = images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this13.start && i < _this13.end;
            });
          }
          /**
           * Private method to init both `start` and `end` to the beginning.
           * @private
           * @return {?}
           */

        }, {
          key: "setBeginningIndexesPreviews",
          value: function setBeginningIndexesPreviews() {
            this.start = 0;
            this.end = Math.min(this.configPreview.number, this.images.length);
          }
          /**
           * Private method to init both `start` and `end` to the end.
           * @private
           * @return {?}
           */

        }, {
          key: "setEndIndexesPreviews",
          value: function setEndIndexesPreviews() {
            this.start = this.images.length - 1 - (this.configPreview.number - 1);
            this.end = this.images.length;
          }
          /**
           * Private method to update the visible previews navigating to the right (next).
           * @private
           * @return {?}
           */

        }, {
          key: "next",
          value: function next() {
            var _this14 = this;

            // check if nextImage should be blocked
            if (this.isPreventSliding(this.images.length - 1)) {
              return;
            }

            if (this.end === this.images.length) {
              return;
            }

            this.start++;
            this.end = Math.min(this.end + 1, this.images.length);
            this.previews = this.images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this14.start && i < _this14.end;
            });
          }
          /**
           * Private method to update the visible previews navigating to the left (previous).
           * @private
           * @return {?}
           */

        }, {
          key: "previous",
          value: function previous() {
            var _this15 = this;

            // check if prevImage should be blocked
            if (this.isPreventSliding(0)) {
              return;
            }

            if (this.start === 0) {
              return;
            }

            this.start = Math.max(this.start - 1, 0);
            this.end = Math.min(this.end - 1, this.images.length);
            this.previews = this.images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this15.start && i < _this15.end;
            });
          }
          /**
           * Private method to block/permit sliding between previews.
           * @private
           * @param {?} boundaryIndex
           * @return {?} boolean if true block sliding, otherwise not
           */

        }, {
          key: "isPreventSliding",
          value: function isPreventSliding(boundaryIndex) {
            return getIndex(this.currentImage, this.images) === boundaryIndex;
          }
        }]);

        return CarouselPreviewsComponent;
      }(AccessibleComponent);

      CarouselPreviewsComponent.ɵfac = function CarouselPreviewsComponent_Factory(t) {
        return new (t || CarouselPreviewsComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.BreakpointObserver), _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdirectiveInject"](_angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer));
      };

      CarouselPreviewsComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: CarouselPreviewsComponent,
        selectors: [["ks-carousel-previews"]],
        hostVars: 3,
        hostBindings: function CarouselPreviewsComponent_HostBindings(rf, ctx) {
          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.ariaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵstyleProp"]("max-width", ctx.hostMaxWidth);
          }
        },
        inputs: {
          carouselConfig: "carouselConfig",
          currentImage: "currentImage",
          images: "images",
          previewConfig: "previewConfig",
          accessibilityConfig: "accessibilityConfig"
        },
        outputs: {
          clickPreview: "clickPreview"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 1,
        vars: 1,
        consts: [["class", "previews-container", 3, "title", 4, "ngIf"], [1, "previews-container", 3, "title"], ["role", "button", 1, "nav-left", 3, "tabindex", "click", "keyup"], ["aria-hidden", "true", 3, "title"], [1, "preview-inner-container"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", 1, "nav-right", 3, "tabindex", "click", "keyup"], [4, "ngIf", "ngIfElse"], ["legacyMode", ""], ["ksSize", "", "role", "img", 3, "class", "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup", 4, "ngIf"], ["ksSize", "", "role", "img", 3, "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup"], ["ksSize", "", "role", "img", 3, "class", "background-color", "background-image", "background-position", "background-size", "background-repeat", "background-attachment", "sizeConfig", "title", "tabindex", "click", "keyup", 4, "ngIf"], ["ksSize", "", "role", "img", 3, "sizeConfig", "title", "tabindex", "click", "keyup"]],
        template: function CarouselPreviewsComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, CarouselPreviewsComponent_nav_0_Template, 7, 16, "nav", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.configPreview == null ? null : ctx.configPreview.visible);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, SizeDirective],
        styles: ["[_nghost-%COMP%]{position:relative;margin-top:3px;margin-bottom:3px;width:100%}.previews-container[_ngcontent-%COMP%]{align-items:center;-webkit-animation:.8s fadein-semi-visible08;animation:.8s fadein-semi-visible08;display:flex;flex-direction:row;justify-content:center;margin-bottom:0}.previews-container[_ngcontent-%COMP%] > .preview-inner-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center;align-items:center;flex-wrap:nowrap;width:100%}.previews-container[_ngcontent-%COMP%] > .preview-inner-container[_ngcontent-%COMP%] > .preview-image[_ngcontent-%COMP%]{cursor:pointer;-o-object-fit:cover;object-fit:cover}.previews-container[_ngcontent-%COMP%] > .preview-inner-container[_ngcontent-%COMP%] > .preview-image.unclickable[_ngcontent-%COMP%]{cursor:not-allowed}.previews-container[_ngcontent-%COMP%] > .preview-inner-container[_ngcontent-%COMP%] > .preview-ie11-image[_ngcontent-%COMP%]{cursor:pointer}.previews-container[_ngcontent-%COMP%] > .preview-inner-container[_ngcontent-%COMP%] > .preview-ie11-image.unclickable[_ngcontent-%COMP%]{cursor:not-allowed}.previews-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{position:absolute;top:calc(50% - 7px);color:#919191;z-index:1000;cursor:pointer;transition:.5s}.previews-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%]:hover, .previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]:hover, .previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]:hover{transform:scale(1.1)}.previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]{margin-right:10px;left:10px}.previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%] > .left-arrow-preview-image[_ngcontent-%COMP%]{opacity:1}.previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{margin-left:10px;right:10px}.previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%] > .right-arrow-preview-image[_ngcontent-%COMP%]{opacity:1}", _c10],
        changeDetection: 0
      });
      /** @nocollapse */

      CarouselPreviewsComponent.ctorParameters = function () {
        return [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
        }, {
          type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.BreakpointObserver
        }, {
          type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer
        }];
      };

      CarouselPreviewsComponent.propDecorators = {
        hostMaxWidth: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
          args: ['style.max-width']
        }],
        ariaLabel: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
          args: ['attr.aria-label']
        }],
        carouselConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        currentImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        previewConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        clickPreview: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](CarouselPreviewsComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-carousel-previews',
            template: "<nav *ngIf=\"configPreview?.visible\"\n     class=\"previews-container\"\n     [attr.aria-label]=\"accessibilityConfig?.carouselPreviewsContainerAriaLabel\"\n     [title]=\"accessibilityConfig?.carouselPreviewsContainerTitle\">\n\n  <a class=\"nav-left\"\n     [attr.aria-label]=\"accessibilityConfig?.carouselPreviewScrollPrevAriaLabel\"\n     [tabindex]=\"configPreview.arrows && start > 0 ? 0 : -1\" role=\"button\"\n     (click)=\"onNavigationEvent('left', $event)\" (keyup)=\"onNavigationEvent('left', $event)\">\n    <div class=\"inside {{configPreview.arrows && start > 0 ? 'left-arrow-preview-image' : 'empty-arrow-preview-image'}}\"\n         aria-hidden=\"true\"\n         [title]=\"accessibilityConfig?.carouselPreviewScrollPrevTitle\"></div>\n  </a>\n\n  <div class=\"preview-inner-container\">\n    <ng-container *ngFor=\"let preview of previews; trackBy: trackById; let index = index\">\n      <ng-container *ngIf=\"!carouselConfig?.legacyIE11Mode; else legacyMode\">\n        <img *ngIf=\"preview?.modal?.img\"\n             class=\"inside preview-image{{isActive(preview) ? ' active' : ''}}{{!configPreview.clickable ? ' unclickable' : ''}}\"\n             [src]=\"preview.plain?.img ? preview.plain.img : preview.modal.img\"\n             ksSize [sizeConfig]=\"{width: configPreview?.width,\n                                 height: configPreview?.maxHeight}\"\n             [attr.aria-label]=\"getAriaLabel(preview)\"\n             [title]=\"getTitle(preview)\"\n             alt=\"{{getAlt(preview)}}\"\n             [tabindex]=\"0\" role=\"img\"\n             (click)=\"onImageEvent(preview, $event, clickAction)\" (keyup)=\"onImageEvent(preview, $event, keyboardAction)\"/>\n      </ng-container>\n      <ng-template #legacyMode>\n        <div *ngIf=\"preview?.modal?.img\"\n             class=\"inside preview-ie11-image{{isActive(preview) ? ' active' : ''}}{{!configPreview.clickable ? ' unclickable' : ''}}\"\n             [style.background-color]=\"'transparent'\"\n             [style.background-image]=\"sanitizeUrlBgStyle(preview.plain?.img ? preview.plain.img : preview.modal.img)\"\n             [style.background-position]=\"'center center'\"\n             [style.background-size]=\"getIE11LegacyBgSize()\"\n             [style.background-repeat]=\"'no-repeat'\"\n             [style.background-attachment]=\"'scroll'\"\n             ksSize [sizeConfig]=\"{width: configPreview?.width,\n                                 height: configPreview?.maxHeight}\"\n             [attr.aria-label]=\"getAriaLabel(preview)\"\n             [title]=\"getTitle(preview)\"\n             [tabindex]=\"0\" role=\"img\"\n             (click)=\"onImageEvent(preview, $event, clickAction)\" (keyup)=\"onImageEvent(preview, $event, keyboardAction)\"></div>\n      </ng-template>\n    </ng-container>\n  </div>\n\n  <a class=\"nav-right\"\n     [attr.aria-label]=\"accessibilityConfig?.carouselPreviewScrollNextAriaLabel\"\n     [tabindex]=\"configPreview.arrows && end < images.length ? 0 : -1\" role=\"button\"\n     (click)=\"onNavigationEvent('right', $event)\" (keyup)=\"onNavigationEvent('right', $event)\">\n    <div class=\"inside {{configPreview.arrows && end < images.length ? 'right-arrow-preview-image' : 'empty-arrow-preview-image'}}\"\n         aria-hidden=\"true\"\n         [title]=\"accessibilityConfig?.carouselPreviewScrollNextTitle\"></div>\n  </a>\n\n</nav>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [":host{position:relative;margin-top:3px;margin-bottom:3px;width:100%}.previews-container{align-items:center;-webkit-animation:.8s fadein-semi-visible08;animation:.8s fadein-semi-visible08;display:flex;flex-direction:row;justify-content:center;margin-bottom:0}.previews-container>.preview-inner-container{display:flex;flex-direction:row;justify-content:center;align-items:center;flex-wrap:nowrap;width:100%}.previews-container>.preview-inner-container>.preview-image{cursor:pointer;-o-object-fit:cover;object-fit:cover}.previews-container>.preview-inner-container>.preview-image.unclickable{cursor:not-allowed}.previews-container>.preview-inner-container>.preview-ie11-image{cursor:pointer}.previews-container>.preview-inner-container>.preview-ie11-image.unclickable{cursor:not-allowed}.previews-container .nav,.previews-container>.nav-left,.previews-container>.nav-right{position:absolute;top:calc(50% - 7px);color:#919191;z-index:1000;cursor:pointer;transition:.5s}.previews-container .nav:hover,.previews-container>.nav-left:hover,.previews-container>.nav-right:hover{transform:scale(1.1)}.previews-container>.nav-left{margin-right:10px;left:10px}.previews-container>.nav-left>.left-arrow-preview-image{opacity:1}.previews-container>.nav-right{margin-left:10px;right:10px}.previews-container>.nav-right>.right-arrow-preview-image{opacity:1}", ".arrow-preview-image,.empty-arrow-preview-image,.left-arrow-preview-image,.right-arrow-preview-image{width:15px;height:15px;opacity:.5}.empty-arrow-preview-image{background:#000;opacity:0}.left-arrow-preview-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.left-arrow-preview-image:hover{transform:scale(1.2)}.right-arrow-preview-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.right-arrow-preview-image:hover{transform:scale(1.2)}"]
          }]
        }], function () {
          return [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectorRef
          }, {
            type: _angular_cdk_layout__WEBPACK_IMPORTED_MODULE_9__.BreakpointObserver
          }, {
            type: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.DomSanitizer
          }];
        }, {
          hostMaxWidth: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
            args: ['style.max-width']
          }],
          ariaLabel: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.HostBinding,
            args: ['attr.aria-label']
          }],
          clickPreview: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          carouselConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          currentImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          previewConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /** @enum {number} */


      var _ButtonsStrategy = {
        // don't use 0 here
        // the first index is 1 and all of the following members are auto-incremented from that point on
        DEFAULT: 1,
        SIMPLE: 2,
        ADVANCED: 3,
        FULL: 4,
        CUSTOM: 5
      };
      _ButtonsStrategy[_ButtonsStrategy.DEFAULT] = 'DEFAULT';
      _ButtonsStrategy[_ButtonsStrategy.SIMPLE] = 'SIMPLE';
      _ButtonsStrategy[_ButtonsStrategy.ADVANCED] = 'ADVANCED';
      _ButtonsStrategy[_ButtonsStrategy.FULL] = 'FULL';
      _ButtonsStrategy[_ButtonsStrategy.CUSTOM] = 'CUSTOM';
      /** @enum {number} */

      var _ButtonType = {
        // don't use 0 here
        // the first index is 1 and all of the following members are auto-incremented from that point on
        // REFRESH = 1,
        DELETE: 1,
        EXTURL: 2,
        DOWNLOAD: 3,
        CLOSE: 4,
        CUSTOM: 5,
        FULLSCREEN: 6 // ROTATE

      };
      _ButtonType[_ButtonType.DELETE] = 'DELETE';
      _ButtonType[_ButtonType.EXTURL] = 'EXTURL';
      _ButtonType[_ButtonType.DOWNLOAD] = 'DOWNLOAD';
      _ButtonType[_ButtonType.CLOSE] = 'CLOSE';
      _ButtonType[_ButtonType.CUSTOM] = 'CUSTOM';
      _ButtonType[_ButtonType.FULLSCREEN] = 'FULLSCREEN';
      /**
       * Array of admitted types of buttons.
       * @type {?}
       */

      var WHITELIST_BUTTON_TYPES = [// ButtonType.REFRESH,
      _ButtonType.FULLSCREEN, _ButtonType.DELETE, _ButtonType.EXTURL, _ButtonType.DOWNLOAD, _ButtonType.CLOSE, _ButtonType.CUSTOM // ButtonType.ROTATE
      ];
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Default button size object
       * @type {?}
       */

      var _KS_DEFAULT_SIZE = {
        height: 'auto',
        width: '30px'
      };
      /**
       * Default close button object
       * @type {?}
       */

      var _KS_DEFAULT_BTN_CLOSE = {
        className: 'close-image',
        size: _KS_DEFAULT_SIZE,
        type: _ButtonType.CLOSE,
        title: 'Close this modal image gallery',
        ariaLabel: 'Close this modal image gallery'
      };
      /**
       * Default download button object
       * @type {?}
       */

      var _KS_DEFAULT_BTN_DOWNLOAD = {
        className: 'download-image',
        size: _KS_DEFAULT_SIZE,
        type: _ButtonType.DOWNLOAD,
        title: 'Download the current image',
        ariaLabel: 'Download the current image'
      };
      /**
       * Default exturl button object
       * @type {?}
       */

      var _KS_DEFAULT_BTN_EXTURL = {
        className: 'ext-url-image',
        size: _KS_DEFAULT_SIZE,
        type: _ButtonType.EXTURL,
        title: 'Navigate the current image',
        ariaLabel: 'Navigate the current image'
      }; // /**
      //  * Default refresh button object
      //  */
      // export const KS_DEFAULT_BTN_REFRESH: ButtonConfig = {
      //   className: 'refresh-image',
      //   size: KS_DEFAULT_SIZE,
      //   type: ButtonType.REFRESH,
      //   title: 'Refresh all images',
      //   ariaLabel: 'Refresh all images'
      // };

      /**
       * Default delete button object
       * @type {?}
       */

      var _KS_DEFAULT_BTN_DELETE = {
        className: 'delete-image',
        size: _KS_DEFAULT_SIZE,
        type: _ButtonType.DELETE,
        title: 'Delete the current image',
        ariaLabel: 'Delete the current image'
      };
      /**
       * Default full-screen button object
       * @type {?}
       */

      var _KS_DEFAULT_BTN_FULL_SCREEN = {
        className: 'fullscreen-image',
        size: _KS_DEFAULT_SIZE,
        type: _ButtonType.FULLSCREEN,
        title: 'Switch to full-screen',
        ariaLabel: 'Switch to full-screen'
      };
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with all upper buttons.
       * Also it emits click events as outputs.
       */

      var UpperButtonsComponent = /*#__PURE__*/function (_AccessibleComponent4) {
        _inherits(UpperButtonsComponent, _AccessibleComponent4);

        var _super5 = _createSuper(UpperButtonsComponent);

        function UpperButtonsComponent() {
          var _this16;

          _classCallCheck(this, UpperButtonsComponent);

          _this16 = _super5.apply(this, arguments);
          /**
           * Output to emit clicks on refresh button. The payload contains a `ButtonEvent`.
           */

          _this16.refresh = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit clicks on delete button. The payload contains a `ButtonEvent`.
           */

          _this16["delete"] = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit clicks on navigate button. The payload contains a `ButtonEvent`.
           */

          _this16.navigate = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit clicks on download button. The payload contains a `ButtonEvent`.
           */

          _this16.download = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit clicks on close button. The payload contains a `ButtonEvent`.
           */

          _this16.close = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Output to emit clicks on full-screen button. The payload contains a `ButtonEvent`.
           */

          _this16.fullscreen = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(); // /**
          //  * Output to emit clicks on rotate button. The payload contains a `ButtonEvent`.
          //  */
          // @Output()
          // rotate: EventEmitter<ButtonEvent> = new EventEmitter<ButtonEvent>();

          /**
           * Output to emit clicks on all custom buttons. The payload contains a `ButtonEvent`.
           */

          _this16.customEmit = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Default buttons array for standard configuration
           */

          _this16.defaultButtonsDefault = [_KS_DEFAULT_BTN_CLOSE];
          /**
           * Default buttons array for simple configuration
           */

          _this16.simpleButtonsDefault = [_KS_DEFAULT_BTN_DOWNLOAD].concat(_toConsumableArray(_this16.defaultButtonsDefault));
          /**
           * Default buttons array for advanced configuration
           */

          _this16.advancedButtonsDefault = [_KS_DEFAULT_BTN_EXTURL].concat(_toConsumableArray(_this16.simpleButtonsDefault));
          /**
           * Default buttons array for full configuration
           */

          _this16.fullButtonsDefault = [
          /*KS_DEFAULT_BTN_REFRESH, */
          _KS_DEFAULT_BTN_FULL_SCREEN, _KS_DEFAULT_BTN_DELETE].concat(_toConsumableArray(_this16.advancedButtonsDefault));
          return _this16;
        }
        /**
         * Method ´ngOnInit´ to build `configButtons` applying a default value and also to
         * init the `buttons` array.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(UpperButtonsComponent, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            /** @type {?} */
            var defaultConfig = {
              visible: true,
              strategy: _ButtonsStrategy.DEFAULT
            };
            this.configButtons = Object.assign(defaultConfig, this.buttonsConfig);

            switch (this.configButtons.strategy) {
              case _ButtonsStrategy.SIMPLE:
                this.buttons = this.addButtonIds(this.simpleButtonsDefault);
                break;

              case _ButtonsStrategy.ADVANCED:
                this.buttons = this.addButtonIds(this.advancedButtonsDefault);
                break;

              case _ButtonsStrategy.FULL:
                this.buttons = this.addButtonIds(this.fullButtonsDefault);
                break;

              case _ButtonsStrategy.CUSTOM:
                this.buttons = this.addButtonIds(this.validateCustomButtons(this.configButtons.buttons));
                break;

              case _ButtonsStrategy.DEFAULT:
              default:
                this.buttons = this.addButtonIds(this.defaultButtonsDefault);
                break;
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a button.
           * This will call a private method to trigger an output with the right payload.
           * @throws an error if the button type is unknown
           * @param {?} button
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onEvent",
          value: function onEvent(button, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.CLICK;

            if (!event) {
              return;
            }
            /** @type {?} */


            var dataToEmit = {
              button: button,
              // current image initialized as null
              // (I'll fill this value inside the parent of this component
              image: null,
              action: action
            };

            switch (button.type) {
              // case ButtonType.REFRESH:
              //   this.triggerOnMouseAndKeyboard(this.refresh, event, dataToEmit);
              //   break;
              case _ButtonType.DELETE:
                this.triggerOnMouseAndKeyboard(this["delete"], event, dataToEmit);
                break;

              case _ButtonType.EXTURL:
                if (!this.currentImage || !this.currentImage.modal || !this.currentImage.modal.extUrl) {
                  return;
                }

                this.triggerOnMouseAndKeyboard(this.navigate, event, dataToEmit);
                break;

              case _ButtonType.DOWNLOAD:
                this.triggerOnMouseAndKeyboard(this.download, event, dataToEmit);
                break;

              case _ButtonType.CLOSE:
                this.triggerOnMouseAndKeyboard(this.close, event, dataToEmit);
                break;

              case _ButtonType.CUSTOM:
                this.triggerOnMouseAndKeyboard(this.customEmit, event, dataToEmit);
                break;

              case _ButtonType.FULLSCREEN:
                this.triggerOnMouseAndKeyboard(this.fullscreen, event, dataToEmit);
                break;
              // case ButtonType.ROTATE:
              //   this.triggerOnMouseAndKeyboard(this.rotate, event, dataToEmit);
              //   break;

              default:
                throw new Error("Unknown button's type into ButtonConfig");
            }
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item or undefined if the item is not valid
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item ? item.id : undefined;
          }
          /**
           * Private method to emit an event using the specified output as an `EventEmitter`.
           * @private
           * @param {?} emitter
           * @param {?} event
           * @param {?} dataToEmit
           * @return {?}
           */

        }, {
          key: "triggerOnMouseAndKeyboard",
          value: function triggerOnMouseAndKeyboard(emitter, event, dataToEmit) {
            if (!emitter) {
              throw new Error("UpperButtonsComponent unknown emitter in triggerOnMouseAndKeyboard");
            }
            /** @type {?} */


            var result = _get(_getPrototypeOf(UpperButtonsComponent.prototype), "handleImageEvent", this).call(this, event);

            if (result === NEXT) {
              emitter.emit(dataToEmit);
            }
          }
          /**
           * Private method to add ids to the array of buttons.
           * It adds ids in a reverse way, to be sure that the last button will always have id = 0.
           * This is really useful in unit testing to be sure that close button always have id = 0, download 1 and so on...
           * It's totally transparent to the user.
           * @private
           * @param {?} buttons
           * @return {?} ButtonConfig[] the input array with incremental numeric ids
           */

        }, {
          key: "addButtonIds",
          value: function addButtonIds(buttons) {
            return buttons.map(
            /**
            * @param {?} val
            * @param {?} i
            * @return {?}
            */
            function (val, i) {
              return Object.assign(val, {
                id: buttons.length - 1 - i
              });
            });
          }
          /**
           * Private method to validate custom buttons received as input.
           * @throws an error is exists a button with an unknown type
           * @private
           * @param {?=} buttons
           * @return {?} ButtonConfig[] the same input buttons config array
           */

        }, {
          key: "validateCustomButtons",
          value: function validateCustomButtons() {
            var buttons = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
            buttons.forEach(
            /**
            * @param {?} val
            * @return {?}
            */
            function (val) {
              /** @type {?} */
              var indexOfButtonType = WHITELIST_BUTTON_TYPES.findIndex(
              /**
              * @param {?} type
              * @return {?}
              */
              function (type) {
                return type === val.type;
              });

              if (indexOfButtonType === -1) {
                throw new Error("Unknown ButtonType. For custom types use ButtonType.CUSTOM");
              }
            });
            return buttons;
          }
        }]);

        return UpperButtonsComponent;
      }(AccessibleComponent);

      UpperButtonsComponent.ɵfac = /*@__PURE__*/function () {
        var ɵUpperButtonsComponent_BaseFactory;
        return function UpperButtonsComponent_Factory(t) {
          return (ɵUpperButtonsComponent_BaseFactory || (ɵUpperButtonsComponent_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](UpperButtonsComponent)))(t || UpperButtonsComponent);
        };
      }();

      UpperButtonsComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: UpperButtonsComponent,
        selectors: [["ks-upper-buttons"]],
        inputs: {
          currentImage: "currentImage",
          buttonsConfig: "buttonsConfig"
        },
        outputs: {
          refresh: "refresh",
          "delete": "delete",
          navigate: "navigate",
          download: "download",
          close: "close",
          fullscreen: "fullscreen",
          customEmit: "customEmit"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"]],
        decls: 2,
        vars: 1,
        consts: [[1, "buttons-container"], [4, "ngIf"], ["class", "upper-button", "ksSize", "", "role", "button", 3, "sizeConfig", "ngStyle", "tabindex", "click", "keyup", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["ksSize", "", "role", "button", 1, "upper-button", 3, "sizeConfig", "ngStyle", "tabindex", "click", "keyup"], ["aria-hidden", "true", 3, "title"]],
        template: function UpperButtonsComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "header", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, UpperButtonsComponent_ng_container_1_Template, 2, 2, "ng-container", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.configButtons || (ctx.configButtons == null ? null : ctx.configButtons.visible));
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, SizeDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgStyle],
        styles: [".buttons-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:flex-end}.buttons-container[_ngcontent-%COMP%] > .upper-button[_ngcontent-%COMP%]{-ms-grid-row-align:center;align-self:center;margin-right:30px;margin-top:28px;font-size:50px;text-decoration:none;cursor:pointer;-webkit-animation:.6s animatezoom;animation:.6s animatezoom;color:#fff}@-webkit-keyframes animatezoom{from{transform:scale(0)}to{transform:scale(1)}}@keyframes animatezoom{from{transform:scale(0)}to{transform:scale(1)}}.base-btn[_ngcontent-%COMP%], .close-image[_ngcontent-%COMP%], .copy[_ngcontent-%COMP%], .delete-image[_ngcontent-%COMP%], .download-image[_ngcontent-%COMP%], .ext-url-image[_ngcontent-%COMP%], .fullscreen-image[_ngcontent-%COMP%], .refresh-image[_ngcontent-%COMP%], .rotate-image[_ngcontent-%COMP%]{width:30px;height:30px;background-size:30px;opacity:.8;transition:.5s}.base-btn[_ngcontent-%COMP%]:hover, .close-image[_ngcontent-%COMP%]:hover, .copy[_ngcontent-%COMP%]:hover, .delete-image[_ngcontent-%COMP%]:hover, .download-image[_ngcontent-%COMP%]:hover, .ext-url-image[_ngcontent-%COMP%]:hover, .fullscreen-image[_ngcontent-%COMP%]:hover, .refresh-image[_ngcontent-%COMP%]:hover, .rotate-image[_ngcontent-%COMP%]:hover{transform:scale(1.2)}.rotate-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDY0IDY0IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2NCA2NDsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTMzLDJjNy43NDYsMCwxNS4wMjgsMy4wMTcsMjAuNTA1LDguNDk0YzEwLjEzOCwxMC4xMzcsMTEuMzEsMjYuMzk2LDIuNzQsMzcuODQ5TDUyLDUyLjU4OVY0NGgtMnYxMWwxLDFoMTF2LTJoLTguNTgyICAgIGw0LjI5Mi00LjI5M2wwLjA5Mi0wLjEwNmM5LjIxMS0xMi4yNDcsNy45NzItMjkuNjY3LTIuODgzLTQwLjUyMUM0OS4wNjQsMy4yMjUsNDEuMjgsMCwzMywwVjJ6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTcuNzU1LDE1LjY1N0wxMiwxMS40MTFWMjBoMlY5bC0xLTFIMnYyaDguNTgyTDYuMjksMTQuMjkzbC0wLjA5MiwwLjEwNkMtMy4wMTMsMjYuNjQ2LTEuNzczLDQ0LjA2Niw5LjA4MSw1NC45MiAgICBDMTQuOTM2LDYwLjc3NSwyMi43Miw2NCwzMSw2NHYtMmMtNy43NDYsMC0xNS4wMjgtMy4wMTctMjAuNTA1LTguNDk0QzAuMzU3LDQzLjM2OS0wLjgxNCwyNy4xMSw3Ljc1NSwxNS42NTd6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}.fullscreen-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNTMgNTMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUzIDUzOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNNTIuOTIzLDAuNjE4Yy0wLjEwMS0wLjI0NC0wLjI5Ni0wLjQzOS0wLjU0MS0wLjU0MUM1Mi4yNiwwLjAyNyw1Mi4xMywwLDUyLDBINDBjLTAuNTUyLDAtMSwwLjQ0OC0xLDFzMC40NDgsMSwxLDFoOS41ODYgICBMMzMuMjkzLDE4LjI5M2MtMC4zOTEsMC4zOTEtMC4zOTEsMS4wMjMsMCwxLjQxNEMzMy40ODgsMTkuOTAyLDMzLjc0NCwyMCwzNCwyMHMwLjUxMi0wLjA5OCwwLjcwNy0wLjI5M0w1MSwzLjQxNFYxMyAgIGMwLDAuNTUyLDAuNDQ4LDEsMSwxczEtMC40NDgsMS0xVjFDNTMsMC44Nyw1Mi45NzMsMC43NCw1Mi45MjMsMC42MTh6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTE4LjI5MywzMy4yOTNMMiw0OS41ODZWNDBjMC0wLjU1Mi0wLjQ0OC0xLTEtMXMtMSwwLjQ0OC0xLDF2MTJjMCwwLjEzLDAuMDI3LDAuMjYsMC4wNzcsMC4zODIgICBjMC4xMDEsMC4yNDQsMC4yOTYsMC40MzksMC41NDEsMC41NDFDMC43NCw1Mi45NzMsMC44Nyw1MywxLDUzaDEyYzAuNTUyLDAsMS0wLjQ0OCwxLTFzLTAuNDQ4LTEtMS0xSDMuNDE0bDE2LjI5My0xNi4yOTMgICBjMC4zOTEtMC4zOTEsMC4zOTEtMS4wMjMsMC0xLjQxNFMxOC42ODQsMzIuOTAyLDE4LjI5MywzMy4yOTN6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTEsMTRjMC41NTIsMCwxLTAuNDQ4LDEtMVYzLjQxNGwxNi4yOTIsMTYuMjkyYzAuMTk1LDAuMTk1LDAuNDUxLDAuMjkzLDAuNzA3LDAuMjkzczAuNTEyLTAuMDk4LDAuNzA3LTAuMjkzICAgYzAuMzkxLTAuMzkxLDAuMzkxLTEuMDIzLDAtMS40MTRMMy40MTQsMkgxM2MwLjU1MiwwLDEtMC40NDgsMS0xcy0wLjQ0OC0xLTEtMUgxQzAuODcsMCwwLjc0LDAuMDI3LDAuNjE4LDAuMDc3ICAgQzAuMzczLDAuMTc5LDAuMTc5LDAuMzczLDAuMDc3LDAuNjE4QzAuMDI3LDAuNzQsMCwwLjg3LDAsMXYxMkMwLDEzLjU1MiwwLjQ0OCwxNCwxLDE0eiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik01MiwzOWMtMC41NTIsMC0xLDAuNDQ4LTEsMXY5LjU4NkwzNC43MDcsMzMuMjkyYy0wLjM5MS0wLjM5MS0xLjAyMy0wLjM5MS0xLjQxNCwwcy0wLjM5MSwxLjAyMywwLDEuNDE0TDQ5LjU4Niw1MUg0MCAgIGMtMC41NTIsMC0xLDAuNDQ4LTEsMXMwLjQ0OCwxLDEsMWgxMmMwLjEzLDAsMC4yNi0wLjAyNywwLjM4Mi0wLjA3N2MwLjI0NC0wLjEwMSwwLjQzOS0wLjI5NiwwLjU0MS0wLjU0MSAgIEM1Mi45NzMsNTIuMjYsNTMsNTIuMTMsNTMsNTJWNDBDNTMsMzkuNDQ4LDUyLjU1MiwzOSw1MiwzOXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.delete-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4Ni40IDQ4Ni40IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0ODYuNCA0ODYuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQ0Niw3MEgzNDQuOFY1My41YzAtMjkuNS0yNC01My41LTUzLjUtNTMuNWgtOTYuMmMtMjkuNSwwLTUzLjUsMjQtNTMuNSw1My41VjcwSDQwLjRjLTcuNSwwLTEzLjUsNi0xMy41LDEzLjUgICAgUzMyLjksOTcsNDAuNCw5N2gyNC40djMxNy4yYzAsMzkuOCwzMi40LDcyLjIsNzIuMiw3Mi4yaDIxMi40YzM5LjgsMCw3Mi4yLTMyLjQsNzIuMi03Mi4yVjk3SDQ0NmM3LjUsMCwxMy41LTYsMTMuNS0xMy41ICAgIFM0NTMuNSw3MCw0NDYsNzB6IE0xNjguNiw1My41YzAtMTQuNiwxMS45LTI2LjUsMjYuNS0yNi41aDk2LjJjMTQuNiwwLDI2LjUsMTEuOSwyNi41LDI2LjVWNzBIMTY4LjZWNTMuNXogTTM5NC42LDQxNC4yICAgIGMwLDI0LjktMjAuMyw0NS4yLTQ1LjIsNDUuMkgxMzdjLTI0LjksMC00NS4yLTIwLjMtNDUuMi00NS4yVjk3aDMwMi45djMxNy4ySDM5NC42eiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0yNDMuMiw0MTFjNy41LDAsMTMuNS02LDEzLjUtMTMuNVYxNTguOWMwLTcuNS02LTEzLjUtMTMuNS0xMy41cy0xMy41LDYtMTMuNSwxMy41djIzOC41ICAgIEMyMjkuNyw0MDQuOSwyMzUuNyw0MTEsMjQzLjIsNDExeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0xNTUuMSwzOTYuMWM3LjUsMCwxMy41LTYsMTMuNS0xMy41VjE3My43YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjA4LjkgICAgQzE0MS42LDM5MC4xLDE0Ny43LDM5Ni4xLDE1NS4xLDM5Ni4xeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0zMzEuMywzOTYuMWM3LjUsMCwxMy41LTYsMTMuNS0xMy41VjE3My43YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjA4LjkgICAgQzMxNy44LDM5MC4xLDMyMy44LDM5Ni4xLDMzMS4zLDM5Ni4xeiIgZmlsbD0iI0ZGRkZGRiIvPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.ext-url-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iNTEycHgiIGhlaWdodD0iNTEycHgiPjxnPjxnPjxnPjxwYXRoIGQ9Ik00ODAsMjg4djExMmMwLDQ0LjE4My0zNS44MTcsODAtODAsODBIMTEyYy00NC4xODMsMC04MC0zNS44MTctODAtODBWMTEyYzAtNDQuMTgzLDM1LjgxNy04MCw4MC04MGg5NlYwaC05NiAgICAgQzUwLjE0NCwwLDAsNTAuMTQ0LDAsMTEydjI4OGMwLDYxLjg1Niw1MC4xNDQsMTEyLDExMiwxMTJoMjg4YzYxLjg1NiwwLDExMi01MC4xNDQsMTEyLTExMlYyODhINDgweiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0xNzYsNDE2aDMyVjI4OGMwLTEyNS43NiwxMDcuNTItMTI4LDExMi0xMjhoMTA1LjQ0bC04NC42NCw4NC42NGwyMi41NiwyMi41NmwxMTItMTEyYzYuMjA0LTYuMjQxLDYuMjA0LTE2LjMxOSwwLTIyLjU2ICAgICBsLTExMi0xMTJsLTIyLjcyLDIyLjcybDg0LjgsODQuNjRIMzIwYy0xLjQ0LDAtMTQ0LDEuNzYtMTQ0LDE2MFY0MTZ6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.download-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3MS4yIDQ3MS4yIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NzEuMiA0NzEuMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQ1Ny43LDIzMC4xNWMtNy41LDAtMTMuNSw2LTEzLjUsMTMuNXYxMjIuOGMwLDMzLjQtMjcuMiw2MC41LTYwLjUsNjAuNUg4Ny41Yy0zMy40LDAtNjAuNS0yNy4yLTYwLjUtNjAuNXYtMTI0LjggICAgYzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MTI0LjhjMCw0OC4zLDM5LjMsODcuNSw4Ny41LDg3LjVoMjk2LjJjNDguMywwLDg3LjUtMzkuMyw4Ny41LTg3LjV2LTEyMi44ICAgIEM0NzEuMiwyMzYuMjUsNDY1LjIsMjMwLjE1LDQ1Ny43LDIzMC4xNXoiIGZpbGw9IiNGRkZGRkYiLz48cGF0aCBkPSJNMjI2LjEsMzQ2Ljc1YzIuNiwyLjYsNi4xLDQsOS41LDRzNi45LTEuMyw5LjUtNGw4NS44LTg1LjhjNS4zLTUuMyw1LjMtMTMuOCwwLTE5LjFjLTUuMy01LjMtMTMuOC01LjMtMTkuMSwwbC02Mi43LDYyLjggICAgVjMwLjc1YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjczLjlsLTYyLjgtNjIuOGMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xICAgIEwyMjYuMSwzNDYuNzV6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}.close-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3NS4yIDQ3NS4yIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NzUuMiA0NzUuMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQwNS42LDY5LjZDMzYwLjcsMjQuNywzMDEuMSwwLDIzNy42LDBzLTEyMy4xLDI0LjctMTY4LDY5LjZTMCwxNzQuMSwwLDIzNy42czI0LjcsMTIzLjEsNjkuNiwxNjhzMTA0LjUsNjkuNiwxNjgsNjkuNiAgICBzMTIzLjEtMjQuNywxNjgtNjkuNnM2OS42LTEwNC41LDY5LjYtMTY4UzQ1MC41LDExNC41LDQwNS42LDY5LjZ6IE0zODYuNSwzODYuNWMtMzkuOCwzOS44LTkyLjcsNjEuNy0xNDguOSw2MS43ICAgIHMtMTA5LjEtMjEuOS0xNDguOS02MS43Yy04Mi4xLTgyLjEtODIuMS0yMTUuNywwLTI5Ny44QzEyOC41LDQ4LjksMTgxLjQsMjcsMjM3LjYsMjdzMTA5LjEsMjEuOSwxNDguOSw2MS43ICAgIEM0NjguNiwxNzAuOCw0NjguNiwzMDQuNCwzODYuNSwzODYuNXoiIGZpbGw9IiNGRkZGRkYiLz48cGF0aCBkPSJNMzQyLjMsMTMyLjljLTUuMy01LjMtMTMuOC01LjMtMTkuMSwwbC04NS42LDg1LjZMMTUyLDEzMi45Yy01LjMtNS4zLTEzLjgtNS4zLTE5LjEsMGMtNS4zLDUuMy01LjMsMTMuOCwwLDE5LjEgICAgbDg1LjYsODUuNmwtODUuNiw4NS42Yy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWMyLjYsMi42LDYuMSw0LDkuNSw0czYuOS0xLjMsOS41LTRsODUuNi04NS42bDg1LjYsODUuNmMyLjYsMi42LDYuMSw0LDkuNSw0ICAgIGMzLjUsMCw2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xbC04NS40LTg1LjZsODUuNi04NS42QzM0Ny42LDE0Ni43LDM0Ny42LDEzOC4yLDM0Mi4zLDEzMi45eiIgZmlsbD0iI0ZGRkZGRiIvPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.refresh-image[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4OS43MTEgNDg5LjcxMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDg5LjcxMSA0ODkuNzExOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48Zz48cGF0aCBkPSJNMTEyLjE1Niw5Ny4xMTFjNzIuMy02NS40LDE4MC41LTY2LjQsMjUzLjgtNi43bC01OC4xLDIuMmMtNy41LDAuMy0xMy4zLDYuNS0xMywxNGMwLjMsNy4zLDYuMywxMywxMy41LDEzICAgIGMwLjIsMCwwLjMsMCwwLjUsMGw4OS4yLTMuM2M3LjMtMC4zLDEzLTYuMiwxMy0xMy41di0xYzAtMC4yLDAtMC4zLDAtMC41di0wLjFsMCwwbC0zLjMtODguMmMtMC4zLTcuNS02LjYtMTMuMy0xNC0xMyAgICBjLTcuNSwwLjMtMTMuMyw2LjUtMTMsMTRsMi4xLDU1LjNjLTM2LjMtMjkuNy04MS00Ni45LTEyOC44LTQ5LjNjLTU5LjItMy0xMTYuMSwxNy4zLTE2MCw1Ny4xYy02MC40LDU0LjctODYsMTM3LjktNjYuOCwyMTcuMSAgICBjMS41LDYuMiw3LDEwLjMsMTMuMSwxMC4zYzEuMSwwLDIuMS0wLjEsMy4yLTAuNGM3LjItMS44LDExLjctOS4xLDkuOS0xNi4zQzM2LjY1NiwyMTguMjExLDU5LjA1NiwxNDUuMTExLDExMi4xNTYsOTcuMTExeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik00NjIuNDU2LDE5NS41MTFjLTEuOC03LjItOS4xLTExLjctMTYuMy05LjljLTcuMiwxLjgtMTEuNyw5LjEtOS45LDE2LjNjMTYuOSw2OS42LTUuNiwxNDIuNy01OC43LDE5MC43ICAgIGMtMzcuMywzMy43LTg0LjEsNTAuMy0xMzAuNyw1MC4zYy00NC41LDAtODguOS0xNS4xLTEyNC43LTQ0LjlsNTguOC01LjNjNy40LTAuNywxMi45LTcuMiwxMi4yLTE0LjdzLTcuMi0xMi45LTE0LjctMTIuMmwtODguOSw4ICAgIGMtNy40LDAuNy0xMi45LDcuMi0xMi4yLDE0LjdsOCw4OC45YzAuNiw3LDYuNSwxMi4zLDEzLjQsMTIuM2MwLjQsMCwwLjgsMCwxLjItMC4xYzcuNC0wLjcsMTIuOS03LjIsMTIuMi0xNC43bC00LjgtNTQuMSAgICBjMzYuMywyOS40LDgwLjgsNDYuNSwxMjguMyw0OC45YzMuOCwwLjIsNy42LDAuMywxMS4zLDAuM2M1NS4xLDAsMTA3LjUtMjAuMiwxNDguNy01Ny40ICAgIEM0NTYuMDU2LDM1Ny45MTEsNDgxLjY1NiwyNzQuODExLDQ2Mi40NTYsMTk1LjUxMXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjwvc3ZnPg==)}.copy[_ngcontent-%COMP%]{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4OC4zIDQ4OC4zIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0ODguMyA0ODguMzsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTMxNC4yNSw4NS40aC0yMjdjLTIxLjMsMC0zOC42LDE3LjMtMzguNiwzOC42djMyNS43YzAsMjEuMywxNy4zLDM4LjYsMzguNiwzOC42aDIyN2MyMS4zLDAsMzguNi0xNy4zLDM4LjYtMzguNlYxMjQgICAgQzM1Mi43NSwxMDIuNywzMzUuNDUsODUuNCwzMTQuMjUsODUuNHogTTMyNS43NSw0NDkuNmMwLDYuNC01LjIsMTEuNi0xMS42LDExLjZoLTIyN2MtNi40LDAtMTEuNi01LjItMTEuNi0xMS42VjEyNCAgICBjMC02LjQsNS4yLTExLjYsMTEuNi0xMS42aDIyN2M2LjQsMCwxMS42LDUuMiwxMS42LDExLjZWNDQ5LjZ6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTQwMS4wNSwwaC0yMjdjLTIxLjMsMC0zOC42LDE3LjMtMzguNiwzOC42YzAsNy41LDYsMTMuNSwxMy41LDEzLjVzMTMuNS02LDEzLjUtMTMuNWMwLTYuNCw1LjItMTEuNiwxMS42LTExLjZoMjI3ICAgIGM2LjQsMCwxMS42LDUuMiwxMS42LDExLjZ2MzI1LjdjMCw2LjQtNS4yLDExLjYtMTEuNiwxMS42Yy03LjUsMC0xMy41LDYtMTMuNSwxMy41czYsMTMuNSwxMy41LDEzLjVjMjEuMywwLDM4LjYtMTcuMywzOC42LTM4LjYgICAgVjM4LjZDNDM5LjY1LDE3LjMsNDIyLjM1LDAsNDAxLjA1LDB6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}"],
        changeDetection: 0
      });
      UpperButtonsComponent.propDecorators = {
        currentImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        buttonsConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        refresh: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        "delete": [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        navigate: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        download: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        close: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        fullscreen: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }],
        customEmit: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](UpperButtonsComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-upper-buttons',
            template: "<header class=\"buttons-container\">\n\n  <ng-container *ngIf=\"!configButtons || configButtons?.visible\">\n    <a *ngFor=\"let btn of buttons; trackBy: trackById; let index = index\"\n       class=\"upper-button\"\n       ksSize [sizeConfig]=\"{width: btn.size?.width, height: btn.size?.height}\"\n       [ngStyle]=\"{'font-size': btn.fontSize}\"\n       [attr.aria-label]=\"btn.ariaLabel\"\n       [tabindex]=\"0\" role=\"button\"\n       (click)=\"onEvent(btn, $event)\" (keyup)=\"onEvent(btn, $event)\">\n      <div class=\"inside {{btn.className}}\" aria-hidden=\"true\" title=\"{{btn.title}}\"></div>\n    </a>\n  </ng-container>\n</header>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [".buttons-container{display:flex;flex-direction:row;justify-content:flex-end}.buttons-container>.upper-button{-ms-grid-row-align:center;align-self:center;margin-right:30px;margin-top:28px;font-size:50px;text-decoration:none;cursor:pointer;-webkit-animation:.6s animatezoom;animation:.6s animatezoom;color:#fff}@-webkit-keyframes animatezoom{from{transform:scale(0)}to{transform:scale(1)}}@keyframes animatezoom{from{transform:scale(0)}to{transform:scale(1)}}.base-btn,.close-image,.copy,.delete-image,.download-image,.ext-url-image,.fullscreen-image,.refresh-image,.rotate-image{width:30px;height:30px;background-size:30px;opacity:.8;transition:.5s}.base-btn:hover,.close-image:hover,.copy:hover,.delete-image:hover,.download-image:hover,.ext-url-image:hover,.fullscreen-image:hover,.refresh-image:hover,.rotate-image:hover{transform:scale(1.2)}.rotate-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDY0IDY0IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA2NCA2NDsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTMzLDJjNy43NDYsMCwxNS4wMjgsMy4wMTcsMjAuNTA1LDguNDk0YzEwLjEzOCwxMC4xMzcsMTEuMzEsMjYuMzk2LDIuNzQsMzcuODQ5TDUyLDUyLjU4OVY0NGgtMnYxMWwxLDFoMTF2LTJoLTguNTgyICAgIGw0LjI5Mi00LjI5M2wwLjA5Mi0wLjEwNmM5LjIxMS0xMi4yNDcsNy45NzItMjkuNjY3LTIuODgzLTQwLjUyMUM0OS4wNjQsMy4yMjUsNDEuMjgsMCwzMywwVjJ6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTcuNzU1LDE1LjY1N0wxMiwxMS40MTFWMjBoMlY5bC0xLTFIMnYyaDguNTgyTDYuMjksMTQuMjkzbC0wLjA5MiwwLjEwNkMtMy4wMTMsMjYuNjQ2LTEuNzczLDQ0LjA2Niw5LjA4MSw1NC45MiAgICBDMTQuOTM2LDYwLjc3NSwyMi43Miw2NCwzMSw2NHYtMmMtNy43NDYsMC0xNS4wMjgtMy4wMTctMjAuNTA1LTguNDk0QzAuMzU3LDQzLjM2OS0wLjgxNCwyNy4xMSw3Ljc1NSwxNS42NTd6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}.fullscreen-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB2ZXJzaW9uPSIxLjEiIGlkPSJDYXBhXzEiIHg9IjBweCIgeT0iMHB4IiB2aWV3Qm94PSIwIDAgNTMgNTMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUzIDUzOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNNTIuOTIzLDAuNjE4Yy0wLjEwMS0wLjI0NC0wLjI5Ni0wLjQzOS0wLjU0MS0wLjU0MUM1Mi4yNiwwLjAyNyw1Mi4xMywwLDUyLDBINDBjLTAuNTUyLDAtMSwwLjQ0OC0xLDFzMC40NDgsMSwxLDFoOS41ODYgICBMMzMuMjkzLDE4LjI5M2MtMC4zOTEsMC4zOTEtMC4zOTEsMS4wMjMsMCwxLjQxNEMzMy40ODgsMTkuOTAyLDMzLjc0NCwyMCwzNCwyMHMwLjUxMi0wLjA5OCwwLjcwNy0wLjI5M0w1MSwzLjQxNFYxMyAgIGMwLDAuNTUyLDAuNDQ4LDEsMSwxczEtMC40NDgsMS0xVjFDNTMsMC44Nyw1Mi45NzMsMC43NCw1Mi45MjMsMC42MTh6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTE4LjI5MywzMy4yOTNMMiw0OS41ODZWNDBjMC0wLjU1Mi0wLjQ0OC0xLTEtMXMtMSwwLjQ0OC0xLDF2MTJjMCwwLjEzLDAuMDI3LDAuMjYsMC4wNzcsMC4zODIgICBjMC4xMDEsMC4yNDQsMC4yOTYsMC40MzksMC41NDEsMC41NDFDMC43NCw1Mi45NzMsMC44Nyw1MywxLDUzaDEyYzAuNTUyLDAsMS0wLjQ0OCwxLTFzLTAuNDQ4LTEtMS0xSDMuNDE0bDE2LjI5My0xNi4yOTMgICBjMC4zOTEtMC4zOTEsMC4zOTEtMS4wMjMsMC0xLjQxNFMxOC42ODQsMzIuOTAyLDE4LjI5MywzMy4yOTN6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTEsMTRjMC41NTIsMCwxLTAuNDQ4LDEtMVYzLjQxNGwxNi4yOTIsMTYuMjkyYzAuMTk1LDAuMTk1LDAuNDUxLDAuMjkzLDAuNzA3LDAuMjkzczAuNTEyLTAuMDk4LDAuNzA3LTAuMjkzICAgYzAuMzkxLTAuMzkxLDAuMzkxLTEuMDIzLDAtMS40MTRMMy40MTQsMkgxM2MwLjU1MiwwLDEtMC40NDgsMS0xcy0wLjQ0OC0xLTEtMUgxQzAuODcsMCwwLjc0LDAuMDI3LDAuNjE4LDAuMDc3ICAgQzAuMzczLDAuMTc5LDAuMTc5LDAuMzczLDAuMDc3LDAuNjE4QzAuMDI3LDAuNzQsMCwwLjg3LDAsMXYxMkMwLDEzLjU1MiwwLjQ0OCwxNCwxLDE0eiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik01MiwzOWMtMC41NTIsMC0xLDAuNDQ4LTEsMXY5LjU4NkwzNC43MDcsMzMuMjkyYy0wLjM5MS0wLjM5MS0xLjAyMy0wLjM5MS0xLjQxNCwwcy0wLjM5MSwxLjAyMywwLDEuNDE0TDQ5LjU4Niw1MUg0MCAgIGMtMC41NTIsMC0xLDAuNDQ4LTEsMXMwLjQ0OCwxLDEsMWgxMmMwLjEzLDAsMC4yNi0wLjAyNywwLjM4Mi0wLjA3N2MwLjI0NC0wLjEwMSwwLjQzOS0wLjI5NiwwLjU0MS0wLjU0MSAgIEM1Mi45NzMsNTIuMjYsNTMsNTIuMTMsNTMsNTJWNDBDNTMsMzkuNDQ4LDUyLjU1MiwzOSw1MiwzOXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.delete-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4Ni40IDQ4Ni40IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0ODYuNCA0ODYuNDsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQ0Niw3MEgzNDQuOFY1My41YzAtMjkuNS0yNC01My41LTUzLjUtNTMuNWgtOTYuMmMtMjkuNSwwLTUzLjUsMjQtNTMuNSw1My41VjcwSDQwLjRjLTcuNSwwLTEzLjUsNi0xMy41LDEzLjUgICAgUzMyLjksOTcsNDAuNCw5N2gyNC40djMxNy4yYzAsMzkuOCwzMi40LDcyLjIsNzIuMiw3Mi4yaDIxMi40YzM5LjgsMCw3Mi4yLTMyLjQsNzIuMi03Mi4yVjk3SDQ0NmM3LjUsMCwxMy41LTYsMTMuNS0xMy41ICAgIFM0NTMuNSw3MCw0NDYsNzB6IE0xNjguNiw1My41YzAtMTQuNiwxMS45LTI2LjUsMjYuNS0yNi41aDk2LjJjMTQuNiwwLDI2LjUsMTEuOSwyNi41LDI2LjVWNzBIMTY4LjZWNTMuNXogTTM5NC42LDQxNC4yICAgIGMwLDI0LjktMjAuMyw0NS4yLTQ1LjIsNDUuMkgxMzdjLTI0LjksMC00NS4yLTIwLjMtNDUuMi00NS4yVjk3aDMwMi45djMxNy4ySDM5NC42eiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0yNDMuMiw0MTFjNy41LDAsMTMuNS02LDEzLjUtMTMuNVYxNTguOWMwLTcuNS02LTEzLjUtMTMuNS0xMy41cy0xMy41LDYtMTMuNSwxMy41djIzOC41ICAgIEMyMjkuNyw0MDQuOSwyMzUuNyw0MTEsMjQzLjIsNDExeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0xNTUuMSwzOTYuMWM3LjUsMCwxMy41LTYsMTMuNS0xMy41VjE3My43YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjA4LjkgICAgQzE0MS42LDM5MC4xLDE0Ny43LDM5Ni4xLDE1NS4xLDM5Ni4xeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0zMzEuMywzOTYuMWM3LjUsMCwxMy41LTYsMTMuNS0xMy41VjE3My43YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjA4LjkgICAgQzMxNy44LDM5MC4xLDMyMy44LDM5Ni4xLDMzMS4zLDM5Ni4xeiIgZmlsbD0iI0ZGRkZGRiIvPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.ext-url-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iNTEycHgiIGhlaWdodD0iNTEycHgiPjxnPjxnPjxnPjxwYXRoIGQ9Ik00ODAsMjg4djExMmMwLDQ0LjE4My0zNS44MTcsODAtODAsODBIMTEyYy00NC4xODMsMC04MC0zNS44MTctODAtODBWMTEyYzAtNDQuMTgzLDM1LjgxNy04MCw4MC04MGg5NlYwaC05NiAgICAgQzUwLjE0NCwwLDAsNTAuMTQ0LDAsMTEydjI4OGMwLDYxLjg1Niw1MC4xNDQsMTEyLDExMiwxMTJoMjg4YzYxLjg1NiwwLDExMi01MC4xNDQsMTEyLTExMlYyODhINDgweiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik0xNzYsNDE2aDMyVjI4OGMwLTEyNS43NiwxMDcuNTItMTI4LDExMi0xMjhoMTA1LjQ0bC04NC42NCw4NC42NGwyMi41NiwyMi41NmwxMTItMTEyYzYuMjA0LTYuMjQxLDYuMjA0LTE2LjMxOSwwLTIyLjU2ICAgICBsLTExMi0xMTJsLTIyLjcyLDIyLjcybDg0LjgsODQuNjRIMzIwYy0xLjQ0LDAtMTQ0LDEuNzYtMTQ0LDE2MFY0MTZ6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.download-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3MS4yIDQ3MS4yIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NzEuMiA0NzEuMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQ1Ny43LDIzMC4xNWMtNy41LDAtMTMuNSw2LTEzLjUsMTMuNXYxMjIuOGMwLDMzLjQtMjcuMiw2MC41LTYwLjUsNjAuNUg4Ny41Yy0zMy40LDAtNjAuNS0yNy4yLTYwLjUtNjAuNXYtMTI0LjggICAgYzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MTI0LjhjMCw0OC4zLDM5LjMsODcuNSw4Ny41LDg3LjVoMjk2LjJjNDguMywwLDg3LjUtMzkuMyw4Ny41LTg3LjV2LTEyMi44ICAgIEM0NzEuMiwyMzYuMjUsNDY1LjIsMjMwLjE1LDQ1Ny43LDIzMC4xNXoiIGZpbGw9IiNGRkZGRkYiLz48cGF0aCBkPSJNMjI2LjEsMzQ2Ljc1YzIuNiwyLjYsNi4xLDQsOS41LDRzNi45LTEuMyw5LjUtNGw4NS44LTg1LjhjNS4zLTUuMyw1LjMtMTMuOCwwLTE5LjFjLTUuMy01LjMtMTMuOC01LjMtMTkuMSwwbC02Mi43LDYyLjggICAgVjMwLjc1YzAtNy41LTYtMTMuNS0xMy41LTEzLjVzLTEzLjUsNi0xMy41LDEzLjV2MjczLjlsLTYyLjgtNjIuOGMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xICAgIEwyMjYuMSwzNDYuNzV6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}.close-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3NS4yIDQ3NS4yIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NzUuMiA0NzUuMjsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTQwNS42LDY5LjZDMzYwLjcsMjQuNywzMDEuMSwwLDIzNy42LDBzLTEyMy4xLDI0LjctMTY4LDY5LjZTMCwxNzQuMSwwLDIzNy42czI0LjcsMTIzLjEsNjkuNiwxNjhzMTA0LjUsNjkuNiwxNjgsNjkuNiAgICBzMTIzLjEtMjQuNywxNjgtNjkuNnM2OS42LTEwNC41LDY5LjYtMTY4UzQ1MC41LDExNC41LDQwNS42LDY5LjZ6IE0zODYuNSwzODYuNWMtMzkuOCwzOS44LTkyLjcsNjEuNy0xNDguOSw2MS43ICAgIHMtMTA5LjEtMjEuOS0xNDguOS02MS43Yy04Mi4xLTgyLjEtODIuMS0yMTUuNywwLTI5Ny44QzEyOC41LDQ4LjksMTgxLjQsMjcsMjM3LjYsMjdzMTA5LjEsMjEuOSwxNDguOSw2MS43ICAgIEM0NjguNiwxNzAuOCw0NjguNiwzMDQuNCwzODYuNSwzODYuNXoiIGZpbGw9IiNGRkZGRkYiLz48cGF0aCBkPSJNMzQyLjMsMTMyLjljLTUuMy01LjMtMTMuOC01LjMtMTkuMSwwbC04NS42LDg1LjZMMTUyLDEzMi45Yy01LjMtNS4zLTEzLjgtNS4zLTE5LjEsMGMtNS4zLDUuMy01LjMsMTMuOCwwLDE5LjEgICAgbDg1LjYsODUuNmwtODUuNiw4NS42Yy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWMyLjYsMi42LDYuMSw0LDkuNSw0czYuOS0xLjMsOS41LTRsODUuNi04NS42bDg1LjYsODUuNmMyLjYsMi42LDYuMSw0LDkuNSw0ICAgIGMzLjUsMCw2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xbC04NS40LTg1LjZsODUuNi04NS42QzM0Ny42LDE0Ni43LDM0Ny42LDEzOC4yLDM0Mi4zLDEzMi45eiIgZmlsbD0iI0ZGRkZGRiIvPjwvZz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+)}.refresh-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4OS43MTEgNDg5LjcxMSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDg5LjcxMSA0ODkuNzExOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48Zz48cGF0aCBkPSJNMTEyLjE1Niw5Ny4xMTFjNzIuMy02NS40LDE4MC41LTY2LjQsMjUzLjgtNi43bC01OC4xLDIuMmMtNy41LDAuMy0xMy4zLDYuNS0xMywxNGMwLjMsNy4zLDYuMywxMywxMy41LDEzICAgIGMwLjIsMCwwLjMsMCwwLjUsMGw4OS4yLTMuM2M3LjMtMC4zLDEzLTYuMiwxMy0xMy41di0xYzAtMC4yLDAtMC4zLDAtMC41di0wLjFsMCwwbC0zLjMtODguMmMtMC4zLTcuNS02LjYtMTMuMy0xNC0xMyAgICBjLTcuNSwwLjMtMTMuMyw2LjUtMTMsMTRsMi4xLDU1LjNjLTM2LjMtMjkuNy04MS00Ni45LTEyOC44LTQ5LjNjLTU5LjItMy0xMTYuMSwxNy4zLTE2MCw1Ny4xYy02MC40LDU0LjctODYsMTM3LjktNjYuOCwyMTcuMSAgICBjMS41LDYuMiw3LDEwLjMsMTMuMSwxMC4zYzEuMSwwLDIuMS0wLjEsMy4yLTAuNGM3LjItMS44LDExLjctOS4xLDkuOS0xNi4zQzM2LjY1NiwyMTguMjExLDU5LjA1NiwxNDUuMTExLDExMi4xNTYsOTcuMTExeiIgZmlsbD0iI0ZGRkZGRiIvPjxwYXRoIGQ9Ik00NjIuNDU2LDE5NS41MTFjLTEuOC03LjItOS4xLTExLjctMTYuMy05LjljLTcuMiwxLjgtMTEuNyw5LjEtOS45LDE2LjNjMTYuOSw2OS42LTUuNiwxNDIuNy01OC43LDE5MC43ICAgIGMtMzcuMywzMy43LTg0LjEsNTAuMy0xMzAuNyw1MC4zYy00NC41LDAtODguOS0xNS4xLTEyNC43LTQ0LjlsNTguOC01LjNjNy40LTAuNywxMi45LTcuMiwxMi4yLTE0LjdzLTcuMi0xMi45LTE0LjctMTIuMmwtODguOSw4ICAgIGMtNy40LDAuNy0xMi45LDcuMi0xMi4yLDE0LjdsOCw4OC45YzAuNiw3LDYuNSwxMi4zLDEzLjQsMTIuM2MwLjQsMCwwLjgsMCwxLjItMC4xYzcuNC0wLjcsMTIuOS03LjIsMTIuMi0xNC43bC00LjgtNTQuMSAgICBjMzYuMywyOS40LDgwLjgsNDYuNSwxMjguMyw0OC45YzMuOCwwLjIsNy42LDAuMywxMS4zLDAuM2M1NS4xLDAsMTA3LjUtMjAuMiwxNDguNy01Ny40ICAgIEM0NTYuMDU2LDM1Ny45MTEsNDgxLjY1NiwyNzQuODExLDQ2Mi40NTYsMTk1LjUxMXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjwvc3ZnPg==)}.copy{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4OC4zIDQ4OC4zIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0ODguMyA0ODguMzsiIHhtbDpzcGFjZT0icHJlc2VydmUiIHdpZHRoPSI1MTJweCIgaGVpZ2h0PSI1MTJweCI+PGc+PGc+PHBhdGggZD0iTTMxNC4yNSw4NS40aC0yMjdjLTIxLjMsMC0zOC42LDE3LjMtMzguNiwzOC42djMyNS43YzAsMjEuMywxNy4zLDM4LjYsMzguNiwzOC42aDIyN2MyMS4zLDAsMzguNi0xNy4zLDM4LjYtMzguNlYxMjQgICAgQzM1Mi43NSwxMDIuNywzMzUuNDUsODUuNCwzMTQuMjUsODUuNHogTTMyNS43NSw0NDkuNmMwLDYuNC01LjIsMTEuNi0xMS42LDExLjZoLTIyN2MtNi40LDAtMTEuNi01LjItMTEuNi0xMS42VjEyNCAgICBjMC02LjQsNS4yLTExLjYsMTEuNi0xMS42aDIyN2M2LjQsMCwxMS42LDUuMiwxMS42LDExLjZWNDQ5LjZ6IiBmaWxsPSIjRkZGRkZGIi8+PHBhdGggZD0iTTQwMS4wNSwwaC0yMjdjLTIxLjMsMC0zOC42LDE3LjMtMzguNiwzOC42YzAsNy41LDYsMTMuNSwxMy41LDEzLjVzMTMuNS02LDEzLjUtMTMuNWMwLTYuNCw1LjItMTEuNiwxMS42LTExLjZoMjI3ICAgIGM2LjQsMCwxMS42LDUuMiwxMS42LDExLjZ2MzI1LjdjMCw2LjQtNS4yLDExLjYtMTEuNiwxMS42Yy03LjUsMC0xMy41LDYtMTMuNSwxMy41czYsMTMuNSwxMy41LDEzLjVjMjEuMywwLDM4LjYtMTcuMywzOC42LTM4LjYgICAgVjM4LjZDNDM5LjY1LDE3LjMsNDIyLjM1LDAsNDAxLjA1LDB6IiBmaWxsPSIjRkZGRkZGIi8+PC9nPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48L3N2Zz4=)}"]
          }]
        }], null, {
          refresh: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          "delete": [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          navigate: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          download: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          close: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          fullscreen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          customEmit: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          currentImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          buttonsConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with clickable dots (small circles) to navigate between images inside the modal gallery.
       */


      var DotsComponent = /*#__PURE__*/function (_AccessibleComponent5) {
        _inherits(DotsComponent, _AccessibleComponent5);

        var _super6 = _createSuper(DotsComponent);

        function DotsComponent() {
          var _this17;

          _classCallCheck(this, DotsComponent);

          _this17 = _super6.apply(this, arguments);
          /**
           * Object of type `DotsConfig` to init DotsComponent's features.
           * For instance, it contains a param to show/hide this component.
           */

          _this17.dotsConfig = {
            visible: true
          };
          /**
           * Output to emit clicks on dots. The payload contains a number that represent
           * the index of the clicked dot.
           */

          _this17.clickDot = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          return _this17;
        }
        /**
         * Method ´ngOnInit´ to build `configDots` applying a default value.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(DotsComponent, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            /** @type {?} */
            var defaultConfig = {
              visible: true
            };
            this.configDots = Object.assign(defaultConfig, this.dotsConfig);
          }
          /**
           * Method ´ngOnChanges´ to change `configDots` if the input dotsConfig is changed.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * @param {?} changes
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            /** @type {?} */
            var dotsConfigChanges = changes.dotsConfig;

            if (dotsConfigChanges && dotsConfigChanges.currentValue !== dotsConfigChanges.previousValue) {
              this.configDots = dotsConfigChanges.currentValue;
            }
          }
          /**
           * Method to check if an image is active (i.e. the current image).
           * It checks currentImage and images to prevent errors.
           * @param {?} index
           * @return {?} boolean true if is active (and input params are valid), false otherwise
           */

        }, {
          key: "isActive",
          value: function isActive(index) {
            if (!this.currentImage || !this.images || this.images.length === 0) {
              return false;
            }
            /** @type {?} */


            var imageIndex;

            try {
              imageIndex = getIndex(this.currentImage, this.images);
            } catch (err) {
              console.error("Internal error while trying to show the active 'dot'", err);
              return false;
            }

            return index === imageIndex;
          }
          /**
           * Method called by events from keyboard and mouse.
           * @param {?} index
           * @param {?} event
           * @return {?}
           */

        }, {
          key: "onDotEvent",
          value: function onDotEvent(index, event) {
            /** @type {?} */
            var result = _get(_getPrototypeOf(DotsComponent.prototype), "handleImageEvent", this).call(this, event);

            if (result === NEXT) {
              this.clickDot.emit(index);
            }
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item.id;
          }
        }]);

        return DotsComponent;
      }(AccessibleComponent);

      DotsComponent.ɵfac = /*@__PURE__*/function () {
        var ɵDotsComponent_BaseFactory;
        return function DotsComponent_Factory(t) {
          return (ɵDotsComponent_BaseFactory || (ɵDotsComponent_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](DotsComponent)))(t || DotsComponent);
        };
      }();

      DotsComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: DotsComponent,
        selectors: [["ks-dots"]],
        inputs: {
          dotsConfig: "dotsConfig",
          currentImage: "currentImage",
          images: "images",
          accessibilityConfig: "accessibilityConfig"
        },
        outputs: {
          clickDot: "clickDot"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 2,
        vars: 3,
        consts: [[1, "dots-container", 3, "title"], [4, "ngIf"], ["class", "inside dot", "role", "navigation", 3, "ngClass", "tabindex", "click", "keyup", 4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "navigation", 1, "inside", "dot", 3, "ngClass", "tabindex", "click", "keyup"]],
        template: function DotsComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nav", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, DotsComponent_ng_container_1_Template, 2, 2, "ng-container", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.dotsContainerTitle);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.dotsContainerAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", !ctx.configDots || (ctx.configDots == null ? null : ctx.configDots.visible));
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgClass],
        styles: [".dots-container[_ngcontent-%COMP%]{display:flex;flex-direction:row;justify-content:center;margin-bottom:30px}.dots-container[_ngcontent-%COMP%] > .dot[_ngcontent-%COMP%]{background:#fff;border-radius:5px;height:10px;margin-left:4px;margin-right:4px;width:10px;cursor:pointer;opacity:.5}.dots-container[_ngcontent-%COMP%] > .dot[_ngcontent-%COMP%]:hover{opacity:.9;transition:opacity .5s}.dots-container[_ngcontent-%COMP%] > .dot.active[_ngcontent-%COMP%]{cursor:pointer;opacity:.9}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}"],
        changeDetection: 0
      });
      DotsComponent.propDecorators = {
        currentImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        dotsConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        clickDot: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](DotsComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-dots',
            template: "<nav class=\"dots-container\" [attr.aria-label]=\"accessibilityConfig?.dotsContainerAriaLabel\"\n     [title]=\"accessibilityConfig?.dotsContainerTitle\">\n  <ng-container *ngIf=\"!configDots || configDots?.visible\">\n    <div class=\"inside dot\"\n         *ngFor=\"let img of images; trackBy: trackById; let index = index\"\n         [ngClass]=\"{'active': isActive(index)}\"\n         [attr.aria-label]=\"accessibilityConfig?.dotAriaLabel + ' ' + (index + 1)\"\n         [tabindex]=\"0\" role=\"navigation\"\n         (click)=\"onDotEvent(index, $event)\" (keyup)=\"onDotEvent(index, $event)\"></div>\n  </ng-container>\n</nav>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [".dots-container{display:flex;flex-direction:row;justify-content:center;margin-bottom:30px}.dots-container>.dot{background:#fff;border-radius:5px;height:10px;margin-left:4px;margin-right:4px;width:10px;cursor:pointer;opacity:.5}.dots-container>.dot:hover{opacity:.9;transition:opacity .5s}.dots-container>.dot.active{cursor:pointer;opacity:.9}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}"]
          }]
        }], null, {
          dotsConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          clickDot: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          currentImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with image previews
       */


      var PreviewsComponent = /*#__PURE__*/function (_AccessibleComponent6) {
        _inherits(PreviewsComponent, _AccessibleComponent6);

        var _super7 = _createSuper(PreviewsComponent);

        function PreviewsComponent() {
          var _this18;

          _classCallCheck(this, PreviewsComponent);

          _this18 = _super7.apply(this, arguments);
          /**
           * Output to emit the clicked preview. The payload contains the `ImageEvent` associated to the clicked preview.
           */

          _this18.clickPreview = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter(); // /**
          //  * Output to emit the clicked arrow. The payload contains which arrow (left or right).
          //  */
          // @Output()
          // clickArrow: EventEmitter<InteractionEvent> = new EventEmitter<InteractionEvent>();

          /**
           * Enum of type `Action` that represents a mouse click on a button.
           * Declared here to be used inside the template.
           */

          _this18.clickAction = _Action.CLICK;
          /**
           * Enum of type `Action` that represents a keyboard action.
           * Declared here to be used inside the template.
           */

          _this18.keyboardAction = _Action.KEYBOARD;
          /**
           * Array of `InternalLibImage` exposed to the template. This field is initialized
           * applying transformations, default values and so on to the input of the same type.
           */

          _this18.previews = [];
          /**
           * Default preview's size object, also used in the template to apply default sizes to ksSize's directive.
           */

          _this18.defaultPreviewSize = {
            height: '50px',
            width: 'auto'
          };
          /**
           * Default preview's config object
           */

          _this18.defaultPreviewConfig = {
            visible: true,
            number: 3,
            arrows: true,
            clickable: true,
            // alwaysCenter: false, // TODO still not implemented
            size: _this18.defaultPreviewSize
          };
          return _this18;
        }
        /**
         * Method ´ngOnInit´ to build `configPreview` applying a default value and also to
         * init the `previews` array.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called only one time!!!
         * @return {?}
         */


        _createClass(PreviewsComponent, [{
          key: "ngOnInit",
          value: function ngOnInit() {
            this.configPreview = Object.assign({}, this.defaultPreviewConfig, this.previewConfig); // if number is <= 0 reset to default

            if (this.configPreview && this.configPreview.number && this.configPreview.number <= 0) {
              this.configPreview.number = this.defaultPreviewConfig.number;
            } // init previews based on currentImage and the full array of images


            this.initPreviews(this.currentImage, this.images);
          }
          /**
           * Method to check if an image is active (i.e. a preview image).
           * @param {?} preview
           * @return {?} boolean true if is active, false otherwise
           */

        }, {
          key: "isActive",
          value: function isActive(preview) {
            if (!preview || !this.currentImage) {
              return false;
            }

            return preview.id === this.currentImage.id;
          } // TODO improve this method to simplify the sourcecode + remove duplicated codelines

          /**
           * Method ´ngOnChanges´ to update `previews` array.
           * Also, both `start` and `end` local variables will be updated accordingly.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called when any data-bound property of a directive changes!!!
           * @param {?} changes
           * @return {?}
           */

        }, {
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            /** @type {?} */
            var images = changes.images;
            /** @type {?} */

            var currentImage = changes.currentImage;
            /** @type {?} */

            var prev;
            /** @type {?} */

            var current;

            if (currentImage) {
              prev = currentImage.previousValue;
              current = currentImage.currentValue;
            } else {
              current = this.currentImage;
            }

            if (current && images && images.previousValue && images.currentValue) {
              // I'm in this if statement, if input images are changed (for instance, because I removed one of them with the 'delete button',
              // or because users changed the images array while modal gallery is still open).
              // In this case, I have to re-init previews, because the input array of images is changed.
              this.initPreviews(current, images.currentValue);
            }

            if (prev && current && prev.id !== current.id) {
              this.updatePreviews(prev, current);
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a preview.
           * This will trigger the `clickpreview` output with the input preview as its payload.
           * @param {?} preview
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onImageEvent",
          value: function onImageEvent(preview, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.NORMAL;

            if (!this.configPreview || !this.configPreview.clickable) {
              return;
            }
            /** @type {?} */


            var result = _get(_getPrototypeOf(PreviewsComponent.prototype), "handleImageEvent", this).call(this, event);

            if (result === NEXT || result === PREV) {
              this.clickPreview.emit(new _ImageModalEvent(action, getIndex(preview, this.images)));
            }
          }
          /**
           * Method called by events from both keyboard and mouse on a navigation arrow.
           * It also emits an event to specify which arrow.
           * @param {?} direction
           * @param {?} event
           * @param {?=} action
           * @return {?}
           */

        }, {
          key: "onNavigationEvent",
          value: function onNavigationEvent(direction, event) {
            var action = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _Action.NORMAL;

            /** @type {?} */
            var result = _get(_getPrototypeOf(PreviewsComponent.prototype), "handleNavigationEvent", this).call(this, direction, event);

            if (result === NEXT) {
              // this.clickArrow.emit(<InteractionEvent>{ source: 'modal-previews', payload: DIRECTION_RIGHT, action: action });
              this.next();
            } else if (result === PREV) {
              // this.clickArrow.emit(<InteractionEvent>{ source: 'modal-previews', payload: DIRECTION_LEFT, action: action });
              this.previous();
            }
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item.id;
          }
          /**
           * Private method to init previews based on the currentImage and the full array of images.
           * The current image in mandatory to show always the current preview (as highlighted).
           * @private
           * @param {?} currentImage
           * @param {?} images
           * @return {?}
           */

        }, {
          key: "initPreviews",
          value: function initPreviews(currentImage, images) {
            var _this19 = this;

            /** @type {?} */
            var index;

            try {
              index = getIndex(currentImage, images);
            } catch (err) {
              throw err;
            }

            switch (index) {
              case 0:
                // first image
                this.setBeginningIndexesPreviews();
                break;

              case images.length - 1:
                // last image
                this.setEndIndexesPreviews();
                break;

              default:
                // other images
                this.setIndexesPreviews();
                break;
            }

            this.previews = images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this19.start && i < _this19.end;
            });
          }
          /**
           * Private method to init both `start` and `end` to the beginning.
           * @private
           * @return {?}
           */

        }, {
          key: "setBeginningIndexesPreviews",
          value: function setBeginningIndexesPreviews() {
            this.start = 0;
            this.end = Math.min(this.configPreview.number, this.images.length);
          }
          /**
           * Private method to init both `start` and `end` to the end.
           * @private
           * @return {?}
           */

        }, {
          key: "setEndIndexesPreviews",
          value: function setEndIndexesPreviews() {
            this.start = this.images.length - 1 - (this.configPreview.number - 1);
            this.end = this.images.length;
          }
          /**
           * Private method to update both `start` and `end` based on the currentImage.
           * @private
           * @return {?}
           */

        }, {
          key: "setIndexesPreviews",
          value: function setIndexesPreviews() {
            this.start = getIndex(this.currentImage, this.images) - Math.floor(this.configPreview.number / 2);
            this.end = getIndex(this.currentImage, this.images) + Math.floor(this.configPreview.number / 2) + 1;
          }
          /**
           * Private method to update the visible previews navigating to the right (next).
           * @private
           * @return {?}
           */

        }, {
          key: "next",
          value: function next() {
            var _this20 = this;

            // check if nextImage should be blocked
            if (this.isPreventSliding(this.images.length - 1)) {
              return;
            }

            if (this.end === this.images.length) {
              return;
            }

            this.start++;
            this.end = Math.min(this.end + 1, this.images.length);
            this.previews = this.images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this20.start && i < _this20.end;
            });
          }
          /**
           * Private method to update the visible previews navigating to the left (previous).
           * @private
           * @return {?}
           */

        }, {
          key: "previous",
          value: function previous() {
            var _this21 = this;

            // check if prevImage should be blocked
            if (this.isPreventSliding(0)) {
              return;
            }

            if (this.start === 0) {
              return;
            }

            this.start = Math.max(this.start - 1, 0);
            this.end = Math.min(this.end - 1, this.images.length);
            this.previews = this.images.filter(
            /**
            * @param {?} img
            * @param {?} i
            * @return {?}
            */
            function (img, i) {
              return i >= _this21.start && i < _this21.end;
            });
          }
          /**
           * Private method to block/permit sliding between previews.
           * @private
           * @param {?} boundaryIndex
           * @return {?} boolean if true block sliding, otherwise not
           */

        }, {
          key: "isPreventSliding",
          value: function isPreventSliding(boundaryIndex) {
            return !!this.slideConfig && this.slideConfig.infinite === false && getIndex(this.currentImage, this.images) === boundaryIndex;
          }
          /**
           * Private method to handle navigation changing the previews array and other variables.
           * @private
           * @param {?} prev
           * @param {?} current
           * @return {?}
           */

        }, {
          key: "updatePreviews",
          value: function updatePreviews(prev, current) {
            var _this22 = this;

            // to manage infinite sliding I have to reset both `start` and `end` at the beginning
            // to show again previews from the first image.
            // This happens when you navigate over the last image to return to the first one

            /** @type {?} */
            var prevIndex;
            /** @type {?} */

            var currentIndex;

            try {
              prevIndex = getIndex(prev, this.images);
              currentIndex = getIndex(current, this.images);
            } catch (err) {
              console.error('Cannot get previous and current image indexes in previews');
              throw err;
            }

            if (prevIndex === this.images.length - 1 && currentIndex === 0) {
              // first image
              this.setBeginningIndexesPreviews();
              this.previews = this.images.filter(
              /**
              * @param {?} img
              * @param {?} i
              * @return {?}
              */
              function (img, i) {
                return i >= _this22.start && i < _this22.end;
              });
              return;
            } // the same for the opposite case, when you navigate back from the fist image to go to the last one.


            if (prevIndex === 0 && currentIndex === this.images.length - 1) {
              // last image
              this.setEndIndexesPreviews();
              this.previews = this.images.filter(
              /**
              * @param {?} img
              * @param {?} i
              * @return {?}
              */
              function (img, i) {
                return i >= _this22.start && i < _this22.end;
              });
              return;
            } // otherwise manage standard scenarios


            if (prevIndex > currentIndex) {
              this.previous();
            } else if (prevIndex < currentIndex) {
              this.next();
            }
          }
        }]);

        return PreviewsComponent;
      }(AccessibleComponent);

      PreviewsComponent.ɵfac = /*@__PURE__*/function () {
        var ɵPreviewsComponent_BaseFactory;
        return function PreviewsComponent_Factory(t) {
          return (ɵPreviewsComponent_BaseFactory || (ɵPreviewsComponent_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](PreviewsComponent)))(t || PreviewsComponent);
        };
      }();

      PreviewsComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: PreviewsComponent,
        selectors: [["ks-previews"]],
        inputs: {
          currentImage: "currentImage",
          images: "images",
          slideConfig: "slideConfig",
          previewConfig: "previewConfig",
          accessibilityConfig: "accessibilityConfig"
        },
        outputs: {
          clickPreview: "clickPreview"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵInheritDefinitionFeature"], _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 2,
        vars: 3,
        consts: [[1, "previews-container", 3, "title"], [4, "ngIf"], ["role", "button", 1, "nav-left", 3, "tabindex", "click", "keyup"], ["aria-hidden", "true", 3, "title"], [4, "ngFor", "ngForOf", "ngForTrackBy"], ["role", "button", 1, "nav-right", 3, "tabindex", "click", "keyup"], ["ksSize", "", "role", "img", 3, "class", "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup", 4, "ngIf"], ["ksSize", "", "role", "img", 3, "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup"]],
        template: function PreviewsComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "nav", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](1, PreviewsComponent_ng_container_1_Template, 6, 14, "ng-container", 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.previewsContainerTitle);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.previewsContainerAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.configPreview == null ? null : ctx.configPreview.visible);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, SizeDirective],
        styles: ["@media only screen and (max-width:767px),only screen and (max-device-width:767px){.previews-container[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .preview-image[_ngcontent-%COMP%]{display:none}}@media only screen and (min-device-width:768px){.previews-container[_ngcontent-%COMP%]{align-items:center;-webkit-animation:.8s fadein-semi-visible08;animation:.8s fadein-semi-visible08;display:flex;flex-direction:row;justify-content:center;margin-bottom:15px}.previews-container[_ngcontent-%COMP%] > .preview-image[_ngcontent-%COMP%]{cursor:pointer;margin-left:2px;margin-right:2px;opacity:.7;height:50px}.previews-container[_ngcontent-%COMP%] > .preview-image.active[_ngcontent-%COMP%]{opacity:1}.previews-container[_ngcontent-%COMP%] > .preview-image.unclickable[_ngcontent-%COMP%]{cursor:not-allowed}.previews-container[_ngcontent-%COMP%] > .preview-image[_ngcontent-%COMP%]:hover{opacity:1;transition:opacity .5s}.previews-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%], .previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{color:#919191;cursor:pointer;transition:.5s}.previews-container[_ngcontent-%COMP%]   .nav[_ngcontent-%COMP%]:hover, .previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]:hover, .previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]:hover{transform:scale(1.1)}.previews-container[_ngcontent-%COMP%] > .nav-left[_ngcontent-%COMP%]{margin-right:10px}.previews-container[_ngcontent-%COMP%] > .nav-right[_ngcontent-%COMP%]{margin-left:10px}}@-webkit-keyframes fadein-visible{from{opacity:0}to{opacity:1}}@keyframes fadein-visible{from{opacity:0}to{opacity:1}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}", _c10],
        changeDetection: 0
      });
      PreviewsComponent.propDecorators = {
        currentImage: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        slideConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        previewConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        clickPreview: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](PreviewsComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-previews',
            template: "<nav class=\"previews-container\"\n     [attr.aria-label]=\"accessibilityConfig?.previewsContainerAriaLabel\"\n     [title]=\"accessibilityConfig?.previewsContainerTitle\">\n\n  <ng-container *ngIf=\"configPreview?.visible\">\n    <a class=\"nav-left\"\n       [attr.aria-label]=\"accessibilityConfig?.previewScrollPrevAriaLabel\"\n       [tabindex]=\"configPreview.arrows && start > 0 ? 0 : -1\" role=\"button\"\n       (click)=\"onNavigationEvent('left', $event)\" (keyup)=\"onNavigationEvent('left', $event)\">\n      <div class=\"inside {{configPreview.arrows && start > 0 ? 'left-arrow-preview-image' : 'empty-arrow-preview-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"accessibilityConfig?.previewScrollPrevTitle\"></div>\n    </a>\n\n    <ng-container *ngFor=\"let preview of previews; trackBy: trackById; let index = index\">\n      <img *ngIf=\"preview?.modal?.img\"\n           class=\"inside preview-image {{isActive(preview) ? 'active' : ''}}{{!configPreview.clickable ? ' unclickable' : ''}}\"\n           [src]=\"preview.plain?.img ? preview.plain.img : preview.modal.img\"\n           ksSize [sizeConfig]=\"{width: configPreview.size ? configPreview.size.width : defaultPreviewSize.width,\n                                 height: configPreview.size ? configPreview.size.height : defaultPreviewSize.height}\"\n           [attr.aria-label]=\"preview.modal.ariaLabel ? preview.modal.ariaLabel : ''\"\n           [title]=\"preview.modal.title ? preview.modal.title : ''\"\n           alt=\"{{preview.modal.alt ? preview.modal.alt : ''}}\"\n           [tabindex]=\"0\" role=\"img\"\n           (click)=\"onImageEvent(preview, $event, clickAction)\" (keyup)=\"onImageEvent(preview, $event, keyboardAction)\"/>\n    </ng-container>\n\n\n    <a class=\"nav-right\"\n       [attr.aria-label]=\"accessibilityConfig?.previewScrollNextAriaLabel\"\n       [tabindex]=\"configPreview.arrows && end < images.length ? 0 : -1\" role=\"button\"\n       (click)=\"onNavigationEvent('right', $event)\" (keyup)=\"onNavigationEvent('right', $event)\">\n      <div class=\"inside {{configPreview.arrows && end < images.length ? 'right-arrow-preview-image' : 'empty-arrow-preview-image'}}\"\n           aria-hidden=\"true\"\n           [title]=\"accessibilityConfig?.previewScrollNextTitle\"></div>\n    </a>\n  </ng-container>\n\n</nav>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: ["@media only screen and (max-width:767px),only screen and (max-device-width:767px){.previews-container,.previews-container>.nav-left,.previews-container>.nav-right,.previews-container>.preview-image{display:none}}@media only screen and (min-device-width:768px){.previews-container{align-items:center;-webkit-animation:.8s fadein-semi-visible08;animation:.8s fadein-semi-visible08;display:flex;flex-direction:row;justify-content:center;margin-bottom:15px}.previews-container>.preview-image{cursor:pointer;margin-left:2px;margin-right:2px;opacity:.7;height:50px}.previews-container>.preview-image.active{opacity:1}.previews-container>.preview-image.unclickable{cursor:not-allowed}.previews-container>.preview-image:hover{opacity:1;transition:opacity .5s}.previews-container .nav,.previews-container>.nav-left,.previews-container>.nav-right{color:#919191;cursor:pointer;transition:.5s}.previews-container .nav:hover,.previews-container>.nav-left:hover,.previews-container>.nav-right:hover{transform:scale(1.1)}.previews-container>.nav-left{margin-right:10px}.previews-container>.nav-right{margin-left:10px}}@-webkit-keyframes fadein-visible{from{opacity:0}to{opacity:1}}@keyframes fadein-visible{from{opacity:0}to{opacity:1}}@-webkit-keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@keyframes fadein-semi-visible05{from{opacity:0}to{opacity:.5}}@-webkit-keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@keyframes fadein-semi-visible08{from{opacity:0}to{opacity:.8}}@-webkit-keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}@keyframes fadein-semi-visible09{from{opacity:0}to{opacity:.9}}", ".arrow-preview-image,.empty-arrow-preview-image,.left-arrow-preview-image,.right-arrow-preview-image{width:15px;height:15px;opacity:.5}.empty-arrow-preview-image{background:#000;opacity:0}.left-arrow-preview-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMTQ1LjE4OCwyMzguNTc1bDIxNS41LTIxNS41YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xcy0xMy44LTUuMy0xOS4xLDBsLTIyNS4xLDIyNS4xYy01LjMsNS4zLTUuMywxMy44LDAsMTkuMWwyMjUuMSwyMjUgICBjMi42LDIuNiw2LjEsNCw5LjUsNHM2LjktMS4zLDkuNS00YzUuMy01LjMsNS4zLTEzLjgsMC0xOS4xTDE0NS4xODgsMjM4LjU3NXoiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.left-arrow-preview-image:hover{transform:scale(1.2)}.right-arrow-preview-image{background-image:url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/PjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ3Ny4xNzUgNDc3LjE3NSIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDc3LjE3NSA0NzcuMTc1OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjUxMnB4IiBoZWlnaHQ9IjUxMnB4Ij48Zz48cGF0aCBkPSJNMzYwLjczMSwyMjkuMDc1bC0yMjUuMS0yMjUuMWMtNS4zLTUuMy0xMy44LTUuMy0xOS4xLDBzLTUuMywxMy44LDAsMTkuMWwyMTUuNSwyMTUuNWwtMjE1LjUsMjE1LjUgICBjLTUuMyw1LjMtNS4zLDEzLjgsMCwxOS4xYzIuNiwyLjYsNi4xLDQsOS41LDRjMy40LDAsNi45LTEuMyw5LjUtNGwyMjUuMS0yMjUuMUMzNjUuOTMxLDI0Mi44NzUsMzY1LjkzMSwyMzQuMjc1LDM2MC43MzEsMjI5LjA3NXogICAiIGZpbGw9IiNGRkZGRkYiLz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PC9zdmc+);background-size:15px;transition:.5s}.right-arrow-preview-image:hover{transform:scale(1.2)}"]
          }]
        }], null, {
          clickPreview: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          currentImage: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          slideConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          previewConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with the loading spinner
       */


      var LoadingSpinnerComponent = function LoadingSpinnerComponent() {
        _classCallCheck(this, LoadingSpinnerComponent);

        /**
         * Enum of type `LoadingType` to choose the standard loading spinner.
         * Declared here to be used inside the template.
         */
        this.loadingStandard = _LoadingType.STANDARD;
        /**
         * Enum of type `LoadingType` to choose the bars loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingBars = _LoadingType.BARS;
        /**
         * Enum of type `LoadingType` to choose the circular loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingCircular = _LoadingType.CIRCULAR;
        /**
         * Enum of type `LoadingType` to choose the dots loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingDots = _LoadingType.DOTS;
        /**
         * Enum of type `LoadingType` to choose the cube flipping loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingCubeFlipping = _LoadingType.CUBE_FLIPPING;
        /**
         * Enum of type `LoadingType` to choose the circles loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingCircles = _LoadingType.CIRCLES;
        /**
         * Enum of type `LoadingType` to choose the explosing squares loading spinner.
         * Declared here to be used inside the template.
         */

        this.loadingExplosingSquares = _LoadingType.EXPLOSING_SQUARES;
      };

      LoadingSpinnerComponent.ɵfac = function LoadingSpinnerComponent_Factory(t) {
        return new (t || LoadingSpinnerComponent)();
      };

      LoadingSpinnerComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: LoadingSpinnerComponent,
        selectors: [["ks-loading-spinner"]],
        inputs: {
          loadingConfig: "loadingConfig",
          accessibilityConfig: "accessibilityConfig"
        },
        decls: 9,
        vars: 10,
        consts: [[3, "title"], [3, "ngSwitch"], [4, "ngSwitchCase"], [1, "cssload-loader"], [1, "cssload-inner", "cssload-one"], [1, "cssload-inner", "cssload-two"], [1, "cssload-inner", "cssload-three"], [1, "loader-bars"], [1, "loader-circular"], [1, "loader-dots"], [1, "cube-wrapper"], [1, "cube-folding"], [1, "leaf1"], [1, "leaf2"], [1, "leaf3"], [1, "leaf4"], ["id", "preloader"], ["id", "loader"], [1, "loader"]],
        template: function LoadingSpinnerComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementStart"](0, "div", 0);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerStart"](1, 1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](2, LoadingSpinnerComponent_ng_container_2_Template, 5, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](3, LoadingSpinnerComponent_ng_container_3_Template, 2, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](4, LoadingSpinnerComponent_ng_container_4_Template, 2, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](5, LoadingSpinnerComponent_ng_container_5_Template, 2, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](6, LoadingSpinnerComponent_ng_container_6_Template, 7, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](7, LoadingSpinnerComponent_ng_container_7_Template, 3, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](8, LoadingSpinnerComponent_ng_container_8_Template, 6, 0, "ng-container", 2);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementContainerEnd"]();

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵelementEnd"]();
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("title", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.loadingSpinnerTitle);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵattribute"]("aria-label", ctx.accessibilityConfig == null ? null : ctx.accessibilityConfig.loadingSpinnerAriaLabel);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitch", ctx.loadingConfig.type);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingStandard);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingBars);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingCircular);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingDots);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingCubeFlipping);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingCircles);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵadvance"](1);

            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngSwitchCase", ctx.loadingExplosingSquares);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgSwitch, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgSwitchCase],
        styles: [".cssload-loader[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;right:0;left:0;margin:auto;width:64px;height:64px;border-radius:50%;-o-border-radius:50%;-ms-border-radius:50%;-webkit-border-radius:50%;-moz-border-radius:50%;perspective:800px}.cssload-inner[_ngcontent-%COMP%]{position:absolute;width:100%;height:100%;box-sizing:border-box;-o-box-sizing:border-box;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;border-radius:50%;-o-border-radius:50%;-ms-border-radius:50%;-webkit-border-radius:50%;-moz-border-radius:50%}.cssload-inner.cssload-one[_ngcontent-%COMP%]{left:0;top:0;animation:.6s linear infinite cssload-rotate-one;-o-animation:.6s linear infinite cssload-rotate-one;-ms-animation:cssload-rotate-one .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-one;-moz-animation:.6s linear infinite cssload-rotate-one;border-bottom:3px solid rgba(255,255,255,.99)}.cssload-inner.cssload-two[_ngcontent-%COMP%]{right:0;top:0;animation:.6s linear infinite cssload-rotate-two;-o-animation:.6s linear infinite cssload-rotate-two;-ms-animation:cssload-rotate-two .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-two;-moz-animation:.6s linear infinite cssload-rotate-two;border-right:3px solid #fff}.cssload-inner.cssload-three[_ngcontent-%COMP%]{right:0;bottom:0;animation:.6s linear infinite cssload-rotate-three;-o-animation:.6s linear infinite cssload-rotate-three;-ms-animation:cssload-rotate-three .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-three;-moz-animation:.6s linear infinite cssload-rotate-three;border-top:3px solid #fff}@keyframes cssload-rotate-one{0%{transform:rotateX(35deg) rotateY(-45deg) rotateZ(0)}100%{transform:rotateX(35deg) rotateY(-45deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-one{0%{-webkit-transform:rotateX(35deg) rotateY(-45deg) rotateZ(0)}100%{-webkit-transform:rotateX(35deg) rotateY(-45deg) rotateZ(360deg)}}@keyframes cssload-rotate-two{0%{transform:rotateX(50deg) rotateY(10deg) rotateZ(0)}100%{transform:rotateX(50deg) rotateY(10deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-two{0%{-webkit-transform:rotateX(50deg) rotateY(10deg) rotateZ(0)}100%{-webkit-transform:rotateX(50deg) rotateY(10deg) rotateZ(360deg)}}@keyframes cssload-rotate-three{0%{transform:rotateX(35deg) rotateY(55deg) rotateZ(0)}100%{transform:rotateX(35deg) rotateY(55deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-three{0%{-webkit-transform:rotateX(35deg) rotateY(55deg) rotateZ(0)}100%{-webkit-transform:rotateX(35deg) rotateY(55deg) rotateZ(360deg)}}", ".loader-dots[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;right:0;left:0;color:#fefcff;font-size:10px;margin:auto;width:1em;height:1em;border-radius:50%;text-indent:-9999em;-webkit-animation:1.3s linear infinite load4;animation:1.3s linear infinite load4;transform:translateZ(0)}@-webkit-keyframes load4{0%,100%{box-shadow:0 -3em 0 .2em,2em -2em 0 0,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 0}12.5%{box-shadow:0 -3em 0 0,2em -2em 0 .2em,3em 0 0 0,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}25%{box-shadow:0 -3em 0 -.5em,2em -2em 0 0,3em 0 0 .2em,2em 2em 0 0,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}37.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 0,2em 2em 0 .2em,0 3em 0 0,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}50%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 0,0 3em 0 .2em,-2em 2em 0 0,-3em 0 0 -1em,-2em -2em 0 -1em}62.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 0,-2em 2em 0 .2em,-3em 0 0 0,-2em -2em 0 -1em}75%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 .2em,-2em -2em 0 0}87.5%{box-shadow:0 -3em 0 0,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 0,-2em -2em 0 .2em}}@keyframes load4{0%,100%{box-shadow:0 -3em 0 .2em,2em -2em 0 0,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 0}12.5%{box-shadow:0 -3em 0 0,2em -2em 0 .2em,3em 0 0 0,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}25%{box-shadow:0 -3em 0 -.5em,2em -2em 0 0,3em 0 0 .2em,2em 2em 0 0,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}37.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 0,2em 2em 0 .2em,0 3em 0 0,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}50%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 0,0 3em 0 .2em,-2em 2em 0 0,-3em 0 0 -1em,-2em -2em 0 -1em}62.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 0,-2em 2em 0 .2em,-3em 0 0 0,-2em -2em 0 -1em}75%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 .2em,-2em -2em 0 0}87.5%{box-shadow:0 -3em 0 0,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 0,-2em -2em 0 .2em}}", ".loader-bars[_ngcontent-%COMP%], .loader-bars[_ngcontent-%COMP%]:after, .loader-bars[_ngcontent-%COMP%]:before{background:#fefcff;-webkit-animation:1s ease-in-out infinite load1;animation:1s ease-in-out infinite load1;width:1em;height:4em}.loader-bars[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;right:0;left:0;color:#fefcff;text-indent:-9999em;margin:auto;font-size:11px;transform:translateZ(0);-webkit-animation-delay:-.16s;animation-delay:-.16s}.loader-bars[_ngcontent-%COMP%]:after, .loader-bars[_ngcontent-%COMP%]:before{position:absolute;top:0;content:''}.loader-bars[_ngcontent-%COMP%]:before{left:-1.5em;-webkit-animation-delay:-.32s;animation-delay:-.32s}.loader-bars[_ngcontent-%COMP%]:after{left:1.5em}@-webkit-keyframes load1{0%,100%,80%{box-shadow:0 0;height:4em}40%{box-shadow:0 -2em;height:5em}}@keyframes load1{0%,100%,80%{box-shadow:0 0;height:4em}40%{box-shadow:0 -2em;height:5em}}", ".loader-circular[_ngcontent-%COMP%], .loader-circular[_ngcontent-%COMP%]:after{border-radius:50%;width:10em;height:10em}.loader-circular[_ngcontent-%COMP%]{position:absolute;top:0;bottom:0;right:0;left:0;margin:auto;font-size:10px;text-indent:-9999em;border-top:1.1em solid rgba(255,255,255,.2);border-right:1.1em solid rgba(255,255,255,.2);border-bottom:1.1em solid rgba(255,255,255,.2);border-left:1.1em solid #fff;transform:translateZ(0);-webkit-animation:1.1s linear infinite load8;animation:1.1s linear infinite load8}@-webkit-keyframes load8{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes load8{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".cube-folding[_ngcontent-%COMP%]{width:50px;height:50px;display:inline-block;transform:rotate(45deg);font-size:0}.cube-folding[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:relative;width:25px;height:25px;transform:scale(1.1);display:inline-block}.cube-folding[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]::before{content:'';background-color:#fff;position:absolute;left:0;top:0;display:block;width:25px;height:25px;transform-origin:100% 100%;-webkit-animation:2.5s linear infinite both folding;animation:2.5s linear infinite both folding}.cube-folding[_ngcontent-%COMP%]   .leaf2[_ngcontent-%COMP%]{transform:rotateZ(90deg) scale(1.1)}.cube-folding[_ngcontent-%COMP%]   .leaf2[_ngcontent-%COMP%]::before{-webkit-animation-delay:.3s;animation-delay:.3s;background-color:#f2f2f2}.cube-folding[_ngcontent-%COMP%]   .leaf3[_ngcontent-%COMP%]{transform:rotateZ(270deg) scale(1.1)}.cube-folding[_ngcontent-%COMP%]   .leaf3[_ngcontent-%COMP%]::before{-webkit-animation-delay:.9s;animation-delay:.9s;background-color:#f2f2f2}.cube-folding[_ngcontent-%COMP%]   .leaf4[_ngcontent-%COMP%]{transform:rotateZ(180deg) scale(1.1)}.cube-folding[_ngcontent-%COMP%]   .leaf4[_ngcontent-%COMP%]::before{-webkit-animation-delay:.6s;animation-delay:.6s;background-color:#e6e6e6}@-webkit-keyframes folding{0%,10%{transform:perspective(140px) rotateX(-180deg);opacity:0}25%,75%{transform:perspective(140px) rotateX(0);opacity:1}100%,90%{transform:perspective(140px) rotateY(180deg);opacity:0}}@keyframes folding{0%,10%{transform:perspective(140px) rotateX(-180deg);opacity:0}25%,75%{transform:perspective(140px) rotateX(0);opacity:1}100%,90%{transform:perspective(140px) rotateY(180deg);opacity:0}}.cube-wrapper[_ngcontent-%COMP%]{position:fixed;left:50%;top:50%;margin-top:-50px;margin-left:-50px;width:100px;height:100px;text-align:center}@-webkit-keyframes text{100%{top:35px}}@keyframes text{100%{top:35px}}@-webkit-keyframes shadow{100%{bottom:-18px;width:100px}}@keyframes shadow{100%{bottom:-18px;width:100px}}", "#preloader[_ngcontent-%COMP%]{position:fixed;top:0;left:0;width:100%;height:100%}#loader[_ngcontent-%COMP%]{display:block;position:relative;left:50%;top:50%;width:100px;height:100px;margin:-75px 0 0 -75px;border-radius:50%;border:3px solid transparent;border-top-color:#b4b4b4;-webkit-animation:2s linear infinite spin;animation:2s linear infinite spin}#loader[_ngcontent-%COMP%]:before{content:\"\";position:absolute;top:5px;left:5px;right:5px;bottom:5px;border-radius:50%;border:3px solid transparent;border-top-color:#d9d9d9;-webkit-animation:3s linear infinite spin;animation:3s linear infinite spin}#loader[_ngcontent-%COMP%]:after{content:\"\";position:absolute;top:15px;left:15px;right:15px;bottom:15px;border-radius:50%;border:3px solid transparent;border-top-color:#fff;-webkit-animation:1.5s linear infinite spin;animation:1.5s linear infinite spin}@-webkit-keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", "@-webkit-keyframes loader{0%,10%,100%{width:60px;height:60px}65%{width:150px;height:150px}}@keyframes loader{0%,10%,100%{width:60px;height:60px}65%{width:150px;height:150px}}@-webkit-keyframes loaderBlock{0%,30%{transform:rotate(0)}55%{background-color:#b4b4b4}100%{transform:rotate(90deg)}}@keyframes loaderBlock{0%,30%{transform:rotate(0)}55%{background-color:#b4b4b4}100%{transform:rotate(90deg)}}@-webkit-keyframes loaderBlockInverse{0%,20%{transform:rotate(0)}55%{background-color:#d9d9d9}100%{transform:rotate(-90deg)}}@keyframes loaderBlockInverse{0%,20%{transform:rotate(0)}55%{background-color:#d9d9d9}100%{transform:rotate(-90deg)}}.loader[_ngcontent-%COMP%]{position:absolute;top:50%;left:50%;width:60px;height:60px;transform:translate(-50%,-50%) rotate(45deg) translate3d(0,0,0);-webkit-animation:1.2s ease-in-out infinite loader;animation:1.2s ease-in-out infinite loader}.loader[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{position:absolute;display:block;width:40px;height:40px;background-color:#fff;-webkit-animation:1.2s ease-in-out infinite both loaderBlock;animation:1.2s ease-in-out infinite both loaderBlock}.loader[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(1){top:0;left:0}.loader[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(2){top:0;right:0;-webkit-animation:1.2s ease-in-out infinite both loaderBlockInverse;animation:1.2s ease-in-out infinite both loaderBlockInverse}.loader[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(3){bottom:0;left:0;-webkit-animation:1.2s ease-in-out infinite both loaderBlockInverse;animation:1.2s ease-in-out infinite both loaderBlockInverse}.loader[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]:nth-child(4){bottom:0;right:0}"],
        changeDetection: 0
      });
      LoadingSpinnerComponent.propDecorators = {
        loadingConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](LoadingSpinnerComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-loading-spinner',
            template: "<div [attr.aria-label]=\"accessibilityConfig?.loadingSpinnerAriaLabel\"\n     [title]=\"accessibilityConfig?.loadingSpinnerTitle\">\n\n  <ng-container [ngSwitch]=\"loadingConfig.type\">\n    <ng-container *ngSwitchCase=\"loadingStandard\">\n      <div class=\"cssload-loader\">\n        <div class=\"cssload-inner cssload-one\"></div>\n        <div class=\"cssload-inner cssload-two\"></div>\n        <div class=\"cssload-inner cssload-three\"></div>\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingBars\">\n      <div class=\"loader-bars\">\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingCircular\">\n      <div class=\"loader-circular\">\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingDots\">\n      <div class=\"loader-dots\">\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingCubeFlipping\">\n      <div class=\"cube-wrapper\">\n        <div class=\"cube-folding\">\n          <span class=\"leaf1\"></span>\n          <span class=\"leaf2\"></span>\n          <span class=\"leaf3\"></span>\n          <span class=\"leaf4\"></span>\n        </div>\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingCircles\">\n      <div id=\"preloader\">\n        <div id=\"loader\"></div>\n      </div>\n    </ng-container>\n    <ng-container *ngSwitchCase=\"loadingExplosingSquares\">\n      <div class=\"loader\">\n        <span></span>\n        <span></span>\n        <span></span>\n        <span></span>\n      </div>\n    </ng-container>\n    <!--<ng-container *ngSwitchDefault>-->\n    <!---->\n    <!--</ng-container>-->\n  </ng-container>\n</div>\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [".cssload-loader{position:absolute;top:0;bottom:0;right:0;left:0;margin:auto;width:64px;height:64px;border-radius:50%;-o-border-radius:50%;-ms-border-radius:50%;-webkit-border-radius:50%;-moz-border-radius:50%;perspective:800px}.cssload-inner{position:absolute;width:100%;height:100%;box-sizing:border-box;-o-box-sizing:border-box;-ms-box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box;border-radius:50%;-o-border-radius:50%;-ms-border-radius:50%;-webkit-border-radius:50%;-moz-border-radius:50%}.cssload-inner.cssload-one{left:0;top:0;animation:.6s linear infinite cssload-rotate-one;-o-animation:.6s linear infinite cssload-rotate-one;-ms-animation:cssload-rotate-one .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-one;-moz-animation:.6s linear infinite cssload-rotate-one;border-bottom:3px solid rgba(255,255,255,.99)}.cssload-inner.cssload-two{right:0;top:0;animation:.6s linear infinite cssload-rotate-two;-o-animation:.6s linear infinite cssload-rotate-two;-ms-animation:cssload-rotate-two .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-two;-moz-animation:.6s linear infinite cssload-rotate-two;border-right:3px solid #fff}.cssload-inner.cssload-three{right:0;bottom:0;animation:.6s linear infinite cssload-rotate-three;-o-animation:.6s linear infinite cssload-rotate-three;-ms-animation:cssload-rotate-three .6s linear infinite;-webkit-animation:.6s linear infinite cssload-rotate-three;-moz-animation:.6s linear infinite cssload-rotate-three;border-top:3px solid #fff}@keyframes cssload-rotate-one{0%{transform:rotateX(35deg) rotateY(-45deg) rotateZ(0)}100%{transform:rotateX(35deg) rotateY(-45deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-one{0%{-webkit-transform:rotateX(35deg) rotateY(-45deg) rotateZ(0)}100%{-webkit-transform:rotateX(35deg) rotateY(-45deg) rotateZ(360deg)}}@keyframes cssload-rotate-two{0%{transform:rotateX(50deg) rotateY(10deg) rotateZ(0)}100%{transform:rotateX(50deg) rotateY(10deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-two{0%{-webkit-transform:rotateX(50deg) rotateY(10deg) rotateZ(0)}100%{-webkit-transform:rotateX(50deg) rotateY(10deg) rotateZ(360deg)}}@keyframes cssload-rotate-three{0%{transform:rotateX(35deg) rotateY(55deg) rotateZ(0)}100%{transform:rotateX(35deg) rotateY(55deg) rotateZ(360deg)}}@-webkit-keyframes cssload-rotate-three{0%{-webkit-transform:rotateX(35deg) rotateY(55deg) rotateZ(0)}100%{-webkit-transform:rotateX(35deg) rotateY(55deg) rotateZ(360deg)}}", ".loader-dots{position:absolute;top:0;bottom:0;right:0;left:0;color:#fefcff;font-size:10px;margin:auto;width:1em;height:1em;border-radius:50%;text-indent:-9999em;-webkit-animation:1.3s linear infinite load4;animation:1.3s linear infinite load4;transform:translateZ(0)}@-webkit-keyframes load4{0%,100%{box-shadow:0 -3em 0 .2em,2em -2em 0 0,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 0}12.5%{box-shadow:0 -3em 0 0,2em -2em 0 .2em,3em 0 0 0,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}25%{box-shadow:0 -3em 0 -.5em,2em -2em 0 0,3em 0 0 .2em,2em 2em 0 0,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}37.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 0,2em 2em 0 .2em,0 3em 0 0,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}50%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 0,0 3em 0 .2em,-2em 2em 0 0,-3em 0 0 -1em,-2em -2em 0 -1em}62.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 0,-2em 2em 0 .2em,-3em 0 0 0,-2em -2em 0 -1em}75%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 .2em,-2em -2em 0 0}87.5%{box-shadow:0 -3em 0 0,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 0,-2em -2em 0 .2em}}@keyframes load4{0%,100%{box-shadow:0 -3em 0 .2em,2em -2em 0 0,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 0}12.5%{box-shadow:0 -3em 0 0,2em -2em 0 .2em,3em 0 0 0,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}25%{box-shadow:0 -3em 0 -.5em,2em -2em 0 0,3em 0 0 .2em,2em 2em 0 0,0 3em 0 -1em,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}37.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 0,2em 2em 0 .2em,0 3em 0 0,-2em 2em 0 -1em,-3em 0 0 -1em,-2em -2em 0 -1em}50%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 0,0 3em 0 .2em,-2em 2em 0 0,-3em 0 0 -1em,-2em -2em 0 -1em}62.5%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 0,-2em 2em 0 .2em,-3em 0 0 0,-2em -2em 0 -1em}75%{box-shadow:0 -3em 0 -1em,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 .2em,-2em -2em 0 0}87.5%{box-shadow:0 -3em 0 0,2em -2em 0 -1em,3em 0 0 -1em,2em 2em 0 -1em,0 3em 0 -1em,-2em 2em 0 0,-3em 0 0 0,-2em -2em 0 .2em}}", ".loader-bars,.loader-bars:after,.loader-bars:before{background:#fefcff;-webkit-animation:1s ease-in-out infinite load1;animation:1s ease-in-out infinite load1;width:1em;height:4em}.loader-bars{position:absolute;top:0;bottom:0;right:0;left:0;color:#fefcff;text-indent:-9999em;margin:auto;font-size:11px;transform:translateZ(0);-webkit-animation-delay:-.16s;animation-delay:-.16s}.loader-bars:after,.loader-bars:before{position:absolute;top:0;content:''}.loader-bars:before{left:-1.5em;-webkit-animation-delay:-.32s;animation-delay:-.32s}.loader-bars:after{left:1.5em}@-webkit-keyframes load1{0%,100%,80%{box-shadow:0 0;height:4em}40%{box-shadow:0 -2em;height:5em}}@keyframes load1{0%,100%,80%{box-shadow:0 0;height:4em}40%{box-shadow:0 -2em;height:5em}}", ".loader-circular,.loader-circular:after{border-radius:50%;width:10em;height:10em}.loader-circular{position:absolute;top:0;bottom:0;right:0;left:0;margin:auto;font-size:10px;text-indent:-9999em;border-top:1.1em solid rgba(255,255,255,.2);border-right:1.1em solid rgba(255,255,255,.2);border-bottom:1.1em solid rgba(255,255,255,.2);border-left:1.1em solid #fff;transform:translateZ(0);-webkit-animation:1.1s linear infinite load8;animation:1.1s linear infinite load8}@-webkit-keyframes load8{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes load8{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", ".cube-folding{width:50px;height:50px;display:inline-block;transform:rotate(45deg);font-size:0}.cube-folding span{position:relative;width:25px;height:25px;transform:scale(1.1);display:inline-block}.cube-folding span::before{content:'';background-color:#fff;position:absolute;left:0;top:0;display:block;width:25px;height:25px;transform-origin:100% 100%;-webkit-animation:2.5s linear infinite both folding;animation:2.5s linear infinite both folding}.cube-folding .leaf2{transform:rotateZ(90deg) scale(1.1)}.cube-folding .leaf2::before{-webkit-animation-delay:.3s;animation-delay:.3s;background-color:#f2f2f2}.cube-folding .leaf3{transform:rotateZ(270deg) scale(1.1)}.cube-folding .leaf3::before{-webkit-animation-delay:.9s;animation-delay:.9s;background-color:#f2f2f2}.cube-folding .leaf4{transform:rotateZ(180deg) scale(1.1)}.cube-folding .leaf4::before{-webkit-animation-delay:.6s;animation-delay:.6s;background-color:#e6e6e6}@-webkit-keyframes folding{0%,10%{transform:perspective(140px) rotateX(-180deg);opacity:0}25%,75%{transform:perspective(140px) rotateX(0);opacity:1}100%,90%{transform:perspective(140px) rotateY(180deg);opacity:0}}@keyframes folding{0%,10%{transform:perspective(140px) rotateX(-180deg);opacity:0}25%,75%{transform:perspective(140px) rotateX(0);opacity:1}100%,90%{transform:perspective(140px) rotateY(180deg);opacity:0}}.cube-wrapper{position:fixed;left:50%;top:50%;margin-top:-50px;margin-left:-50px;width:100px;height:100px;text-align:center}@-webkit-keyframes text{100%{top:35px}}@keyframes text{100%{top:35px}}@-webkit-keyframes shadow{100%{bottom:-18px;width:100px}}@keyframes shadow{100%{bottom:-18px;width:100px}}", "#preloader{position:fixed;top:0;left:0;width:100%;height:100%}#loader{display:block;position:relative;left:50%;top:50%;width:100px;height:100px;margin:-75px 0 0 -75px;border-radius:50%;border:3px solid transparent;border-top-color:#b4b4b4;-webkit-animation:2s linear infinite spin;animation:2s linear infinite spin}#loader:before{content:\"\";position:absolute;top:5px;left:5px;right:5px;bottom:5px;border-radius:50%;border:3px solid transparent;border-top-color:#d9d9d9;-webkit-animation:3s linear infinite spin;animation:3s linear infinite spin}#loader:after{content:\"\";position:absolute;top:15px;left:15px;right:15px;bottom:15px;border-radius:50%;border:3px solid transparent;border-top-color:#fff;-webkit-animation:1.5s linear infinite spin;animation:1.5s linear infinite spin}@-webkit-keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}", "@-webkit-keyframes loader{0%,10%,100%{width:60px;height:60px}65%{width:150px;height:150px}}@keyframes loader{0%,10%,100%{width:60px;height:60px}65%{width:150px;height:150px}}@-webkit-keyframes loaderBlock{0%,30%{transform:rotate(0)}55%{background-color:#b4b4b4}100%{transform:rotate(90deg)}}@keyframes loaderBlock{0%,30%{transform:rotate(0)}55%{background-color:#b4b4b4}100%{transform:rotate(90deg)}}@-webkit-keyframes loaderBlockInverse{0%,20%{transform:rotate(0)}55%{background-color:#d9d9d9}100%{transform:rotate(-90deg)}}@keyframes loaderBlockInverse{0%,20%{transform:rotate(0)}55%{background-color:#d9d9d9}100%{transform:rotate(-90deg)}}.loader{position:absolute;top:50%;left:50%;width:60px;height:60px;transform:translate(-50%,-50%) rotate(45deg) translate3d(0,0,0);-webkit-animation:1.2s ease-in-out infinite loader;animation:1.2s ease-in-out infinite loader}.loader span{position:absolute;display:block;width:40px;height:40px;background-color:#fff;-webkit-animation:1.2s ease-in-out infinite both loaderBlock;animation:1.2s ease-in-out infinite both loaderBlock}.loader span:nth-child(1){top:0;left:0}.loader span:nth-child(2){top:0;right:0;-webkit-animation:1.2s ease-in-out infinite both loaderBlockInverse;animation:1.2s ease-in-out infinite both loaderBlockInverse}.loader span:nth-child(3){bottom:0;left:0;-webkit-animation:1.2s ease-in-out infinite both loaderBlockInverse;animation:1.2s ease-in-out infinite both loaderBlockInverse}.loader span:nth-child(4){bottom:0;right:0}"]
          }]
        }], function () {
          return [];
        }, {
          loadingConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Component with the gallery of thumbs.
       * In receives an array of Images, a boolean to show/hide
       * the gallery (feature used by imagePointer) and a config
       * object to customize the behaviour of this component.
       * Also, it emits click events as outputs.
       */


      var PlainGalleryComponent = /*#__PURE__*/function () {
        function PlainGalleryComponent() {
          _classCallCheck(this, PlainGalleryComponent);

          /**
           * Output to emit an event when an image is changed.
           */
          this.show = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
          /**
           * Bi-dimensional array of `Image` object to store images to display as plain gallery.
           * [] by default.
           */

          this.imageGrid = [];
          /**
           * Boolean passed as input to `ks-wrap` directive to configure flex-wrap css property.
           * However it's not enough, because you need to limit the width using `widthStyle` public variable.
           * For more info check https://developer.mozilla.org/it/docs/Web/CSS/flex-wrap
           */

          this.wrapStyle = false;
          /**
           * String passed as input to `ks-wrap` directive to set width to be able to force overflow.
           * In this way, `wrapStyle` (flex-wrap css property) will be used as requested.
           */

          this.widthStyle = '';
          /**
           * Default image size object
           */

          this.defaultSize = {
            width: '50px',
            height: 'auto'
          };
          /**
           * Default layout config object
           * Note that length=-1 means infinity
           */

          this.defaultLayout = new _LineLayout(this.defaultSize, {
            length: -1,
            wrap: false
          }, 'flex-start');
          /**
           * Default plain gallery config object
           */

          this.defaultPlainConfig = {
            strategy: _PlainGalleryStrategy.ROW,
            layout: this.defaultLayout,
            advanced: {
              aTags: false,
              additionalBackground: '50% 50%/cover'
            }
          };
        }
        /**
         * Method ´ngOnChanges´ to update both `imageGrid` and`configPlainGallery`.
         * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
         * In particular, it's called when any data-bound property of a directive changes!!!
         * @param {?} changes
         * @return {?}
         */


        _createClass(PlainGalleryComponent, [{
          key: "ngOnChanges",
          value: function ngOnChanges(changes) {
            /** @type {?} */
            var imagesChange = changes.images;
            /** @type {?} */

            var configChange = changes.plainGalleryConfig; // I'm using !change.firstChange because the first time will be called both onInit and onChange and I don't
            // want to execute initialization two times.

            if (configChange && !configChange.firstChange && (configChange.previousValue !== configChange.currentValue || !configChange.previousValue && !configChange.currentValue)) {
              this.configPlainGallery = this.initPlainGalleryConfig();
            }

            if (imagesChange && !imagesChange.firstChange && imagesChange.previousValue !== imagesChange.currentValue) {
              this.initImageGrid();
            }
          }
          /**
           * Method ´ngOnInit´ to init both `configPlainGallery` calling `initPlainGalleryConfig()`
           * and `imageGrid invoking `initImageGrid()`.
           * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
           * In particular, it's called only one time!!!
           * @return {?}
           */

        }, {
          key: "ngOnInit",
          value: function ngOnInit() {
            this.configPlainGallery = this.initPlainGalleryConfig();
            this.initImageGrid();
          }
          /**
           * Method called when you click on an image of the plain (or inline) gallery.
           * This will emit the show event with the index number as payload.
           * @param {?} index
           * @return {?}
           */

        }, {
          key: "showModalGallery",
          value: function showModalGallery(index) {
            this.show.emit(index);
          }
          /**
           * Method called when you click on an image of the plain (or inline) gallery.
           * This will emit the show event with the image as payload.
           * @param {?} img
           * @return {?}
           */

        }, {
          key: "showModalGalleryByImage",
          value: function showModalGalleryByImage(img) {
            /** @type {?} */
            var index = this.images.findIndex(
            /**
            * @param {?} val
            * @return {?}
            */
            function (val) {
              return val && img && val.id === img.id;
            });
            this.showModalGallery(index);
          }
          /**
           * Method to get `alt attribute`.
           * `alt` specifies an alternate text for an image, if the image cannot be displayed.
           * @param {?} image
           * @return {?} string alt description of the image
           */

        }, {
          key: "getAltPlainDescriptionByImage",
          value: function getAltPlainDescriptionByImage(image) {
            if (!image) {
              return '';
            }

            return image.plain && image.plain.description ? image.plain.description : "Image ".concat(getIndex(image, this.images) + 1);
          }
          /**
           * Method to get the title for an image.
           * @param {?} image
           * @return {?} string the title of the input image
           */

        }, {
          key: "getTitleDisplay",
          value: function getTitleDisplay(image) {
            /** @type {?} */
            var description = '';

            if (image.plain && image.plain.description) {
              description = image.plain.description;
            } else if (image.modal && image.modal.description) {
              description = image.modal.description;
            }
            /** @type {?} */


            var currentIndex = getIndex(image, this.images);
            /** @type {?} */

            var prevDescription = 'Image ' + (currentIndex + 1) + '/' + this.images.length;
            /** @type {?} */

            var currImgDescription = description ? description : '';

            if (currImgDescription !== '') {
              currImgDescription = ' - ' + currImgDescription;
            }

            return prevDescription + currImgDescription;
          }
          /**
           * Method used in the template to track ids in ngFor.
           * @param {?} index
           * @param {?} item
           * @return {?} number the id of the item
           */

        }, {
          key: "trackById",
          value: function trackById(index, item) {
            return item.id;
          }
          /**
           * Private method to build and return a `PlainGalleryConfig` object, proving also default values.
           * @throws an Error if layout and strategy aren't compatible
           * @private
           * @return {?} PlainGalleryConfig the plain gallery configuration
           */

        }, {
          key: "initPlainGalleryConfig",
          value: function initPlainGalleryConfig() {
            /** @type {?} */
            var config = Object.assign({}, this.defaultPlainConfig, this.plainGalleryConfig);

            if (config.layout instanceof _LineLayout) {
              if (config.strategy !== _PlainGalleryStrategy.ROW && config.strategy !== _PlainGalleryStrategy.COLUMN) {
                throw new Error('LineLayout requires either ROW or COLUMN strategy');
              }

              if (!config.layout || !config.layout.breakConfig) {
                throw new Error('Both layout and breakConfig must be valid');
              }
            }

            if (config.layout instanceof _GridLayout) {
              if (config.strategy !== _PlainGalleryStrategy.GRID) {
                throw new Error('GridLayout requires GRID strategy');
              }

              if (!config.layout || !config.layout.breakConfig) {
                throw new Error('Both layout and breakConfig must be valid');
              } // force wrap for grid layout


              config.layout.breakConfig.wrap = true;
            }

            if (config.layout instanceof _AdvancedLayout) {
              if (config.strategy !== _PlainGalleryStrategy.CUSTOM) {
                throw new Error('AdvancedLayout requires CUSTOM strategy');
              }
            }

            return config;
          }
          /**
           * Private method to init both `imageGrid` and other style variables,
           * based on the layout type.
           * @private
           * @return {?}
           */

        }, {
          key: "initImageGrid",
          value: function initImageGrid() {
            var _this23 = this;

            /** @type {?} */
            var config = this.configPlainGallery; // reset the array to prevent issues in case of GridLayout

            this.imageGrid = [];

            if (config.layout instanceof _LineLayout) {
              /** @type {?} */
              var layout = config.layout;
              /** @type {?} */

              var row = this.images.filter(
              /**
              * @param {?} val
              * @param {?} i
              * @return {?}
              */
              function (val, i) {
                return i < layout.breakConfig.length || layout.breakConfig.length === -1;
              });
              this.imageGrid = [row];
              this.size = config.layout.size;

              switch (config.strategy) {
                case _PlainGalleryStrategy.ROW:
                  this.directionStyle = 'row';
                  break;

                case _PlainGalleryStrategy.COLUMN:
                  this.directionStyle = 'column';
                  this.wrapStyle = layout.breakConfig.wrap;
                  break;
              }

              this.justifyStyle = layout.justify;
            }

            if (config.layout instanceof _GridLayout) {
              (function () {
                /** @type {?} */
                var layout = config.layout;
                /** @type {?} */

                var count = Math.ceil(_this23.images.length / layout.breakConfig.length);
                /** @type {?} */

                var start = 0;
                /** @type {?} */

                var end = layout.breakConfig.length - 1;

                for (var j = 0; j < count; j++) {
                  /** @type {?} */
                  var _row = _this23.images.filter(
                  /**
                  * @param {?} val
                  * @param {?} i
                  * @return {?}
                  */
                  function (val, i) {
                    return i >= start && i <= end;
                  });

                  _this23.imageGrid.push(_row);

                  start = end + 1;
                  end = start + layout.breakConfig.length - 1;
                }

                _this23.size = config.layout.size;
                /** @type {?} */

                var pixels = +layout.size.width.replace('px', '');
                _this23.widthStyle = pixels * layout.breakConfig.length + pixels / 2 + 'px';
                _this23.wrapStyle = layout.breakConfig.wrap;
                _this23.directionStyle = 'row';
              })();
            }

            if (config.layout instanceof _AdvancedLayout) {
              this.imageGrid = [this.images];
            }
          }
        }]);

        return PlainGalleryComponent;
      }();

      PlainGalleryComponent.ɵfac = function PlainGalleryComponent_Factory(t) {
        return new (t || PlainGalleryComponent)();
      };

      PlainGalleryComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineComponent"]({
        type: PlainGalleryComponent,
        selectors: [["ks-plain-gallery"]],
        inputs: {
          images: "images",
          showGallery: "showGallery",
          plainGalleryConfig: "plainGalleryConfig",
          accessibilityConfig: "accessibilityConfig"
        },
        outputs: {
          show: "show"
        },
        features: [_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵNgOnChangesFeature"]],
        decls: 1,
        vars: 1,
        consts: [["class", "plain-container", "ksWrap", "", "ksDirection", "", 3, "wrap", "width", "direction", "justify", "title", 4, "ngIf"], ["ksWrap", "", "ksDirection", "", 1, "plain-container", 3, "wrap", "width", "direction", "justify", "title"], [4, "ngFor", "ngForOf"], [4, "ngIf", "ngIfElse"], ["aTags", ""], ["class", "image", "ksSize", "", "role", "img", 3, "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup", 4, "ngIf"], ["ksSize", "", "role", "img", 1, "image", 3, "src", "sizeConfig", "title", "alt", "tabindex", "click", "keyup"], ["class", "a-tag-image", "ksATagBgImage", "", "ksSize", "", 3, "image", "style", "sizeConfig", "title", "tabindex", "click", "keyup", 4, "ngIf"], ["ksATagBgImage", "", "ksSize", "", 1, "a-tag-image", 3, "image", "sizeConfig", "title", "tabindex", "click", "keyup"]],
        template: function PlainGalleryComponent_Template(rf, ctx) {
          if (rf & 1) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵtemplate"](0, PlainGalleryComponent_div_0_Template, 2, 7, "div", 0);
          }

          if (rf & 2) {
            _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵproperty"]("ngIf", ctx.showGallery);
          }
        },
        directives: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.NgIf, WrapDirective, DirectionDirective, _angular_common__WEBPACK_IMPORTED_MODULE_1__.NgForOf, SizeDirective, ATagBgImageDirective],
        styles: [".plain-container[_ngcontent-%COMP%]{align-items:center;display:flex}.plain-container[_ngcontent-%COMP%]   .image[_ngcontent-%COMP%]{cursor:pointer;height:auto;width:50px;margin:2px}.plain-container[_ngcontent-%COMP%]   .a-tag-image[_ngcontent-%COMP%]{cursor:pointer;margin:2px}"],
        changeDetection: 0
      });
      PlainGalleryComponent.propDecorators = {
        images: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        showGallery: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        plainGalleryConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        accessibilityConfig: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
        }],
        show: [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
        }]
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](PlainGalleryComponent, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Component,
          args: [{
            selector: 'ks-plain-gallery',
            template: "<div *ngIf=\"showGallery\"\n     class=\"plain-container\"\n     ksWrap [wrap]=\"wrapStyle\" [width]=\"widthStyle\"\n     ksDirection [direction]=\"directionStyle\" [justify]=\"justifyStyle\"\n     [attr.aria-label]=\"accessibilityConfig?.plainGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig?.plainGalleryContentTitle\">\n\n  <ng-container *ngFor=\"let imgRow of imageGrid; let i = index\">\n    <ng-container *ngFor=\"let imgCol of imgRow; let j = index\">\n\n      <ng-container *ngIf=\"!configPlainGallery.advanced?.aTags; else aTags\">\n        <img *ngIf=\"imgCol?.modal?.img\"\n             [src]=\"imgCol.plain?.img ? imgCol.plain.img : imgCol.modal.img\"\n             class=\"image\"\n             ksSize [sizeConfig]=\"{width: size?.width, height: size?.height}\"\n             [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n             [title]=\"imgCol.plain?.title ? imgCol.plain.title : getTitleDisplay(imgCol)\"\n             alt=\"{{imgCol.plain?.alt ? imgCol.plain.alt : getAltPlainDescriptionByImage(imgCol)}}\"\n             [tabindex]=\"0\" role=\"img\"\n             (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"showModalGalleryByImage(imgCol)\"/>\n      </ng-container>\n\n      <!-- Add directive to set background with the image url as param to pass thumb or img-->\n      <!-- to do something like this <a style=\"background: url('path to image') 50% 50%/cover\">.-->\n      <ng-template #aTags>\n        <a *ngIf=\"imgCol?.modal?.img\"\n           class=\"a-tag-image\"\n           ksATagBgImage [image]=\"imgCol\" [style]=\"configPlainGallery.advanced?.additionalBackground\"\n           ksSize [sizeConfig]=\"{width: size?.width, height: size?.height}\"\n           [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n           [title]=\"imgCol.plain?.title ? imgCol.plain.title : getTitleDisplay(imgCol)\"\n           [tabindex]=\"0\"\n           (click)=\"showModalGallery(j)\" (keyup)=\"showModalGallery(j)\"></a>\n      </ng-template>\n\n    </ng-container>\n  </ng-container>\n\n</div>\n\n",
            changeDetection: _angular_core__WEBPACK_IMPORTED_MODULE_0__.ChangeDetectionStrategy.OnPush,
            styles: [".plain-container{align-items:center;display:flex}.plain-container .image{cursor:pointer;height:auto;width:50px;margin:2px}.plain-container .a-tag-image{cursor:pointer;margin:2px}"]
          }]
        }], function () {
          return [];
        }, {
          show: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Output
          }],
          images: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          showGallery: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          plainGalleryConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }],
          accessibilityConfig: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Input
          }]
        });
      })();
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * Array of all components.
       * @type {?}
       */


      var COMPONENTS = [BackgroundComponent, PlainGalleryComponent, ModalGalleryComponent, CarouselComponent, CarouselPreviewsComponent, UpperButtonsComponent, DotsComponent, PreviewsComponent, CurrentImageComponent, LoadingSpinnerComponent, AccessibleComponent];
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */
      // to prevent bad scrolling behaviour on mobile phone with carousels.
      // From @mohaxspb (https://github.com/Ks89/angular-modal-gallery/pull/187)

      var KsHammerGestureConfig = /*#__PURE__*/function (_angular_platform_bro) {
        _inherits(KsHammerGestureConfig, _angular_platform_bro);

        var _super8 = _createSuper(KsHammerGestureConfig);

        function KsHammerGestureConfig() {
          _classCallCheck(this, KsHammerGestureConfig);

          return _super8.apply(this, arguments);
        }

        _createClass(KsHammerGestureConfig, [{
          key: "buildHammer",
          value:
          /**
           * @param {?} element
           * @return {?}
           */
          function buildHammer(element) {
            return new Hammer(element, {
              touchAction: 'pan-y'
            });
          }
        }]);

        return KsHammerGestureConfig;
      }(_angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.HammerGestureConfig);

      KsHammerGestureConfig.ɵfac = /*@__PURE__*/function () {
        var ɵKsHammerGestureConfig_BaseFactory;
        return function KsHammerGestureConfig_Factory(t) {
          return (ɵKsHammerGestureConfig_BaseFactory || (ɵKsHammerGestureConfig_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](KsHammerGestureConfig)))(t || KsHammerGestureConfig);
        };
      }();

      KsHammerGestureConfig.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
        token: KsHammerGestureConfig,
        factory: KsHammerGestureConfig.ɵfac
      });
      /**
       * Module to import it in the root module of your application.
       */

      var _GalleryModule = /*#__PURE__*/function () {
        function _GalleryModule() {
          _classCallCheck(this, _GalleryModule);
        }

        _createClass(_GalleryModule, null, [{
          key: "forRoot",
          value:
          /**
           * Importing with '.forRoot()' is deprecated. I'll provide a new way to do this in next releases.
           * Will be removed in 8.0.0 or 9.0.0
           * @param {?=} config
           * @return {?}
           */
          function forRoot(config) {
            return {
              ngModule: _GalleryModule,
              providers: [{
                provide: KEYBOARD_CONFIGURATION,
                useValue: config ? config : {}
              }, {
                provide: KeyboardService,
                useFactory: setupKeyboardService,
                deps: [KEYBOARD_CONFIGURATION]
              }]
            };
          }
        }]);

        return _GalleryModule;
      }();

      _GalleryModule.ɵfac = function GalleryModule_Factory(t) {
        return new (t || _GalleryModule)();
      };

      _GalleryModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineNgModule"]({
        type: _GalleryModule
      });
      _GalleryModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjector"]({
        providers: [{
          provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.HAMMER_GESTURE_CONFIG,
          useClass: KsHammerGestureConfig
        }],
        imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule]]
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](_GalleryModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.NgModule,
          args: [{
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule],
            declarations: [COMPONENTS, DIRECTIVES],
            exports: [ModalGalleryComponent, CarouselComponent],
            providers: [{
              provide: _angular_platform_browser__WEBPACK_IMPORTED_MODULE_8__.HAMMER_GESTURE_CONFIG,
              useClass: KsHammerGestureConfig
            }]
          }]
        }], null, null);
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵsetNgModuleScope"](_GalleryModule, {
          declarations: function declarations() {
            return [BackgroundComponent, PlainGalleryComponent, ModalGalleryComponent, CarouselComponent, CarouselPreviewsComponent, UpperButtonsComponent, DotsComponent, PreviewsComponent, CurrentImageComponent, LoadingSpinnerComponent, AccessibleComponent, ClickOutsideDirective, SizeDirective, KeyboardNavigationDirective, WrapDirective, DirectionDirective, ATagBgImageDirective, DescriptionDirective, MarginDirective, MaxSizeDirective];
          },
          imports: function imports() {
            return [_angular_common__WEBPACK_IMPORTED_MODULE_1__.CommonModule];
          },
          exports: function exports() {
            return [ModalGalleryComponent, CarouselComponent];
          }
        });
      })();
      /**
       * Function to setup the keyboard service inside the `forRoot` method.
       * @param {?} injector
       * @return {?} KeyboardService an instance of the `KeyboardService`
       */


      function setupKeyboardService(injector) {
        return new KeyboardService(injector);
      }
      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */

      /**
       * @fileoverview added by tsickle
       * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
       */
      //# sourceMappingURL=ks89-angular-modal-gallery.js.map

      /***/

    },

    /***/
    11524: function _(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*! Hammer.JS - v2.0.7 - 2016-04-22
      * http://hammerjs.github.io/
      *
      * Copyright (c) 2016 Jorik Tangelder;
      * Licensed under the MIT license */


      (function (window, document, exportName, undefined) {
        'use strict';

        var VENDOR_PREFIXES = ['', 'webkit', 'Moz', 'MS', 'ms', 'o'];
        var TEST_ELEMENT = document.createElement('div');
        var TYPE_FUNCTION = 'function';
        var round = Math.round;
        var abs = Math.abs;
        var now = Date.now;
        /**
         * set a timeout with a given scope
         * @param {Function} fn
         * @param {Number} timeout
         * @param {Object} context
         * @returns {number}
         */

        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn(fn, context), timeout);
        }
        /**
         * if the argument is an array, we want to execute the fn on each entry
         * if it aint an array we don't want to do a thing.
         * this is used by all the methods that accept a single and array argument.
         * @param {*|Array} arg
         * @param {String} fn
         * @param {Object} [context]
         * @returns {Boolean}
         */


        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }

          return false;
        }
        /**
         * walk objects and arrays
         * @param {Object} obj
         * @param {Function} iterator
         * @param {Object} context
         */


        function each(obj, iterator, context) {
          var i;

          if (!obj) {
            return;
          }

          if (obj.forEach) {
            obj.forEach(iterator, context);
          } else if (obj.length !== undefined) {
            i = 0;

            while (i < obj.length) {
              iterator.call(context, obj[i], i, obj);
              i++;
            }
          } else {
            for (i in obj) {
              obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj);
            }
          }
        }
        /**
         * wrap a method with a deprecation warning and stack trace
         * @param {Function} method
         * @param {String} name
         * @param {String} message
         * @returns {Function} A new function wrapping the supplied method.
         */


        function deprecate(method, name, message) {
          var deprecationMessage = 'DEPRECATED METHOD: ' + name + '\n' + message + ' AT \n';
          return function () {
            var e = new Error('get-stack-trace');
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, '').replace(/^\s+at\s+/gm, '').replace(/^Object.<anonymous>\s*\(/gm, '{anonymous}()@') : 'Unknown Stack Trace';
            var log = window.console && (window.console.warn || window.console.log);

            if (log) {
              log.call(window.console, deprecationMessage, stack);
            }

            return method.apply(this, arguments);
          };
        }
        /**
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} target
         * @param {...Object} objects_to_assign
         * @returns {Object} target
         */


        var assign;

        if (typeof Object.assign !== 'function') {
          assign = function assign(target) {
            if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
            }

            var output = Object(target);

            for (var index = 1; index < arguments.length; index++) {
              var source = arguments[index];

              if (source !== undefined && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }

            return output;
          };
        } else {
          assign = Object.assign;
        }
        /**
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge=false]
         * @returns {Object} dest
         */


        var extend = deprecate(function extend(dest, src, merge) {
          var keys = Object.keys(src);
          var i = 0;

          while (i < keys.length) {
            if (!merge || merge && dest[keys[i]] === undefined) {
              dest[keys[i]] = src[keys[i]];
            }

            i++;
          }

          return dest;
        }, 'extend', 'Use `assign`.');
        /**
         * merge the values from src in the dest.
         * means that properties that exist in dest will not be overwritten by src
         * @param {Object} dest
         * @param {Object} src
         * @returns {Object} dest
         */

        var merge = deprecate(function merge(dest, src) {
          return extend(dest, src, true);
        }, 'merge', 'Use `assign`.');
        /**
         * simple class inheritance
         * @param {Function} child
         * @param {Function} base
         * @param {Object} [properties]
         */

        function inherit(child, base, properties) {
          var baseP = base.prototype,
              childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;

          if (properties) {
            assign(childP, properties);
          }
        }
        /**
         * simple function bind
         * @param {Function} fn
         * @param {Object} context
         * @returns {Function}
         */


        function bindFn(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        /**
         * let a boolean value also be a function that must return a boolean
         * this first item in args will be used as the context
         * @param {Boolean|Function} val
         * @param {Array} [args]
         * @returns {Boolean}
         */


        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined : undefined, args);
          }

          return val;
        }
        /**
         * use the val2 when val1 is undefined
         * @param {*} val1
         * @param {*} val2
         * @returns {*}
         */


        function ifUndefined(val1, val2) {
          return val1 === undefined ? val2 : val1;
        }
        /**
         * addEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */


        function addEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
            target.addEventListener(type, handler, false);
          });
        }
        /**
         * removeEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */


        function removeEventListeners(target, types, handler) {
          each(splitStr(types), function (type) {
            target.removeEventListener(type, handler, false);
          });
        }
        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */


        function hasParent(node, parent) {
          while (node) {
            if (node == parent) {
              return true;
            }

            node = node.parentNode;
          }

          return false;
        }
        /**
         * small indexOf wrapper
         * @param {String} str
         * @param {String} find
         * @returns {Boolean} found
         */


        function inStr(str, find) {
          return str.indexOf(find) > -1;
        }
        /**
         * split string on whitespace
         * @param {String} str
         * @returns {Array} words
         */


        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        /**
         * find if a array contains the object using indexOf or a simple polyFill
         * @param {Array} src
         * @param {String} find
         * @param {String} [findByKey]
         * @return {Boolean|Number} false when not found, or the index
         */


        function inArray(src, find, findByKey) {
          if (src.indexOf && !findByKey) {
            return src.indexOf(find);
          } else {
            var i = 0;

            while (i < src.length) {
              if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) {
                return i;
              }

              i++;
            }

            return -1;
          }
        }
        /**
         * convert array-like objects to real arrays
         * @param {Object} obj
         * @returns {Array}
         */


        function toArray(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        /**
         * unique array with objects based on a key (like 'id') or just by the array's value
         * @param {Array} src [{id:1},{id:2},{id:1}]
         * @param {String} [key]
         * @param {Boolean} [sort=False]
         * @returns {Array} [{id:1},{id:2}]
         */


        function uniqueArray(src, key, sort) {
          var results = [];
          var values = [];
          var i = 0;

          while (i < src.length) {
            var val = key ? src[i][key] : src[i];

            if (inArray(values, val) < 0) {
              results.push(src[i]);
            }

            values[i] = val;
            i++;
          }

          if (sort) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
              });
            }
          }

          return results;
        }
        /**
         * get the prefixed property
         * @param {Object} obj
         * @param {String} property
         * @returns {String|Undefined} prefixed
         */


        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i = 0;

          while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;

            if (prop in obj) {
              return prop;
            }

            i++;
          }

          return undefined;
        }
        /**
         * get a unique id
         * @returns {number} uniqueId
         */


        var _uniqueId = 1;

        function uniqueId() {
          return _uniqueId++;
        }
        /**
         * get the window object of an element
         * @param {HTMLElement} element
         * @returns {DocumentView|Window}
         */


        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window;
        }

        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = ('ontouchstart' in window);
        var SUPPORT_POINTER_EVENTS = prefixed(window, 'PointerEvent') !== undefined;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = 'touch';
        var INPUT_TYPE_PEN = 'pen';
        var INPUT_TYPE_MOUSE = 'mouse';
        var INPUT_TYPE_KINECT = 'kinect';
        var COMPUTE_INTERVAL = 25;
        var INPUT_START = 1;
        var INPUT_MOVE = 2;
        var INPUT_END = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ['x', 'y'];
        var PROPS_CLIENT_XY = ['clientX', 'clientY'];
        /**
         * create new input type manager
         * @param {Manager} manager
         * @param {Function} callback
         * @returns {Input}
         * @constructor
         */

        function Input(manager, callback) {
          var self = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget; // smaller wrapper around the handler, for the scope and the enabled state of the manager,
          // so when disabled the input events are completely bypassed.

          this.domHandler = function (ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self.handler(ev);
            }
          };

          this.init();
        }

        Input.prototype = {
          /**
           * should handle the inputEvent data and trigger the callback
           * @virtual
           */
          handler: function handler() {},

          /**
           * bind the events
           */
          init: function init() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },

          /**
           * unbind the events
           */
          destroy: function destroy() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        /**
         * create new input type manager
         * called by the Manager constructor
         * @param {Hammer} manager
         * @returns {Input}
         */

        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;

          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput;
          } else {
            Type = TouchMouseInput;
          }

          return new Type(manager, inputHandler);
        }
        /**
         * handle input events
         * @param {Manager} manager
         * @param {String} eventType
         * @param {Object} input
         */


        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;

          if (isFirst) {
            manager.session = {};
          } // source event is the normalized value of the domEvents
          // like 'touchstart, mouseup, pointerdown'


          input.eventType = eventType; // compute scale, rotation etc

          computeInputData(manager, input); // emit secret event

          manager.emit('hammer.input', input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        /**
         * extend the data with some usable properties like scale, rotate, velocity etc
         * @param {Object} manager
         * @param {Object} input
         */


        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length; // store the first input to calculate the distance and direction

          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          } // to compute scale and rotation we need to store the multiple touches


          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }

          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input); // find the correct target

          var target = manager.element;

          if (hasParent(input.srcEvent.target, target)) {
            target = input.srcEvent.target;
          }

          input.target = target;
        }

        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};

          if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }

          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        /**
         * velocity is calculated every x ms
         * @param {Object} session
         * @param {Object} input
         */


        function computeIntervalInputData(session, input) {
          var last = session.lastInterval || input,
              deltaTime = input.timeStamp - last.timeStamp,
              velocity,
              velocityX,
              velocityY,
              direction;

          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
            var deltaX = input.deltaX - last.deltaX;
            var deltaY = input.deltaY - last.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            // use latest velocity info if it doesn't overtake a minimum period
            velocity = last.velocity;
            velocityX = last.velocityX;
            velocityY = last.velocityY;
            direction = last.direction;
          }

          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        /**
         * create a simple clone from the input used for storage of firstInput and firstMultiple
         * @param {Object} input
         * @returns {Object} clonedInputData
         */


        function simpleCloneInputData(input) {
          // make a simple copy of the pointers because we will get a reference if we don't
          // we only need clientXY for the calculations
          var pointers = [];
          var i = 0;

          while (i < input.pointers.length) {
            pointers[i] = {
              clientX: round(input.pointers[i].clientX),
              clientY: round(input.pointers[i].clientY)
            };
            i++;
          }

          return {
            timeStamp: now(),
            pointers: pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        /**
         * get the center of all the pointers
         * @param {Array} pointers
         * @return {Object} center contains `x` and `y` properties
         */


        function getCenter(pointers) {
          var pointersLength = pointers.length; // no need to loop when only one touch

          if (pointersLength === 1) {
            return {
              x: round(pointers[0].clientX),
              y: round(pointers[0].clientY)
            };
          }

          var x = 0,
              y = 0,
              i = 0;

          while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
          }

          return {
            x: round(x / pointersLength),
            y: round(y / pointersLength)
          };
        }
        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @param {Number} deltaTime
         * @param {Number} x
         * @param {Number} y
         * @return {Object} velocity `x` and `y`
         */


        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }
        /**
         * get the direction between two points
         * @param {Number} x
         * @param {Number} y
         * @return {Number} direction
         */


        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }

          if (abs(x) >= abs(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }

          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        /**
         * calculate the absolute distance between two points
         * @param {Object} p1 {x, y}
         * @param {Object} p2 {x, y}
         * @param {Array} [props] containing x and y keys
         * @return {Number} distance
         */


        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }

          var x = p2[props[0]] - p1[props[0]],
              y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }
        /**
         * calculate the angle between two coordinates
         * @param {Object} p1
         * @param {Object} p2
         * @param {Array} [props] containing x and y keys
         * @return {Number} angle
         */


        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }

          var x = p2[props[0]] - p1[props[0]],
              y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }
        /**
         * calculate the rotation degrees between two pointersets
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} rotation
         */


        function getRotation(start, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
        }
        /**
         * calculate the scale factor between two pointersets
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} scale
         */


        function getScale(start, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
        }

        var MOUSE_INPUT_MAP = {
          mousedown: INPUT_START,
          mousemove: INPUT_MOVE,
          mouseup: INPUT_END
        };
        var MOUSE_ELEMENT_EVENTS = 'mousedown';
        var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
        /**
         * Mouse events input
         * @constructor
         * @extends Input
         */

        function MouseInput() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false; // mousedown state

          Input.apply(this, arguments);
        }

        inherit(MouseInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP[ev.type]; // on start we want to have the left mouse button down

            if (eventType & INPUT_START && ev.button === 0) {
              this.pressed = true;
            }

            if (eventType & INPUT_MOVE && ev.which !== 1) {
              eventType = INPUT_END;
            } // mouse must be down


            if (!this.pressed) {
              return;
            }

            if (eventType & INPUT_END) {
              this.pressed = false;
            }

            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START,
          pointermove: INPUT_MOVE,
          pointerup: INPUT_END,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        }; // in IE10 the pointer types is defined as an enum

        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816

        };
        var POINTER_ELEMENT_EVENTS = 'pointerdown';
        var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel'; // IE10 has prefixed support, and case-sensitive

        if (window.MSPointerEvent && !window.PointerEvent) {
          POINTER_ELEMENT_EVENTS = 'MSPointerDown';
          POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
        }
        /**
         * Pointer events input
         * @constructor
         * @extends Input
         */


        function PointerEventInput() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }

        inherit(PointerEventInput, Input, {
          /**
           * handle mouse events
           * @param {Object} ev
           */
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace('ms', '');
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH; // get index of the event in the store

            var storeIndex = inArray(store, ev.pointerId, 'pointerId'); // start and mouse must be down

            if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
              removePointer = true;
            } // it not found, so the pointer hasn't been down (so it's probably a hover)


            if (storeIndex < 0) {
              return;
            } // update the event in the store


            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType: pointerType,
              srcEvent: ev
            });

            if (removePointer) {
              // remove from the store
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
        var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
         * Touch events input
         * @constructor
         * @extends Input
         */

        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input.apply(this, arguments);
        }

        inherit(SingleTouchInput, Input, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type]; // should we handle the touch events?

            if (type === INPUT_START) {
              this.started = true;
            }

            if (!this.started) {
              return;
            }

            var touches = normalizeSingleTouches.call(this, ev, type); // when done, reset the started state

            if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }

            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        /**
         * @this {TouchInput}
         * @param {Object} ev
         * @param {Number} type flag
         * @returns {undefined|Array} [all, changed]
         */

        function normalizeSingleTouches(ev, type) {
          var all = toArray(ev.touches);
          var changed = toArray(ev.changedTouches);

          if (type & (INPUT_END | INPUT_CANCEL)) {
            all = uniqueArray(all.concat(changed), 'identifier', true);
          }

          return [all, changed];
        }

        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START,
          touchmove: INPUT_MOVE,
          touchend: INPUT_END,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
        /**
         * Multi-user touch events input
         * @constructor
         * @extends Input
         */

        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input.apply(this, arguments);
        }

        inherit(TouchInput, Input, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);

            if (!touches) {
              return;
            }

            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        /**
         * @this {TouchInput}
         * @param {Object} ev
         * @param {Number} type flag
         * @returns {undefined|Array} [all, changed]
         */

        function getTouches(ev, type) {
          var allTouches = toArray(ev.touches);
          var targetIds = this.targetIds; // when there is only one touch, the process can be simplified

          if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }

          var i,
              targetTouches,
              changedTouches = toArray(ev.changedTouches),
              changedTargetTouches = [],
              target = this.target; // get target touches from touches

          targetTouches = allTouches.filter(function (touch) {
            return hasParent(touch.target, target);
          }); // collect touches

          if (type === INPUT_START) {
            i = 0;

            while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
            }
          } // filter changed touches to only contain touches that exist in the collected target ids


          i = 0;

          while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
            } // cleanup removed touches


            if (type & (INPUT_END | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
            }

            i++;
          }

          if (!changedTargetTouches.length) {
            return;
          }

          return [// merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          uniqueArray(targetTouches.concat(changedTargetTouches), 'identifier', true), changedTargetTouches];
        }
        /**
         * Combined touch and mouse input
         *
         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
         * This because touch devices also emit mouse events while doing a touch.
         *
         * @constructor
         * @extends Input
         */


        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;

        function TouchMouseInput() {
          Input.apply(this, arguments);
          var handler = bindFn(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }

        inherit(TouchMouseInput, Input, {
          /**
           * handle mouse and touch events
           * @param {Hammer} manager
           * @param {String} inputEvent
           * @param {Object} inputData
           */
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;

            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            } // when we're in a touch event, record touches to  de-dupe synthetic mouse event


            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }

            this.callback(manager, inputEvent, inputData);
          },

          /**
           * remove the event listeners
           */
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });

        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }

        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];

          if (touch.identifier === this.primaryTouch) {
            var lastTouch = {
              x: touch.clientX,
              y: touch.clientY
            };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;

            var removeLastTouch = function removeLastTouch() {
              var i = lts.indexOf(lastTouch);

              if (i > -1) {
                lts.splice(i, 1);
              }
            };

            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }

        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX,
              y = eventData.srcEvent.clientY;

          for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x),
                dy = Math.abs(y - t.y);

            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }

          return false;
        }

        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, 'touchAction');
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined; // magical touchAction value

        var TOUCH_ACTION_COMPUTE = 'compute';
        var TOUCH_ACTION_AUTO = 'auto';
        var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented

        var TOUCH_ACTION_NONE = 'none';
        var TOUCH_ACTION_PAN_X = 'pan-x';
        var TOUCH_ACTION_PAN_Y = 'pan-y';
        var TOUCH_ACTION_MAP = getTouchActionProps();
        /**
         * Touch Action
         * sets the touchAction property or uses the js alternative
         * @param {Manager} manager
         * @param {String} value
         * @constructor
         */

        function TouchAction(manager, value) {
          this.manager = manager;
          this.set(value);
        }

        TouchAction.prototype = {
          /**
           * set the touchAction value on the element or enable the polyfill
           * @param {String} value
           */
          set: function set(value) {
            // find out the touch-action by the event handlers
            if (value == TOUCH_ACTION_COMPUTE) {
              value = this.compute();
            }

            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
            }

            this.actions = value.toLowerCase().trim();
          },

          /**
           * just re-set the touchAction value
           */
          update: function update() {
            this.set(this.manager.options.touchAction);
          },

          /**
           * compute the value for the touchAction property based on the recognizer's settings
           * @returns {String} value
           */
          compute: function compute() {
            var actions = [];
            each(this.manager.recognizers, function (recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(' '));
          },

          /**
           * this method is called on each input cycle and provides the preventing of the browser behavior
           * @param {Object} input
           */
          preventDefaults: function preventDefaults(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection; // if the touch action did prevented once this session

            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }

            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];

            if (hasNone) {
              //do not prevent defaults if this is a tap gesture
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;

              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }

            if (hasPanX && hasPanY) {
              // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
              return;
            }

            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },

          /**
           * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
           * @param {Object} srcEvent
           */
          preventSrc: function preventSrc(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        /**
         * when the touchActions are collected they are not a valid value, so we need to clean things up. *
         * @param {String} actions
         * @returns {*}
         */

        function cleanTouchActions(actions) {
          // none
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }

          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y); // if both pan-x and pan-y are set (different recognizers
          // for different directions, e.g. horizontal pan but vertical swipe?)
          // we need none (as otherwise with pan-x pan-y combined none of these
          // recognizers will work, since the browser would handle all panning

          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          } // pan-x OR pan-y


          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          } // manipulation


          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }

          return TOUCH_ACTION_AUTO;
        }

        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }

          var touchMap = {};
          var cssSupports = window.CSS && window.CSS.supports;
          ['auto', 'manipulation', 'pan-y', 'pan-x', 'pan-x pan-y', 'none'].forEach(function (val) {
            // If css.supports is not supported but there is native touch-action assume it supports
            // all values. This is the case for IE 10 and 11.
            touchMap[val] = cssSupports ? window.CSS.supports('touch-action', val) : true;
          });
          return touchMap;
        }
        /**
         * Recognizer flow explained; *
         * All recognizers have the initial state of POSSIBLE when a input session starts.
         * The definition of a input session is from the first input until the last input, with all it's movement in it. *
         * Example session for mouse-input: mousedown -> mousemove -> mouseup
         *
         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
         * which determines with state it should be.
         *
         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
         * POSSIBLE to give it another change on the next cycle.
         *
         *               Possible
         *                  |
         *            +-----+---------------+
         *            |                     |
         *      +-----+-----+               |
         *      |           |               |
         *   Failed      Cancelled          |
         *                          +-------+------+
         *                          |              |
         *                      Recognized       Began
         *                                         |
         *                                      Changed
         *                                         |
         *                                  Ended/Recognized
         */


        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        /**
         * Recognizer
         * Every recognizer needs to extend from this class.
         * @constructor
         * @param {Object} options
         */

        function Recognizer(options) {
          this.options = assign({}, this.defaults, options || {});
          this.id = uniqueId();
          this.manager = null; // default is enable true

          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }

        Recognizer.prototype = {
          /**
           * @virtual
           * @type {Object}
           */
          defaults: {},

          /**
           * set options
           * @param {Object} options
           * @return {Recognizer}
           */
          set: function set(options) {
            assign(this.options, options); // also update the touchAction, in case something changed about the directions/enabled state

            this.manager && this.manager.touchAction.update();
            return this;
          },

          /**
           * recognize simultaneous with an other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          recognizeWith: function recognizeWith(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'recognizeWith', this)) {
              return this;
            }

            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }

            return this;
          },

          /**
           * drop the simultaneous link. it doesnt remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRecognizeWith: function dropRecognizeWith(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRecognizeWith', this)) {
              return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },

          /**
           * recognizer can only run when an other is failing
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          requireFailure: function requireFailure(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'requireFailure', this)) {
              return this;
            }

            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);

            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }

            return this;
          },

          /**
           * drop the requireFailure link. it does not remove the link on the other recognizer.
           * @param {Recognizer} otherRecognizer
           * @returns {Recognizer} this
           */
          dropRequireFailure: function dropRequireFailure(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, 'dropRequireFailure', this)) {
              return this;
            }

            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index = inArray(this.requireFail, otherRecognizer);

            if (index > -1) {
              this.requireFail.splice(index, 1);
            }

            return this;
          },

          /**
           * has require failures boolean
           * @returns {boolean}
           */
          hasRequireFailures: function hasRequireFailures() {
            return this.requireFail.length > 0;
          },

          /**
           * if the recognizer can recognize simultaneous with an other recognizer
           * @param {Recognizer} otherRecognizer
           * @returns {Boolean}
           */
          canRecognizeWith: function canRecognizeWith(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },

          /**
           * You should use `tryEmit` instead of `emit` directly to check
           * that all the needed recognizers has failed before emitting.
           * @param {Object} input
           */
          emit: function emit(input) {
            var self = this;
            var state = this.state;

            function emit(event) {
              self.manager.emit(event, input);
            } // 'panstart' and 'panmove'


            if (state < STATE_ENDED) {
              emit(self.options.event + stateStr(state));
            }

            emit(self.options.event); // simple 'eventName' events

            if (input.additionalEvent) {
              // additional event(panleft, panright, pinchin, pinchout...)
              emit(input.additionalEvent);
            } // panend and pancancel


            if (state >= STATE_ENDED) {
              emit(self.options.event + stateStr(state));
            }
          },

          /**
           * Check that all the require failure recognizers has failed,
           * if true, it emits a gesture event,
           * otherwise, setup the state to FAILED.
           * @param {Object} input
           */
          tryEmit: function tryEmit(input) {
            if (this.canEmit()) {
              return this.emit(input);
            } // it's failing anyway


            this.state = STATE_FAILED;
          },

          /**
           * can we emit?
           * @returns {boolean}
           */
          canEmit: function canEmit() {
            var i = 0;

            while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }

              i++;
            }

            return true;
          },

          /**
           * update the recognizer
           * @param {Object} inputData
           */
          recognize: function recognize(inputData) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = assign({}, inputData); // is is enabled and allow recognizing?

            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            } // reset when we've reached the end


            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }

            this.state = this.process(inputDataClone); // the recognizer has recognized a gesture
            // so trigger an event

            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },

          /**
           * return the state of the recognizer
           * the actual recognizing happens in this method
           * @virtual
           * @param {Object} inputData
           * @returns {Const} STATE
           */
          process: function process(inputData) {},
          // jshint ignore:line

          /**
           * return the preferred touch-action
           * @virtual
           * @returns {Array}
           */
          getTouchAction: function getTouchAction() {},

          /**
           * called when the gesture isn't allowed to recognize
           * like when another is being recognized or it is disabled
           * @virtual
           */
          reset: function reset() {}
        };
        /**
         * get a usable string, used as event postfix
         * @param {Const} state
         * @returns {String} state
         */

        function stateStr(state) {
          if (state & STATE_CANCELLED) {
            return 'cancel';
          } else if (state & STATE_ENDED) {
            return 'end';
          } else if (state & STATE_CHANGED) {
            return 'move';
          } else if (state & STATE_BEGAN) {
            return 'start';
          }

          return '';
        }
        /**
         * direction cons to string
         * @param {Const} direction
         * @returns {String}
         */


        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return 'down';
          } else if (direction == DIRECTION_UP) {
            return 'up';
          } else if (direction == DIRECTION_LEFT) {
            return 'left';
          } else if (direction == DIRECTION_RIGHT) {
            return 'right';
          }

          return '';
        }
        /**
         * get a recognizer by name if it is bound to a manager
         * @param {Recognizer|String} otherRecognizer
         * @param {Recognizer} recognizer
         * @returns {Recognizer}
         */


        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;

          if (manager) {
            return manager.get(otherRecognizer);
          }

          return otherRecognizer;
        }
        /**
         * This recognizer is just used as a base for the simple attribute recognizers.
         * @constructor
         * @extends Recognizer
         */


        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }

        inherit(AttrRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof AttrRecognizer
           */
          defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
          },

          /**
           * Used to check if it the recognizer receives valid input, like input.distance > 10.
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {Boolean} recognized
           */
          attrTest: function attrTest(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },

          /**
           * Process the input and return the state for the recognizer
           * @memberof AttrRecognizer
           * @param {Object} input
           * @returns {*} State
           */
          process: function process(input) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
            var isValid = this.attrTest(input); // on cancel input and we've recognized before, return STATE_CANCELLED

            if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
              return state | STATE_CANCELLED;
            } else if (isRecognized || isValid) {
              if (eventType & INPUT_END) {
                return state | STATE_ENDED;
              } else if (!(state & STATE_BEGAN)) {
                return STATE_BEGAN;
              }

              return state | STATE_CHANGED;
            }

            return STATE_FAILED;
          }
        });
        /**
         * Pan
         * Recognized when the pointer is down and moved in the allowed direction.
         * @constructor
         * @extends AttrRecognizer
         */

        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }

        inherit(PanRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PanRecognizer
           */
          defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function getTouchAction() {
            var direction = this.options.direction;
            var actions = [];

            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }

            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }

            return actions;
          },
          directionTest: function directionTest(input) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY; // lock to axis?

            if (!(direction & options.direction)) {
              if (options.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance = Math.abs(input.deltaY);
              }
            }

            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
          },
          attrTest: function attrTest(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function emit(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);

            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }

            this._super.emit.call(this, input);
          }
        });
        /**
         * Pinch
         * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
         * @constructor
         * @extends AttrRecognizer
         */

        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }

        inherit(PinchRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function getTouchAction() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function attrTest(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function emit(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? 'in' : 'out';
              input.additionalEvent = this.options.event + inOut;
            }

            this._super.emit.call(this, input);
          }
        });
        /**
         * Press
         * Recognized when the pointer is down for x ms without any movement.
         * @constructor
         * @extends Recognizer
         */

        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }

        inherit(PressRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PressRecognizer
           */
          defaults: {
            event: 'press',
            pointers: 1,
            time: 251,
            // minimal time of the pointer to be pressed
            threshold: 9 // a minimal movement is ok, but keep it low

          },
          getTouchAction: function getTouchAction() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function process(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input; // we only allow little movement
            // and we've reached an end event, so a tap is possible

            if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START) {
              this.reset();
              this._timer = setTimeoutContext(function () {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options.time, this);
            } else if (input.eventType & INPUT_END) {
              return STATE_RECOGNIZED;
            }

            return STATE_FAILED;
          },
          reset: function reset() {
            clearTimeout(this._timer);
          },
          emit: function emit(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }

            if (input && input.eventType & INPUT_END) {
              this.manager.emit(this.options.event + 'up', input);
            } else {
              this._input.timeStamp = now();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        /**
         * Rotate
         * Recognized when two or more pointer are moving in a circular motion.
         * @constructor
         * @extends AttrRecognizer
         */

        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }

        inherit(RotateRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof RotateRecognizer
           */
          defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function getTouchAction() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function attrTest(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        /**
         * Swipe
         * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
         * @constructor
         * @extends AttrRecognizer
         */

        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }

        inherit(SwipeRecognizer, AttrRecognizer, {
          /**
           * @namespace
           * @memberof SwipeRecognizer
           */
          defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function getTouchAction() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function attrTest(input) {
            var direction = this.options.direction;
            var velocity;

            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }

            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
          },
          emit: function emit(input) {
            var direction = directionStr(input.offsetDirection);

            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }

            this.manager.emit(this.options.event, input);
          }
        });
        /**
         * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
         * between the given interval and position. The delay option can be used to recognize multi-taps without firing
         * a single tap.
         *
         * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
         * multi-taps being recognized.
         * @constructor
         * @extends Recognizer
         */

        function TapRecognizer() {
          Recognizer.apply(this, arguments); // previous time and center,
          // used for tap counting

          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }

        inherit(TapRecognizer, Recognizer, {
          /**
           * @namespace
           * @memberof PinchRecognizer
           */
          defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300,
            // max time between the multi-tap taps
            time: 250,
            // max time of the pointer to be down (like finger on the screen)
            threshold: 9,
            // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position

          },
          getTouchAction: function getTouchAction() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function process(input) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();

            if (input.eventType & INPUT_START && this.count === 0) {
              return this.failTimeout();
            } // we only allow little movement
            // and we've reached an end event, so a tap is possible


            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END) {
                return this.failTimeout();
              }

              var validInterval = this.pTime ? input.timeStamp - this.pTime < options.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;

              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }

              this._input = input; // if tap count matches we have recognized it,
              // else it has began recognizing...

              var tapCount = this.count % options.taps;

              if (tapCount === 0) {
                // no failing requirements, immediately trigger the tap event
                // or wait as long as the multitap interval to trigger
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function () {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options.interval, this);
                  return STATE_BEGAN;
                }
              }
            }

            return STATE_FAILED;
          },
          failTimeout: function failTimeout() {
            this._timer = setTimeoutContext(function () {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function reset() {
            clearTimeout(this._timer);
          },
          emit: function emit() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        /**
         * Simple way to create a manager with a default set of recognizers.
         * @param {HTMLElement} element
         * @param {Object} [options]
         * @constructor
         */

        function Hammer(element, options) {
          options = options || {};
          options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset);
          return new Manager(element, options);
        }
        /**
         * @const {string}
         */


        Hammer.VERSION = '2.0.7';
        /**
         * default settings
         * @namespace
         */

        Hammer.defaults = {
          /**
           * set if DOM events are being triggered.
           * But this is slower and unused by simple implementations, so disabled by default.
           * @type {Boolean}
           * @default false
           */
          domEvents: false,

          /**
           * The value for the touchAction property/fallback.
           * When set to `compute` it will magically set the correct value based on the added recognizers.
           * @type {String}
           * @default compute
           */
          touchAction: TOUCH_ACTION_COMPUTE,

          /**
           * @type {Boolean}
           * @default true
           */
          enable: true,

          /**
           * EXPERIMENTAL FEATURE -- can be removed/changed
           * Change the parent input target element.
           * If Null, then it is being set the to main element.
           * @type {Null|EventTarget}
           * @default null
           */
          inputTarget: null,

          /**
           * force an input class
           * @type {Null|Function}
           * @default null
           */
          inputClass: null,

          /**
           * Default recognizer setup when calling `Hammer()`
           * When creating a new Manager these will be skipped.
           * @type {Array}
           */
          preset: [// RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
          [RotateRecognizer, {
            enable: false
          }], [PinchRecognizer, {
            enable: false
          }, ['rotate']], [SwipeRecognizer, {
            direction: DIRECTION_HORIZONTAL
          }], [PanRecognizer, {
            direction: DIRECTION_HORIZONTAL
          }, ['swipe']], [TapRecognizer], [TapRecognizer, {
            event: 'doubletap',
            taps: 2
          }, ['tap']], [PressRecognizer]],

          /**
           * Some CSS properties can be used to improve the working of Hammer.
           * Add them to this method and they will be set when creating a new Manager.
           * @namespace
           */
          cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',

            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',

            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',

            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',

            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',

            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        /**
         * Manager
         * @param {HTMLElement} element
         * @param {Object} [options]
         * @constructor
         */

        function Manager(element, options) {
          this.options = assign({}, Hammer.defaults, options || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function (item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }

        Manager.prototype = {
          /**
           * set options
           * @param {Object} options
           * @returns {Manager}
           */
          set: function set(options) {
            assign(this.options, options); // Options that need a little more setup

            if (options.touchAction) {
              this.touchAction.update();
            }

            if (options.inputTarget) {
              // Clean up existing event listeners and reinitialize
              this.input.destroy();
              this.input.target = options.inputTarget;
              this.input.init();
            }

            return this;
          },

          /**
           * stop recognizing for this session.
           * This session will be discarded, when a new [input]start event is fired.
           * When forced, the recognizer cycle is stopped immediately.
           * @param {Boolean} [force]
           */
          stop: function stop(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },

          /**
           * run the recognizers!
           * called by the inputHandler function on every movement of the pointers (touches)
           * it walks through all the recognizers and tries to detect the gesture that is being made
           * @param {Object} inputData
           */
          recognize: function recognize(inputData) {
            var session = this.session;

            if (session.stopped) {
              return;
            } // run the touch-action polyfill


            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers; // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`

            var curRecognizer = session.curRecognizer; // reset when the last recognizer is recognized
            // or when we're in a new session

            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }

            var i = 0;

            while (i < recognizers.length) {
              recognizer = recognizers[i]; // find out if we are allowed try to recognize the input for this one.
              // 1.   allow if the session is NOT forced stopped (see the .stop() method)
              // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
              //      that is being recognized.
              // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
              //      this can be setup with the `recognizeWith()` method on the recognizer.

              if (session.stopped !== FORCED_STOP && ( // 1
              !curRecognizer || recognizer == curRecognizer || // 2
              recognizer.canRecognizeWith(curRecognizer))) {
                // 3
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              } // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
              // current active recognizer. but only if we don't already have an active recognizer


              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }

              i++;
            }
          },

          /**
           * get a recognizer by its event name.
           * @param {Recognizer|String} recognizer
           * @returns {Recognizer|Null}
           */
          get: function get(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }

            var recognizers = this.recognizers;

            for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
              }
            }

            return null;
          },

          /**
           * add a recognizer to the manager
           * existing recognizers with the same event name will be removed
           * @param {Recognizer} recognizer
           * @returns {Recognizer|Manager}
           */
          add: function add(recognizer) {
            if (invokeArrayArg(recognizer, 'add', this)) {
              return this;
            } // remove existing


            var existing = this.get(recognizer.options.event);

            if (existing) {
              this.remove(existing);
            }

            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },

          /**
           * remove a recognizer by name or instance
           * @param {Recognizer|String} recognizer
           * @returns {Manager}
           */
          remove: function remove(recognizer) {
            if (invokeArrayArg(recognizer, 'remove', this)) {
              return this;
            }

            recognizer = this.get(recognizer); // let's make sure this recognizer exists

            if (recognizer) {
              var recognizers = this.recognizers;
              var index = inArray(recognizers, recognizer);

              if (index !== -1) {
                recognizers.splice(index, 1);
                this.touchAction.update();
              }
            }

            return this;
          },

          /**
           * bind event
           * @param {String} events
           * @param {Function} handler
           * @returns {EventEmitter} this
           */
          on: function on(events, handler) {
            if (events === undefined) {
              return;
            }

            if (handler === undefined) {
              return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function (event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },

          /**
           * unbind event, leave emit blank to remove all handlers
           * @param {String} events
           * @param {Function} [handler]
           * @returns {EventEmitter} this
           */
          off: function off(events, handler) {
            if (events === undefined) {
              return;
            }

            var handlers = this.handlers;
            each(splitStr(events), function (event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },

          /**
           * emit event to the listeners
           * @param {String} event
           * @param {Object} data
           */
          emit: function emit(event, data) {
            // we also want to trigger dom events
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            } // no handlers, so skip it all


            var handlers = this.handlers[event] && this.handlers[event].slice();

            if (!handlers || !handlers.length) {
              return;
            }

            data.type = event;

            data.preventDefault = function () {
              data.srcEvent.preventDefault();
            };

            var i = 0;

            while (i < handlers.length) {
              handlers[i](data);
              i++;
            }
          },

          /**
           * destroy the manager and unbinds all events
           * it doesn't unbind dom events, that is the user own responsibility
           */
          destroy: function destroy() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        /**
         * add/remove the css properties as defined in manager.options.cssProps
         * @param {Manager} manager
         * @param {Boolean} add
         */

        function toggleCssProps(manager, add) {
          var element = manager.element;

          if (!element.style) {
            return;
          }

          var prop;
          each(manager.options.cssProps, function (value, name) {
            prop = prefixed(element.style, name);

            if (add) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || '';
            }
          });

          if (!add) {
            manager.oldCssProps = {};
          }
        }
        /**
         * trigger dom event
         * @param {String} event
         * @param {Object} data
         */


        function triggerDomEvent(event, data) {
          var gestureEvent = document.createEvent('Event');
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }

        assign(Hammer, {
          INPUT_START: INPUT_START,
          INPUT_MOVE: INPUT_MOVE,
          INPUT_END: INPUT_END,
          INPUT_CANCEL: INPUT_CANCEL,
          STATE_POSSIBLE: STATE_POSSIBLE,
          STATE_BEGAN: STATE_BEGAN,
          STATE_CHANGED: STATE_CHANGED,
          STATE_ENDED: STATE_ENDED,
          STATE_RECOGNIZED: STATE_RECOGNIZED,
          STATE_CANCELLED: STATE_CANCELLED,
          STATE_FAILED: STATE_FAILED,
          DIRECTION_NONE: DIRECTION_NONE,
          DIRECTION_LEFT: DIRECTION_LEFT,
          DIRECTION_RIGHT: DIRECTION_RIGHT,
          DIRECTION_UP: DIRECTION_UP,
          DIRECTION_DOWN: DIRECTION_DOWN,
          DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL: DIRECTION_VERTICAL,
          DIRECTION_ALL: DIRECTION_ALL,
          Manager: Manager,
          Input: Input,
          TouchAction: TouchAction,
          TouchInput: TouchInput,
          MouseInput: MouseInput,
          PointerEventInput: PointerEventInput,
          TouchMouseInput: TouchMouseInput,
          SingleTouchInput: SingleTouchInput,
          Recognizer: Recognizer,
          AttrRecognizer: AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each: each,
          merge: merge,
          extend: extend,
          assign: assign,
          inherit: inherit,
          bindFn: bindFn,
          prefixed: prefixed
        }); // this prevents errors when Hammer is loaded in the presence of an AMD
        //  style loader but by script tag, not by the loader.

        var freeGlobal = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}; // jshint ignore:line

        freeGlobal.Hammer = Hammer;

        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return Hammer;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else {}
      })(window, document, 'Hammer');
      /***/

    },

    /***/
    13544: function _(module, exports, __webpack_require__) {
      var __WEBPACK_AMD_DEFINE_RESULT__;
      /*global define:false */

      /**
       * Copyright 2012-2017 Craig Campbell
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       * http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * Mousetrap is a simple keyboard shortcut library for Javascript with
       * no external dependencies
       *
       * @version 1.6.5
       * @url craig.is/killing/mice
       */


      (function (window, document, undefined) {
        // Check if mousetrap is used inside browser, if not, return
        if (!window) {
          return;
        }
        /**
         * mapping of special keycodes to their corresponding keys
         *
         * everything in this dictionary cannot use keypress events
         * so it has to be here to map to the correct keycodes for
         * keyup/keydown events
         *
         * @type {Object}
         */


        var _MAP = {
          8: 'backspace',
          9: 'tab',
          13: 'enter',
          16: 'shift',
          17: 'ctrl',
          18: 'alt',
          20: 'capslock',
          27: 'esc',
          32: 'space',
          33: 'pageup',
          34: 'pagedown',
          35: 'end',
          36: 'home',
          37: 'left',
          38: 'up',
          39: 'right',
          40: 'down',
          45: 'ins',
          46: 'del',
          91: 'meta',
          93: 'meta',
          224: 'meta'
        };
        /**
         * mapping for special characters so they can support
         *
         * this dictionary is only used incase you want to bind a
         * keyup or keydown event to one of these keys
         *
         * @type {Object}
         */

        var _KEYCODE_MAP = {
          106: '*',
          107: '+',
          109: '-',
          110: '.',
          111: '/',
          186: ';',
          187: '=',
          188: ',',
          189: '-',
          190: '.',
          191: '/',
          192: '`',
          219: '[',
          220: '\\',
          221: ']',
          222: '\''
        };
        /**
         * this is a mapping of keys that require shift on a US keypad
         * back to the non shift equivelents
         *
         * this is so you can use keyup events with these keys
         *
         * note that this will only work reliably on US keyboards
         *
         * @type {Object}
         */

        var _SHIFT_MAP = {
          '~': '`',
          '!': '1',
          '@': '2',
          '#': '3',
          '$': '4',
          '%': '5',
          '^': '6',
          '&': '7',
          '*': '8',
          '(': '9',
          ')': '0',
          '_': '-',
          '+': '=',
          ':': ';',
          '\"': '\'',
          '<': ',',
          '>': '.',
          '?': '/',
          '|': '\\'
        };
        /**
         * this is a list of special strings you can use to map
         * to modifier keys when you specify your keyboard shortcuts
         *
         * @type {Object}
         */

        var _SPECIAL_ALIASES = {
          'option': 'alt',
          'command': 'meta',
          'return': 'enter',
          'escape': 'esc',
          'plus': '+',
          'mod': /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? 'meta' : 'ctrl'
        };
        /**
         * variable to store the flipped version of _MAP from above
         * needed to check if we should use keypress or not when no action
         * is specified
         *
         * @type {Object|undefined}
         */

        var _REVERSE_MAP;
        /**
         * loop through the f keys, f1 to f19 and add them to the map
         * programatically
         */


        for (var i = 1; i < 20; ++i) {
          _MAP[111 + i] = 'f' + i;
        }
        /**
         * loop through to map numbers on the numeric keypad
         */


        for (i = 0; i <= 9; ++i) {
          // This needs to use a string cause otherwise since 0 is falsey
          // mousetrap will never fire for numpad 0 pressed as part of a keydown
          // event.
          //
          // @see https://github.com/ccampbell/mousetrap/pull/258
          _MAP[i + 96] = i.toString();
        }
        /**
         * cross browser add event method
         *
         * @param {Element|HTMLDocument} object
         * @param {string} type
         * @param {Function} callback
         * @returns void
         */


        function _addEvent(object, type, callback) {
          if (object.addEventListener) {
            object.addEventListener(type, callback, false);
            return;
          }

          object.attachEvent('on' + type, callback);
        }
        /**
         * takes the event and returns the key character
         *
         * @param {Event} e
         * @return {string}
         */


        function _characterFromEvent(e) {
          // for keypress events we should return the character as is
          if (e.type == 'keypress') {
            var character = String.fromCharCode(e.which); // if the shift key is not pressed then it is safe to assume
            // that we want the character to be lowercase.  this means if
            // you accidentally have caps lock on then your key bindings
            // will continue to work
            //
            // the only side effect that might not be desired is if you
            // bind something like 'A' cause you want to trigger an
            // event when capital A is pressed caps lock will no longer
            // trigger the event.  shift+a will though.

            if (!e.shiftKey) {
              character = character.toLowerCase();
            }

            return character;
          } // for non keypress events the special maps are needed


          if (_MAP[e.which]) {
            return _MAP[e.which];
          }

          if (_KEYCODE_MAP[e.which]) {
            return _KEYCODE_MAP[e.which];
          } // if it is not in the special map
          // with keydown and keyup events the character seems to always
          // come in as an uppercase character whether you are pressing shift
          // or not.  we should make sure it is always lowercase for comparisons


          return String.fromCharCode(e.which).toLowerCase();
        }
        /**
         * checks if two arrays are equal
         *
         * @param {Array} modifiers1
         * @param {Array} modifiers2
         * @returns {boolean}
         */


        function _modifiersMatch(modifiers1, modifiers2) {
          return modifiers1.sort().join(',') === modifiers2.sort().join(',');
        }
        /**
         * takes a key event and figures out what the modifiers are
         *
         * @param {Event} e
         * @returns {Array}
         */


        function _eventModifiers(e) {
          var modifiers = [];

          if (e.shiftKey) {
            modifiers.push('shift');
          }

          if (e.altKey) {
            modifiers.push('alt');
          }

          if (e.ctrlKey) {
            modifiers.push('ctrl');
          }

          if (e.metaKey) {
            modifiers.push('meta');
          }

          return modifiers;
        }
        /**
         * prevents default for this event
         *
         * @param {Event} e
         * @returns void
         */


        function _preventDefault(e) {
          if (e.preventDefault) {
            e.preventDefault();
            return;
          }

          e.returnValue = false;
        }
        /**
         * stops propogation for this event
         *
         * @param {Event} e
         * @returns void
         */


        function _stopPropagation(e) {
          if (e.stopPropagation) {
            e.stopPropagation();
            return;
          }

          e.cancelBubble = true;
        }
        /**
         * determines if the keycode specified is a modifier key or not
         *
         * @param {string} key
         * @returns {boolean}
         */


        function _isModifier(key) {
          return key == 'shift' || key == 'ctrl' || key == 'alt' || key == 'meta';
        }
        /**
         * reverses the map lookup so that we can look for specific keys
         * to see what can and can't use keypress
         *
         * @return {Object}
         */


        function _getReverseMap() {
          if (!_REVERSE_MAP) {
            _REVERSE_MAP = {};

            for (var key in _MAP) {
              // pull out the numeric keypad from here cause keypress should
              // be able to detect the keys from the character
              if (key > 95 && key < 112) {
                continue;
              }

              if (_MAP.hasOwnProperty(key)) {
                _REVERSE_MAP[_MAP[key]] = key;
              }
            }
          }

          return _REVERSE_MAP;
        }
        /**
         * picks the best action based on the key combination
         *
         * @param {string} key - character for key
         * @param {Array} modifiers
         * @param {string=} action passed in
         */


        function _pickBestAction(key, modifiers, action) {
          // if no action was picked in we should try to pick the one
          // that we think would work best for this key
          if (!action) {
            action = _getReverseMap()[key] ? 'keydown' : 'keypress';
          } // modifier keys don't work as expected with keypress,
          // switch to keydown


          if (action == 'keypress' && modifiers.length) {
            action = 'keydown';
          }

          return action;
        }
        /**
         * Converts from a string key combination to an array
         *
         * @param  {string} combination like "command+shift+l"
         * @return {Array}
         */


        function _keysFromString(combination) {
          if (combination === '+') {
            return ['+'];
          }

          combination = combination.replace(/\+{2}/g, '+plus');
          return combination.split('+');
        }
        /**
         * Gets info for a specific key combination
         *
         * @param  {string} combination key combination ("command+s" or "a" or "*")
         * @param  {string=} action
         * @returns {Object}
         */


        function _getKeyInfo(combination, action) {
          var keys;
          var key;
          var i;
          var modifiers = []; // take the keys from this pattern and figure out what the actual
          // pattern is all about

          keys = _keysFromString(combination);

          for (i = 0; i < keys.length; ++i) {
            key = keys[i]; // normalize key names

            if (_SPECIAL_ALIASES[key]) {
              key = _SPECIAL_ALIASES[key];
            } // if this is not a keypress event then we should
            // be smart about using shift keys
            // this will only work for US keyboards however


            if (action && action != 'keypress' && _SHIFT_MAP[key]) {
              key = _SHIFT_MAP[key];
              modifiers.push('shift');
            } // if this key is a modifier then add it to the list of modifiers


            if (_isModifier(key)) {
              modifiers.push(key);
            }
          } // depending on what the key combination is
          // we will try to pick the best event for it


          action = _pickBestAction(key, modifiers, action);
          return {
            key: key,
            modifiers: modifiers,
            action: action
          };
        }

        function _belongsTo(element, ancestor) {
          if (element === null || element === document) {
            return false;
          }

          if (element === ancestor) {
            return true;
          }

          return _belongsTo(element.parentNode, ancestor);
        }

        function Mousetrap(targetElement) {
          var self = this;
          targetElement = targetElement || document;

          if (!(self instanceof Mousetrap)) {
            return new Mousetrap(targetElement);
          }
          /**
           * element to attach key events to
           *
           * @type {Element}
           */


          self.target = targetElement;
          /**
           * a list of all the callbacks setup via Mousetrap.bind()
           *
           * @type {Object}
           */

          self._callbacks = {};
          /**
           * direct map of string combinations to callbacks used for trigger()
           *
           * @type {Object}
           */

          self._directMap = {};
          /**
           * keeps track of what level each sequence is at since multiple
           * sequences can start out with the same sequence
           *
           * @type {Object}
           */

          var _sequenceLevels = {};
          /**
           * variable to store the setTimeout call
           *
           * @type {null|number}
           */

          var _resetTimer;
          /**
           * temporary state where we will ignore the next keyup
           *
           * @type {boolean|string}
           */


          var _ignoreNextKeyup = false;
          /**
           * temporary state where we will ignore the next keypress
           *
           * @type {boolean}
           */

          var _ignoreNextKeypress = false;
          /**
           * are we currently inside of a sequence?
           * type of action ("keyup" or "keydown" or "keypress") or false
           *
           * @type {boolean|string}
           */

          var _nextExpectedAction = false;
          /**
           * resets all sequence counters except for the ones passed in
           *
           * @param {Object} doNotReset
           * @returns void
           */

          function _resetSequences(doNotReset) {
            doNotReset = doNotReset || {};
            var activeSequences = false,
                key;

            for (key in _sequenceLevels) {
              if (doNotReset[key]) {
                activeSequences = true;
                continue;
              }

              _sequenceLevels[key] = 0;
            }

            if (!activeSequences) {
              _nextExpectedAction = false;
            }
          }
          /**
           * finds all callbacks that match based on the keycode, modifiers,
           * and action
           *
           * @param {string} character
           * @param {Array} modifiers
           * @param {Event|Object} e
           * @param {string=} sequenceName - name of the sequence we are looking for
           * @param {string=} combination
           * @param {number=} level
           * @returns {Array}
           */


          function _getMatches(character, modifiers, e, sequenceName, combination, level) {
            var i;
            var callback;
            var matches = [];
            var action = e.type; // if there are no events related to this keycode

            if (!self._callbacks[character]) {
              return [];
            } // if a modifier key is coming up on its own we should allow it


            if (action == 'keyup' && _isModifier(character)) {
              modifiers = [character];
            } // loop through all callbacks for the key that was pressed
            // and see if any of them match


            for (i = 0; i < self._callbacks[character].length; ++i) {
              callback = self._callbacks[character][i]; // if a sequence name is not specified, but this is a sequence at
              // the wrong level then move onto the next match

              if (!sequenceName && callback.seq && _sequenceLevels[callback.seq] != callback.level) {
                continue;
              } // if the action we are looking for doesn't match the action we got
              // then we should keep going


              if (action != callback.action) {
                continue;
              } // if this is a keypress event and the meta key and control key
              // are not pressed that means that we need to only look at the
              // character, otherwise check the modifiers as well
              //
              // chrome will not fire a keypress if meta or control is down
              // safari will fire a keypress if meta or meta+shift is down
              // firefox will fire a keypress if meta or control is down


              if (action == 'keypress' && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers)) {
                // when you bind a combination or sequence a second time it
                // should overwrite the first one.  if a sequenceName or
                // combination is specified in this call it does just that
                //
                // @todo make deleting its own method?
                var deleteCombo = !sequenceName && callback.combo == combination;
                var deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;

                if (deleteCombo || deleteSequence) {
                  self._callbacks[character].splice(i, 1);
                }

                matches.push(callback);
              }
            }

            return matches;
          }
          /**
           * actually calls the callback function
           *
           * if your callback function returns false this will use the jquery
           * convention - prevent default and stop propogation on the event
           *
           * @param {Function} callback
           * @param {Event} e
           * @returns void
           */


          function _fireCallback(callback, e, combo, sequence) {
            // if this event should not happen stop here
            if (self.stopCallback(e, e.target || e.srcElement, combo, sequence)) {
              return;
            }

            if (callback(e, combo) === false) {
              _preventDefault(e);

              _stopPropagation(e);
            }
          }
          /**
           * handles a character key event
           *
           * @param {string} character
           * @param {Array} modifiers
           * @param {Event} e
           * @returns void
           */


          self._handleKey = function (character, modifiers, e) {
            var callbacks = _getMatches(character, modifiers, e);

            var i;
            var doNotReset = {};
            var maxLevel = 0;
            var processedSequenceCallback = false; // Calculate the maxLevel for sequences so we can only execute the longest callback sequence

            for (i = 0; i < callbacks.length; ++i) {
              if (callbacks[i].seq) {
                maxLevel = Math.max(maxLevel, callbacks[i].level);
              }
            } // loop through matching callbacks for this key event


            for (i = 0; i < callbacks.length; ++i) {
              // fire for all sequence callbacks
              // this is because if for example you have multiple sequences
              // bound such as "g i" and "g t" they both need to fire the
              // callback for matching g cause otherwise you can only ever
              // match the first one
              if (callbacks[i].seq) {
                // only fire callbacks for the maxLevel to prevent
                // subsequences from also firing
                //
                // for example 'a option b' should not cause 'option b' to fire
                // even though 'option b' is part of the other sequence
                //
                // any sequences that do not match here will be discarded
                // below by the _resetSequences call
                if (callbacks[i].level != maxLevel) {
                  continue;
                }

                processedSequenceCallback = true; // keep a list of which sequences were matches for later

                doNotReset[callbacks[i].seq] = 1;

                _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq);

                continue;
              } // if there were no sequence matches but we are still here
              // that means this is a regular match so we should fire that


              if (!processedSequenceCallback) {
                _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
              }
            } // if the key you pressed matches the type of sequence without
            // being a modifier (ie "keyup" or "keypress") then we should
            // reset all sequences that were not matched by this event
            //
            // this is so, for example, if you have the sequence "h a t" and you
            // type "h e a r t" it does not match.  in this case the "e" will
            // cause the sequence to reset
            //
            // modifier keys are ignored because you can have a sequence
            // that contains modifiers such as "enter ctrl+space" and in most
            // cases the modifier key will be pressed before the next key
            //
            // also if you have a sequence such as "ctrl+b a" then pressing the
            // "b" key will trigger a "keypress" and a "keydown"
            //
            // the "keydown" is expected when there is a modifier, but the
            // "keypress" ends up matching the _nextExpectedAction since it occurs
            // after and that causes the sequence to reset
            //
            // we ignore keypresses in a sequence that directly follow a keydown
            // for the same character


            var ignoreThisKeypress = e.type == 'keypress' && _ignoreNextKeypress;

            if (e.type == _nextExpectedAction && !_isModifier(character) && !ignoreThisKeypress) {
              _resetSequences(doNotReset);
            }

            _ignoreNextKeypress = processedSequenceCallback && e.type == 'keydown';
          };
          /**
           * handles a keydown event
           *
           * @param {Event} e
           * @returns void
           */


          function _handleKeyEvent(e) {
            // normalize e.which for key events
            // @see http://stackoverflow.com/questions/4285627/javascript-keycode-vs-charcode-utter-confusion
            if (typeof e.which !== 'number') {
              e.which = e.keyCode;
            }

            var character = _characterFromEvent(e); // no character found then stop


            if (!character) {
              return;
            } // need to use === for the character check because the character can be 0


            if (e.type == 'keyup' && _ignoreNextKeyup === character) {
              _ignoreNextKeyup = false;
              return;
            }

            self.handleKey(character, _eventModifiers(e), e);
          }
          /**
           * called to set a 1 second timeout on the specified sequence
           *
           * this is so after each key press in the sequence you have 1 second
           * to press the next key before you have to start over
           *
           * @returns void
           */


          function _resetSequenceTimer() {
            clearTimeout(_resetTimer);
            _resetTimer = setTimeout(_resetSequences, 1000);
          }
          /**
           * binds a key sequence to an event
           *
           * @param {string} combo - combo specified in bind call
           * @param {Array} keys
           * @param {Function} callback
           * @param {string=} action
           * @returns void
           */


          function _bindSequence(combo, keys, callback, action) {
            // start off by adding a sequence level record for this combination
            // and setting the level to 0
            _sequenceLevels[combo] = 0;
            /**
             * callback to increase the sequence level for this sequence and reset
             * all other sequences that were active
             *
             * @param {string} nextAction
             * @returns {Function}
             */

            function _increaseSequence(nextAction) {
              return function () {
                _nextExpectedAction = nextAction;
                ++_sequenceLevels[combo];

                _resetSequenceTimer();
              };
            }
            /**
             * wraps the specified callback inside of another function in order
             * to reset all sequence counters as soon as this sequence is done
             *
             * @param {Event} e
             * @returns void
             */


            function _callbackAndReset(e) {
              _fireCallback(callback, e, combo); // we should ignore the next key up if the action is key down
              // or keypress.  this is so if you finish a sequence and
              // release the key the final key will not trigger a keyup


              if (action !== 'keyup') {
                _ignoreNextKeyup = _characterFromEvent(e);
              } // weird race condition if a sequence ends with the key
              // another sequence begins with


              setTimeout(_resetSequences, 10);
            } // loop through keys one at a time and bind the appropriate callback
            // function.  for any key leading up to the final one it should
            // increase the sequence. after the final, it should reset all sequences
            //
            // if an action is specified in the original bind call then that will
            // be used throughout.  otherwise we will pass the action that the
            // next key in the sequence should match.  this allows a sequence
            // to mix and match keypress and keydown events depending on which
            // ones are better suited to the key provided


            for (var i = 0; i < keys.length; ++i) {
              var isFinal = i + 1 === keys.length;
              var wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);

              _bindSingle(keys[i], wrappedCallback, action, combo, i);
            }
          }
          /**
           * binds a single keyboard combination
           *
           * @param {string} combination
           * @param {Function} callback
           * @param {string=} action
           * @param {string=} sequenceName - name of sequence if part of sequence
           * @param {number=} level - what part of the sequence the command is
           * @returns void
           */


          function _bindSingle(combination, callback, action, sequenceName, level) {
            // store a direct mapped reference for use with Mousetrap.trigger
            self._directMap[combination + ':' + action] = callback; // make sure multiple spaces in a row become a single space

            combination = combination.replace(/\s+/g, ' ');
            var sequence = combination.split(' ');
            var info; // if this pattern is a sequence of keys then run through this method
            // to reprocess each pattern one key at a time

            if (sequence.length > 1) {
              _bindSequence(combination, sequence, callback, action);

              return;
            }

            info = _getKeyInfo(combination, action); // make sure to initialize array if this is the first time
            // a callback is added for this key

            self._callbacks[info.key] = self._callbacks[info.key] || []; // remove an existing match if there is one

            _getMatches(info.key, info.modifiers, {
              type: info.action
            }, sequenceName, combination, level); // add this call back to the array
            // if it is a sequence put it at the beginning
            // if not put it at the end
            //
            // this is important because the way these are processed expects
            // the sequence ones to come first


            self._callbacks[info.key][sequenceName ? 'unshift' : 'push']({
              callback: callback,
              modifiers: info.modifiers,
              action: info.action,
              seq: sequenceName,
              level: level,
              combo: combination
            });
          }
          /**
           * binds multiple combinations to the same callback
           *
           * @param {Array} combinations
           * @param {Function} callback
           * @param {string|undefined} action
           * @returns void
           */


          self._bindMultiple = function (combinations, callback, action) {
            for (var i = 0; i < combinations.length; ++i) {
              _bindSingle(combinations[i], callback, action);
            }
          }; // start!


          _addEvent(targetElement, 'keypress', _handleKeyEvent);

          _addEvent(targetElement, 'keydown', _handleKeyEvent);

          _addEvent(targetElement, 'keyup', _handleKeyEvent);
        }
        /**
         * binds an event to mousetrap
         *
         * can be a single key, a combination of keys separated with +,
         * an array of keys, or a sequence of keys separated by spaces
         *
         * be sure to list the modifier keys first to make sure that the
         * correct key ends up getting bound (the last key in the pattern)
         *
         * @param {string|Array} keys
         * @param {Function} callback
         * @param {string=} action - 'keypress', 'keydown', or 'keyup'
         * @returns void
         */


        Mousetrap.prototype.bind = function (keys, callback, action) {
          var self = this;
          keys = keys instanceof Array ? keys : [keys];

          self._bindMultiple.call(self, keys, callback, action);

          return self;
        };
        /**
         * unbinds an event to mousetrap
         *
         * the unbinding sets the callback function of the specified key combo
         * to an empty function and deletes the corresponding key in the
         * _directMap dict.
         *
         * TODO: actually remove this from the _callbacks dictionary instead
         * of binding an empty function
         *
         * the keycombo+action has to be exactly the same as
         * it was defined in the bind method
         *
         * @param {string|Array} keys
         * @param {string} action
         * @returns void
         */


        Mousetrap.prototype.unbind = function (keys, action) {
          var self = this;
          return self.bind.call(self, keys, function () {}, action);
        };
        /**
         * triggers an event that has already been bound
         *
         * @param {string} keys
         * @param {string=} action
         * @returns void
         */


        Mousetrap.prototype.trigger = function (keys, action) {
          var self = this;

          if (self._directMap[keys + ':' + action]) {
            self._directMap[keys + ':' + action]({}, keys);
          }

          return self;
        };
        /**
         * resets the library back to its initial state.  this is useful
         * if you want to clear out the current keyboard shortcuts and bind
         * new ones - for example if you switch to another page
         *
         * @returns void
         */


        Mousetrap.prototype.reset = function () {
          var self = this;
          self._callbacks = {};
          self._directMap = {};
          return self;
        };
        /**
         * should we stop this event before firing off callbacks
         *
         * @param {Event} e
         * @param {Element} element
         * @return {boolean}
         */


        Mousetrap.prototype.stopCallback = function (e, element) {
          var self = this; // if the element has the class "mousetrap" then no need to stop

          if ((' ' + element.className + ' ').indexOf(' mousetrap ') > -1) {
            return false;
          }

          if (_belongsTo(element, self.target)) {
            return false;
          } // Events originating from a shadow DOM are re-targetted and `e.target` is the shadow host,
          // not the initial event target in the shadow tree. Note that not all events cross the
          // shadow boundary.
          // For shadow trees with `mode: 'open'`, the initial event target is the first element in
          // the event’s composed path. For shadow trees with `mode: 'closed'`, the initial event
          // target cannot be obtained.


          if ('composedPath' in e && typeof e.composedPath === 'function') {
            // For open shadow trees, update `element` so that the following check works.
            var initialEventTarget = e.composedPath()[0];

            if (initialEventTarget !== e.target) {
              element = initialEventTarget;
            }
          } // stop for input, select, and textarea


          return element.tagName == 'INPUT' || element.tagName == 'SELECT' || element.tagName == 'TEXTAREA' || element.isContentEditable;
        };
        /**
         * exposes _handleKey publicly so it can be overwritten by extensions
         */


        Mousetrap.prototype.handleKey = function () {
          var self = this;
          return self._handleKey.apply(self, arguments);
        };
        /**
         * allow custom key mappings
         */


        Mousetrap.addKeycodes = function (object) {
          for (var key in object) {
            if (object.hasOwnProperty(key)) {
              _MAP[key] = object[key];
            }
          }

          _REVERSE_MAP = null;
        };
        /**
         * Init the global mousetrap functions
         *
         * This method is needed to allow the global mousetrap functions to work
         * now that mousetrap is a constructor function.
         */


        Mousetrap.init = function () {
          var documentMousetrap = Mousetrap(document);

          for (var method in documentMousetrap) {
            if (method.charAt(0) !== '_') {
              Mousetrap[method] = function (method) {
                return function () {
                  return documentMousetrap[method].apply(documentMousetrap, arguments);
                };
              }(method);
            }
          }
        };

        Mousetrap.init(); // expose mousetrap to the global object

        window.Mousetrap = Mousetrap; // expose as a common js module

        if (true && module.exports) {
          module.exports = Mousetrap;
        } // expose mousetrap as an AMD module


        if (true) {
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return Mousetrap;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
      })(typeof window !== 'undefined' ? window : null, typeof window !== 'undefined' ? document : null);
      /***/

    },

    /***/
    13653: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "skip": function skip() {
          return (
            /* binding */
            _skip
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _Subscriber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ../Subscriber */
      77393);

      function _skip(count) {
        return function (source) {
          return source.lift(new SkipOperator(count));
        };
      }

      var SkipOperator = /*#__PURE__*/function () {
        function SkipOperator(total) {
          _classCallCheck(this, SkipOperator);

          this.total = total;
        }

        _createClass(SkipOperator, [{
          key: "call",
          value: function call(subscriber, source) {
            return source.subscribe(new SkipSubscriber(subscriber, this.total));
          }
        }]);

        return SkipOperator;
      }();

      var SkipSubscriber = /*#__PURE__*/function (_Subscriber__WEBPACK_) {
        _inherits(SkipSubscriber, _Subscriber__WEBPACK_);

        var _super9 = _createSuper(SkipSubscriber);

        function SkipSubscriber(destination, total) {
          var _this24;

          _classCallCheck(this, SkipSubscriber);

          _this24 = _super9.call(this, destination);
          _this24.total = total;
          _this24.count = 0;
          return _this24;
        }

        _createClass(SkipSubscriber, [{
          key: "_next",
          value: function _next(x) {
            if (++this.count > this.total) {
              this.destination.next(x);
            }
          }
        }]);

        return SkipSubscriber;
      }(_Subscriber__WEBPACK_IMPORTED_MODULE_0__.Subscriber); //# sourceMappingURL=skip.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default-node_modules_ks89_angular-modal-gallery___ivy_ngcc___fesm2015_ks89-angular-modal-gall-4edc15-es5.js.map